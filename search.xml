<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OKVoice_note_api</title>
      <link href="2020/04/29/OKVoice_note_api/"/>
      <url>2020/04/29/OKVoice_note_api/</url>
      
        <content type="html"><![CDATA[<h1 id="okvoiceAPI"><a href="#okvoiceAPI" class="headerlink" title="okvoiceAPI"></a>okvoiceAPI</h1><p>okvoice开发者中心 <a href="http://dev.okvoice.com" target="_blank" rel="noopener">http://dev.okvoice.com</a><br>okvoice在线api    <a href="http://dev.okvoice.com/file.php" target="_blank" rel="noopener">http://dev.okvoice.com/file.php</a></p><ul><li><p>简介<br>OKVoice TTS REST API为开发者提供一个通用的开发接口，基于该接口，<br>开发者可以方便的为应用集成TTS功能，本文档描述了使用TTS REST API的方法。<br>使用API需要以下条件：</p><ol><li>需要申请 API Key 用于验证开发者</li><li>使用过程中应用需要通过互联网连接到OKVoice 云平台</li></ol></li><li><p>访问控制<br>OKVoice 通过apiKey/apiSecretKey对称加密来验证某个请求的发送者身份，<br>apiKey用来标示app，apiSecretKey是用来签名加密的密钥，所以apiSecretKey必须保密。<br>当用户发送一个请求时，首先按照OKVoice指定的格式生成签名字符串，然后使用apiSecretKey对签名字符串进行加密产生验证码。<br>OKVoice收到请求后会根据apiKey找到对应的apiSecretKey，然后用同样的方式产生验证码，如果计算出来的验证码跟请求的一样则认为请求有效，<br>否则拒绝这次请求，并返回403错误。</p></li><li><p>申请apiKey/apiSecretKey<br>  apiKey/apiSecretKey 需要在okvoice开发者平台(<a href="http://dev.okvoice.com/)申请账号，然后点击用户名，进入我的账号。" target="_blank" rel="noopener">http://dev.okvoice.com/)申请账号，然后点击用户名，进入我的账号。</a><br>  在我的账号添加app应用，在应用管理中可以查看app应用一个列表。<br>  每个项都存在一个apiKey(KEY)与apiSecretKey(Secret)。</p></li><li><p>API验证机制</p><ol><li><p>signature=HMAC-SHA1(arg1=v1&amp;arg2=v2)<br>  生成签名字符串<br>  首先，对整个请求参数列表中的参数按照参数名字典序进行排序。(说明:按参数的字母排序)<br>  其次，把所有参数对以’&amp;’字符连接起来，最终形成待签名字符串。<br>关于参数的签名字符串组装问题:<br>如:apiKey=920c657431d374436117b00f9b18be78<br>&amp;expires=1446445018&amp;format=MP3<br>&amp;speed=0.3<br>&amp;text=&lt;py=a1&gt;啊</py><br>&amp;voice=cnfemale<br>  上面的便是一个参数完整的待签名字符串。<br>参数说明如下</p><ul><li>apiKey : 为app的KEY，即apiKey                        </li><li>expires: 为过期时间:可以这样处理 Date.now().slice(0,-3)取到当前时间的秒数 然后加上一定的时间 Date.now().slice(0,-3)+3600<br>这样设置过期时间为1小时。</li><li>format : 语音的格式。WVA与MP3 默认为MP3</li><li>speed  : 语速 取值0.2-5(官方文档为—- 负5到5 -&gt; -5到5 ) 小于1为慢速，大于1为快速，默认为1(正常情况)</li><li>text   : 需要合成的文本，说明关于多音字的问题 如’啊’是一个多音字，那么需要将’啊’包裹在&lt;py=a1&gt;</py>中这里的啊为一声。</li><li>voice  : 声音类型如下<ul><li>cnmale         普通话男声</li><li>cnfemale       普通话女声</li><li>cnctmale       粤语男声</li><li>cnctfemale     粤语女声</li><li>enmale         英语男声</li><li>enfemale       英语女声 </li></ul></li></ul></li><li><p>使用hmac-sha1方法签名，其中Key为apiSecretKey<br>说明：hmac-sha1方法签名有很多库<br>目前MBEditor采用的是CryptoJS进行签名—-<a href="https://github.com/brix/crypto-js/" target="_blank" rel="noopener">https://github.com/brix/crypto-js/</a><br>CryptoJS.HmacSHA1(signature, okvoiceapisecretkey)<br>签名参数说明第一个为待签名的字符串，第二个为一个KEY。<br>这里对参数做下解释：signature为待签名的字符串，okvoiceapisecretkey为对应的apiKey/apiSecretKey中的apiSecretKey的值，即Secret</p></li><li><p>把”signature=签名结果字符串”加入请求参数列表<br>    apiKey=920c657431d374436117b00f9b18be78<br>&amp;expires=1446445018<br>&amp;speed=0.3<br>&amp;text=&lt;py=a1&gt;啊</py><br>&amp;voice=cnfemale<br>&amp;signature=CryptoJS.HmacSHA1(signture, okvoiceapisecretkey)<br>下面是一个完整okvoice的请求地址<br>ttp://api.okvoice.com/tts?apiKey=920c657431d374436117b00f9b18be78&amp;expires=1446445018&amp;speed=0.3&amp;text=&lt;py=a1&gt;啊</py>&amp;voice=cnfemale&amp;signature=d610bae4113e17de24475ab0c06396ab7dae7a74<br>说明signature参数后面的字符串是CryptoJS.HmacSHA1(signature, okvoiceapisecretkey)的返回值<br>    注意：待签名字符串必须是UTF-8编码</p></li></ol></li><li><p>API 接口说明</p><ol><li><p>请求类型及URL<br>接口类型          输入数据格式     URL<br>HTTP GET/POST     URL Encoded     <a href="http://api.okvoice.com/tts" target="_blank" rel="noopener">http://api.okvoice.com/tts</a></p></li><li><p>请求参数<br>参数                数据类型          是否必选        说明<br>apiKey              String              是          Api key<br>signature              String              是          签名字符串<br>expires                Int                  是          请求超时时间，自UTC1970-01-01开始的秒数<br>text                String              是          需要合成的文本<br>voice                String              否          声音类型，语言+性别，默认cnmale<br>format              String              否          音频格式（WAV，MP3），默认MP3<br>speed                Int                  否          语音速度，-5–5默认1 //实际值为0.2-5 大于1语速加快，小于1语速变慢<br> <br>Voice参数<br>取值                说明<br>cnmale              普通话男声<br>cnfemale              普通话女声<br>cnctmale              粤语男声<br>cnctfemale            粤语女声<br>enmale              英语男声<br>enfemale              英语女声</p></li><li><p>响应结果<br>HTTP response     说明<br>200             成功，返回音频数据<br>202             失败，返回json数据，包含错误码及错误信息<br>403             签名验证失败，禁止访问</p></li><li><p>错误码<br>错误码            描述<br>1001            非法请求<br>1002            API key 非法<br>1003            鉴权验证失败<br>1004            转换文本失败<br>1005            非法文本<br>1006            文本超长<br>1007            非法参数<br>1008            不支持的voice类型</p></li></ol></li></ul><p>目前采用账号为个人账号<br>apiKey             920c657431d374436117b00f9b18be78<br>apiSecretKey       fd1993ac9dd85cdb6b8f08a16c30ce8c</p><p>应用控件：生字教学 mainbo_wordteaching，<br>         词语教学 mainbo_vocateaching</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Epub_analysis</title>
      <link href="2017/06/16/Epub-analysis-md/"/>
      <url>2017/06/16/Epub-analysis-md/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Epub-制作数字图书-基于XML的开放式eBook格式"><a href="#使用Epub-制作数字图书-基于XML的开放式eBook格式" class="headerlink" title="使用Epub 制作数字图书 基于XML的开放式eBook格式"></a>使用Epub 制作数字图书 基于XML的开放式eBook格式</h1><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>是否需要分发文档、创建电子图书或者把喜欢的博客文章存档？EPUB 是一种开放式的数字图书规范，以常用的技术如 XML、CSS 和 XHTML 为基础，EPUB 文件可在便携式的 e-ink 设备、移动电话和桌面计算机上阅读。本教程详细阐述了 EPUB 格式，首先用 Java™ 技术示范了 EPUB 验证，然后详细说明如何使用 DocBook 和 Python 自动创建 EPUB。</p><h2 id="常用的缩写词"><a href="#常用的缩写词" class="headerlink" title="常用的缩写词"></a>常用的缩写词</h2><ul><li>API：应用程序编程接口（application programming interface）</li><li>CSS：级联样式表（Cascading stylesheet)</li><li>DOM: 文档对象模型（Document Object Model)</li><li>DTD: 文档类型定义（Document type definition）</li><li>GUI: 图形用户界面（Graphical user interface）</li><li>HTML： 超文本标记语言（Hypertext Markup Language）</li><li>SAX: XML简易API(simple API For XML)</li><li>W3C: 万维网联盟（World Wide Web Consortium）</li><li>XHTML: 可拓展的HTML（Extendsible HTML）</li><li>XMl: 可拓展标记语言</li></ul><p>关于 EPUB 格式</p><p>了解 EPUB 的背景，EPUB 最适合做什么，以及 EPUB 和便携式文档格式（PDF）的区别。</p><p>什么是 EPUB？</p><p>EPUB 是可逆的数字图书和出版物 XML 格式，数字出版业商业和标准协会 International Digital Publishing Forum (IDPF) 制定的标准。IDPF 于 2007 年 10 月正式采用 EPUB，随后被主流出版商迅速采用。可以使用各种开放源代码或者商业软件在所有主流操作系统、Sony PRS 之类的 e-ink 设备或者 Apple iPhone 之类的小型设备上阅读 EPUB 格式。</p><p>谁在使用 EPUB？只能用于图书吗？</p><p>虽然最早采用 EPUB 的是传统的印刷品出版商，但是这并不妨碍它在电子图书中的应用。利用免费的软件工具，可以将网页捆绑成 EPUB，转化成文本文件或者将原有的 DocBook XML 文档转化成结构良好的、有效的 EPUB</p><p>EPUB 与 PDF 有什么不同？</p><p>PDF 仍然是世界上应用最广泛的电子文档格式。从图书出版商的角度来看，PDF 的优点包括：</p><p>PDF 文件允许对页面布局进行像素级的控制，包括复杂的打印格式，如多栏格式和奇偶页相间的格式。<br>有多种不同的 GUI 文档工具可生成 PDF，如 Microsoft® Office Word 和 Adobe® InDesign®。<br>PDF 阅读器非常普及，现在大多数计算机上都有安装。<br>PDF 可以嵌入特殊的字体，精确控制最终的输出结果</p><h2 id="三合一标准"><a href="#三合一标准" class="headerlink" title="三合一标准"></a>三合一标准</h2><p>EPUB 包括三个单独的 IDPF 规范，虽然实际上将其统称为 EPUB 更保险：</p><ul><li>Open eBook Publication Structure Container Format (OCF)：定义了 EPUB 档案的目录树结构和文件结构（ZIP）。</li><li>Open Publication Structure (OPS)：定义了电子图书的公共词汇表，特别是可作为图书内容的格式（比如 XHTML 和 CSS）。</li><li>Open Packaging Format (OPF)：描述了 EPUB 必须的和可选的元数据、阅读顺序和目录。</li></ul><p>此外，对于档案中的特定类型的内容，EPUB 还重用了其他一些标准，如 XHTML 1.0 和 Digital Accessible Information SYstem (DAISY)。</p><p>从软件开发人员的角度来看，PDF 还远远不够理想：</p><p>这不是一种简单易学的标准，因此编写自己的 PDF 生成代码非常困难。<br>虽然 PDF 现在是一种 International Organization for Standardization（ISO）标准（ISO 32000-1:2008），但过去一直受一家公司的控制：Adobe Systems。<br>尽管多数编程语言都提供了 PDF 库，但很多是商业产品或者嵌入到 GUI 应用程序中，外部进程不容易控制。并非所有的免费库都得到积极的维护。<br>PDF 原生文本可以通过程序提取出来并进行搜索，但很少可以对 PDF 进行标记以便简单可靠地转化成 Web 友好的格式。<br>PDF 文档不容易流动，就是说很难适应小屏幕或者对布局进行明显的改变。<br>为何说 EPUB 对开发人员是友好的</p><p>EPUB 解决了 PDF 和开发人员友好性有关的所有瑕疵。一个 EPUB 就是一个简单 ZIP 格式文件（使用 .epub 扩展名），其中包括按照预先定义的方式排列的文件。如何制作 ZIP 文档有一些技巧，稍后将在 将 EPUB 文件捆绑为 ZIP 文档 一节介绍。除此以外，EPUB 非常简单：</p><p>EPUB 中的所有内容基本上都是 XML。EPUB 文件可使用标准 XML 工具创建，不需要任何专门或者私有的软件。<br>EPUB 内容（eBook 的具体内容）基本上都是 XHTML 1.1（另一种格式是 DTBook，为视力受限者编码书籍的一种标准。关于 DTBook 的更多信息请参阅 参考资料，本教程中不涉及这部分）。<br>大多数 EPUB XML 模式都来自现成的、可免费获得的、已发布的规范。<br>最关键的在于 EPUB 元数据是 XML，EPUB 内容是 XHTML。如果您的文档构建系统产生的结果用于 Web 和/或基于 XML，那么也可用于生成 EPUB。</p><h2 id="开始创建"><a href="#开始创建" class="headerlink" title="开始创建"></a>开始创建</h2><p>分析EPUB包<br>小型 EPUB 文件的基本结构遵循 清单 1 所示的样式。准备好分发之前，整个目录结构被压缩到一个 ZIP 格式文件中，几点特殊要求将在 用 ZIP 打包 EPUB 文件 一节讨论</p><h4 id="清单1-EPUB的目录和文件结构"><a href="#清单1-EPUB的目录和文件结构" class="headerlink" title="清单1. EPUB的目录和文件结构"></a>清单1. EPUB的目录和文件结构</h4><p>如下</p><pre><code>  mimetype    META-INf/      container.xml    OEBPS/      content.opf      title.html      content.html      stylesheet.css      toc.ncx      image/        cover.png  </code></pre><p>提示：可下载符合该结构的一个电子图书，但建议还是按照以上所述自己创建一个。</p><p>mimetype 文件<br>这个文件必须命名为 mimetype ，文件内容如下：</p><pre><code>  application/epub+zip</code></pre><p>要注意，mimetype 文件不能包含新行或者回车。<br>此外，mimetype 文件必须作为 ZIP 档案中的第一个文件，而且自身不能压缩。用 ZIP 打包 EPUB 文件 一节将介绍如何使用一般的 ZIP 参数将其包含进来。现在创建该文件并保存，并确保它在 EPUB 项目的根目录中。</p><p>META-INF/container.xml</p><p>EPUB 根目录下必须包含 META-INF 目录，而且其中要有一个文件 container.xml。EPUB 阅读系统首先查看该文件，它指向数字图书元数据的位置。</p><p>创建目录 META-INF。在其中创建一个新文件 container.xml。container 文件非常小，但是对结构要求很严格。将 清单 2 中的代码粘贴到 META-INF/container.xml 中。</p><h4 id="清单2-container-xml文件"><a href="#清单2-container-xml文件" class="headerlink" title="清单2. container.xml文件"></a>清单2. container.xml文件</h4><pre><code>  &lt;?xml version=&quot;1.0&quot;?&gt;  &lt;container version=&quot;1.0&quot; xmlns=&quot;urn:oasis:names:tc:opendocument:xmlns:container&quot;&gt;  &lt;rootfiles&gt;    &lt;rootfile full-path=&quot;OEBPS/content.opf&quot;     media-type=&quot;application/oebps-package+xml&quot; /&gt;  &lt;/rootfiles&gt;  &lt;/container&gt;</code></pre><p>full-path的值(OEBPS/content.opf)仅仅是该文件的一部分，不同的文件可能相差甚大。目录路径必须相对于 EPUB 文件根目录本身，而不是 META-INF 目录</p><h3 id="关于-META-INF"><a href="#关于-META-INF" class="headerlink" title="关于 META-INF"></a>关于 META-INF</h3><p>META-INF 目录还可以包含其他几个文件。这些文件使 EPUB 支持数字签名、加密和数字版权管理（DRM）。本教程不讨论这些主题。更多信息请参阅 OCF 规范</p><p>mimetype 和 container 是 EPUB 档案中仅有的两个需要严格限制位置的文件。建议（尽管不是必须的）将其他文件保存到 EPUB 的子目录下（按照惯例，通常被称为 OEBPS，即 Open eBook Publication Structure，但不是必须的）。</p><p>接下来在 EPUB 项目中创建目录 OEBPS。本教程下一节将介绍 OEBPS 中的文件 — 数字图书的核心：元数据和页面。<br>创建 OEBPS/content.opf 并粘贴 清单 3 所示的内容。</p><h4 id="清单-3-包含示例元数据的-OPF-content-文件"><a href="#清单-3-包含示例元数据的-OPF-content-文件" class="headerlink" title="清单 3. 包含示例元数据的 OPF content 文件"></a>清单 3. 包含示例元数据的 OPF content 文件</h4><pre><code>&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;&lt;package xmlns=&quot;http://www.idpf.org/2007/opf&quot;             xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot;             unique-identifier=&quot;bookid&quot; version=&quot;2.0&quot;&gt;  &lt;metadata&gt;    &lt;dc:title&gt;Hello World: My First EPUB&lt;/dc:title&gt;    &lt;dc:creator&gt;My Name&lt;/dc:creator&gt;    &lt;dc:identifier id=&quot;bookid&quot;&gt;urn:uuid:12345&lt;/dc:identifier&gt;    &lt;meta name=&quot;cover&quot; content=&quot;cover-image&quot; /&gt;  &lt;/metadata&gt;  &lt;manifest&gt;    &lt;item id=&quot;ncx&quot; href=&quot;toc.ncx&quot; media-type=&quot;text/xml&quot;/&gt;    &lt;item id=&quot;cover&quot; href=&quot;title.html&quot; media-type=&quot;application/xhtml+xml&quot;/&gt;    &lt;item id=&quot;content&quot; href=&quot;content.html&quot; media-type=&quot;application/xhtml+xml&quot;/&gt;    &lt;item id=&quot;cover-image&quot; href=&quot;images/cover.png&quot; media-type=&quot;image/png&quot;/&gt;    &lt;item id=&quot;css&quot; href=&quot;stylesheet.css&quot; media-type=&quot;text/css&quot;/&gt;  &lt;/manifest&gt;  &lt;spine toc=&quot;ncx&quot;&gt;    &lt;itemref idref=&quot;cover&quot; linear=&quot;no&quot;/&gt;    &lt;itemref idref=&quot;content&quot;/&gt;  &lt;/spine&gt;  &lt;guide&gt;    &lt;reference href=&quot;cover.html&quot; type=&quot;cover&quot; title=&quot;Cover&quot;/&gt;  &lt;/guide&gt;&lt;/package&gt;</code></pre><p><strong>OPF 模式与名称空间</strong></p><p>OPF 文档本身必须使用名称空间 <a href="http://www.idpf.org/2007/opf，元数据则使用" target="_blank" rel="noopener">http://www.idpf.org/2007/opf，元数据则使用</a> Dublin Core Metadata Initiative (DCMI) 名称空间 <a href="http://purl.org/dc/elements/1.1/。" target="_blank" rel="noopener">http://purl.org/dc/elements/1.1/。</a></p><p>最好现在将 OPF 和 DCMI 模式添加到 XML 编辑器中。EPUB 用到的所有模式都可以 下载。</p><p><strong>元数据</strong></p><p>Dublin Core 定义了一组常用的元数据，可用于描述各种不同的数字资料，它不是 EPUB 规范的一部分。所有这些术语都可以出现在 OPF 元数据部分。编写要分发的 EPUB 时，这里可以放很多内容，目前来说 清单 4 的内容就足够了。</p><h4 id="清单-4-OPF-元数据摘要"><a href="#清单-4-OPF-元数据摘要" class="headerlink" title="清单 4. OPF 元数据摘要"></a>清单 4. OPF 元数据摘要</h4><pre><code>  ...  &lt;metadata&gt;    &lt;dc:title&gt;Hello World: My First EPUB&lt;/dc:title&gt;    &lt;dc:creator&gt;My Name&lt;/dc:creator&gt;    &lt;dc:identifier id=&quot;bookid&quot;&gt;urn:uuid:12345&lt;/dc:identifier&gt;    &lt;meta name=&quot;cover&quot; content=&quot;cover-image&quot; /&gt;  &lt;/metadata&gt;..</code></pre><p>有两个术语是必须的，即 title 和 identifier。按照 EPUB 规范，标识符必须 是惟一的，但是这个惟一的值要靠数字图书的创建者来定义。对于图书出版商来说，这个字段一般包含 ISBN 或者 Library of Congress 编号。对于其他 EPUB 创建者，可以考虑使用 URL 或者很大的随机生成的惟一用户 ID（UUID）。要注意，属性 unique-identifier 的值必须和 dc:identifier 元素的 ID 属性匹配。</p><p>其他和内容相关的可以考虑添加的元数据包括：</p><ul><li>语言（如 dc:language）。</li><li>出版日期（如 dc:date）。</li><li>出版商（如 dc:publisher）。（可以是公司或个人的名称）。</li><li>版权信息（如 dc:rights）。（如果采用 Creative Commons 许可证，可以将许可证的 URL 放在这里）。</li><li>关于 DCMI 的更多信息请参阅 参考资料。</li></ul><p>EPUB 规范没有要求包含 name 属性值为 cover 的 meta 元素，但为了增加封面和图像的可移植性，建议这样做。一些 EPUB 呈现程序喜欢使用图像文件作为封面，另一些则愿意使用包含内联封面图像的 XHTML 文件。该例子显示了这两种情况。meta 元素的 content 属性的值应该是图书封面图像在 manifest 中的 ID 号，manifest 是 OPF 文件的一部分。</p><p><strong>Manifest</strong></p><p>OPF manifest 列出了 EPUB 内容（不包括元数据）中的所有资源。就是说，通常是组成电子图书文本的一组 XHTML 文件再加上一些相关的媒体如图像。EPUB 鼓励使用 CSS 设定图书内容的样式，因此 manifest 中也包含 CSS。进入数字图书的所有文件都必须在 manifest 中列出。</p><p>清单 5 显示了 manifest 的一部分。</p><h4 id="清单-5-OPF-manifest-的一部分"><a href="#清单-5-OPF-manifest-的一部分" class="headerlink" title="清单 5. OPF manifest 的一部分"></a>清单 5. OPF manifest 的一部分</h4><pre><code>  ...  &lt;manifest&gt;    &lt;item id=&quot;ncx&quot; href=&quot;toc.ncx&quot; media-type=&quot;text/xml&quot;/&gt;    &lt;item id=&quot;cover&quot; href=&quot;title.html&quot; media-type=&quot;application/xhtml+xml&quot;/&gt;    &lt;item id=&quot;content&quot; href=&quot;content.html&quot; media-type=&quot;application/xhtml+xml&quot;/&gt;    &lt;item id=&quot;cover-image&quot; href=&quot;images/cover.png&quot; media-type=&quot;image/png&quot;/&gt;    &lt;item id=&quot;css&quot; href=&quot;stylesheet.css&quot; media-type=&quot;text/css&quot;/&gt;  &lt;/manifest&gt;  ...</code></pre><h3 id="高级-OPF-manifest"><a href="#高级-OPF-manifest" class="headerlink" title="高级 OPF manifest"></a>高级 OPF manifest</h3><p>更高级的 manifest 文件可能包含多个 XHTML 文件以及图像和 CSS。可 下载 一个完整的包含各种常见类型的 EPUB 例子。</p><p>第一项 toc.ncx（参见 下一节）是必须的。所有的项都有相应的 media-type 值，XHTML 内容的媒体类型为 application/xhtml+xml。媒体类型必须正确，不能 是 text/html 或者其他类型。</p><p>EPUB 支持四种核心 图像文件类型：Joint Photographic Experts Group (JPEG)、Portable Network Graphics (PNG)、Graphics Interchange Format (GIF) 和 Scalable Vector Graphics (SVG)。如果能够提供对核心类型的后退转换（fall-back），也可包含不支持的文件类型。关于后退转换内容的更多信息请参阅 OPF 规范。</p><p>href 属性的值应该是一个相对于该 OPF 文件 的统一资源标识符（URI）。（很容易和 container.xml 中对 OPF 文件的引用混淆，其中的引用是相对于 EPUB 的整体引用）。这里的 OPF 文件位于和内容相同的 OEBPS 目录中，因此不需要路径信息。</p><p><strong>Spine</strong></p><p>manifest 告诉 EPUB 阅读器哪些文件属于档案，spine 则指定这些文件出现的顺序或 — 按照 EPUB 的说法 — 数字图书的线性阅读顺序。可以将 OPF spine 看作是书中 “页面” 的顺序。按照文档顺序从上到下依次读取 spine。清单 6 显示了 OPF 文件的一个片段。</p><h4 id="清单-6-OPF-spine-的一部分"><a href="#清单-6-OPF-spine-的一部分" class="headerlink" title="清单 6. OPF spine 的一部分"></a>清单 6. OPF spine 的一部分</h4><pre><code>  ...  &lt;spine toc=&quot;ncx&quot;&gt;    &lt;itemref idref=&quot;cover&quot; linear=&quot;no&quot;/&gt;    &lt;itemref idref=&quot;content&quot;/&gt;  &lt;/spine&gt;  ...</code></pre><p>每个 itemref 元素都需要有一个 idref 属性，并且和 manifest 中的某个 ID 匹配。toc 属性也是必需的。它引用 manifest 中表示内容 NCX 表文件名的 ID。</p><p>spine 中的 linear 属性表明该项是作为线性阅读顺序中的一项，还是和先后次序无关。建议将封面定义为 linear=no。符合 EPUB 规范的阅读系统将首先打开 spine 中没有 设置为 linear=no 中的第一项。</p><p><strong>Guide</strong></p><p>OPF 内容文件的最后一部分是 guide。这一节是可选的，但最好保留。清单 7 显示了 guide 文件的部分内容。</p><pre><code>  ...  &lt;guide&gt;    &lt;reference href=&quot;cover.html&quot; type=&quot;cover&quot; title=&quot;Cover&quot;/&gt;  &lt;/guide&gt;  ...</code></pre><p>guide 可以为 EPUB 阅读系统提供语义信息。manifest 定义了 EPUB 中的物理资源，spine 提供了这些资源的顺序信息，guide 负责解释这些部分的含义。下面是可以出现在 OPF guide 中的部分值：</p><ul><li>cover：图书封面</li><li>title-page：包含作者和出版商信息的页面</li><li>toc：目录<br>完整的列表请参阅 OPF 2.0 规范（参见 参考资料）。</li></ul><h3 id="NCX-和-OPF元数据的交叉"><a href="#NCX-和-OPF元数据的交叉" class="headerlink" title="NCX 和 OPF元数据的交叉"></a>NCX 和 OPF元数据的交叉</h3><p>由于 NCX 源自其他标准，使用 NCX 编码的信息和 OPF 内容之间存在重复。如果通过程序生成 EPUB，这算不上什么问题，因为同样的代码可输出到两个文件中。两个位置的信息要一致，不同的 EPUB 读者可能使用不同位置的值。</p><p>尽管 OCF 文件是作为 EPUB 本身的一部分定义的，但最后一个主要的元数据文件参照了不同的数字图书标准。DAISY 是一个专门为不能使用传统书籍的读者设计数据格式的组织，通常是因为视力受损或者不便于使用印刷的书籍。EPUB 借用了 DAISY 的 NCX DTD。NCX 定义了数字图书的目录表。复杂的图书中，目录表通常采用层次结构，包括嵌套的内容、章和节。</p><p>使用 XML 编辑器创建 OEBPS/toc.ncx 并粘贴 清单 8 所示的代码。</p><pre><code>  &lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;  &lt;!DOCTYPE ncx PUBLIC &quot;-//NISO//DTD ncx 2005-1//EN&quot;                   &quot;http://www.daisy.org/z3986/2005/ncx-2005-1.dtd&quot;&gt;  &lt;ncx xmlns=&quot;http://www.daisy.org/z3986/2005/ncx/&quot; version=&quot;2005-1&quot;&gt;    &lt;head&gt;      &lt;meta name=&quot;dtb:uid&quot; content=&quot;urn:uuid:12345&quot;/&gt;      &lt;meta name=&quot;dtb:depth&quot; content=&quot;1&quot;/&gt;      &lt;meta name=&quot;dtb:totalPageCount&quot; content=&quot;0&quot;/&gt;      &lt;meta name=&quot;dtb:maxPageNumber&quot; content=&quot;0&quot;/&gt;    &lt;/head&gt;    &lt;docTitle&gt;      &lt;text&gt;Hello World: My First EPUB&lt;/text&gt;    &lt;/docTitle&gt;    &lt;navMap&gt;      &lt;navPoint id=&quot;navpoint-1&quot; playOrder=&quot;1&quot;&gt;        &lt;navLabel&gt;          &lt;text&gt;Book cover&lt;/text&gt;        &lt;/navLabel&gt;        &lt;content src=&quot;title.html&quot;/&gt;      &lt;/navPoint&gt;      &lt;navPoint id=&quot;navpoint-2&quot; playOrder=&quot;2&quot;&gt;        &lt;navLabel&gt;          &lt;text&gt;Contents&lt;/text&gt;        &lt;/navLabel&gt;        &lt;content src=&quot;content.html&quot;/&gt;      &lt;/navPoint&gt;    &lt;/navMap&gt;  &lt;/ncx&gt;</code></pre><p><strong>NCX 元数据</strong></p><p>DTD 要求 NCX <head> 标记中包含四个 meta 元素：</p><p>uid： 数字图书的惟一 ID。该元素应该和 OPF 文件中的 dc:identifier对应。<br>depth：反映目录表中层次的深度。该例只有一层，因此是 1。<br>totalPageCount 和 maxPageNumber：仅用于纸质图书，保留 0 即可。<br>docTitle/text 的内容是图书的标题，和 OPF 中的 dc:title 匹配。</p><p><strong>NCX navMap</strong></p><h3 id="NCX-和-OPF-spine-有什么不同？"><a href="#NCX-和-OPF-spine-有什么不同？" class="headerlink" title="NCX 和 OPF spine 有什么不同？"></a>NCX 和 OPF spine 有什么不同？</h3><p>两者很容易混淆，因为两个文件都描述了文档的顺序和内容。要说明两者的区别，最简单的办法就是拿印刷书来打比方：OPF spine 描述了书中的各个章节是如何实际连接起来的，比方说翻过第一章的最后一页就看到第二章的第一页。NCX 在图书的一开始描述了目录。目录肯定会包含书中主要的章节，但是还可能包含没有单独分页的小节。</p><p>一条法则是 NCX 包含的 navPoint 元素通常比 OPF spine 中的 itemref 元素多。实际上，spine 中的所有项都会出现在 NCX 中，但 NCX 可能更详细。</p><p>navMap 是 NCX 文件中最重要的部分，定义了图书的目录。navMap 包含一个或多个 navPoint 元素。每个 navPoint 都要包含下列元素：</p><ul><li>playOrder 属性，说明文档的阅读顺序。和 OPF spine 中 itemref元素的顺序相同。</li><li>navLabel/text元素，给出该章节的标题。通常是章的标题或者数字，如 “第一章”，或者 — 像这个例子一样 — “封面”。</li><li>content 元素，它的 src 属性指向包含这些内容的物理资源。就是 OPF manifest 中声明的文件（也可使用片段标识符引用 XHTML 内容中的锚元素 — 比如 content.html#footnote1）。</li><li>还可以有一个或多个 navPoint 元素。NCX 使用嵌套的导航点表示层次结构的文档。<br>该文档的结构非常简单：只有两页，不存在嵌套关系。就是说有两个 navPoint 元素，它们的 playOrder 值按升序排列，从 1 开始。在 NCX 中可以命名这些章节，以便读者跳到电子图书不同的部分。</li></ul><p>添加最后的内容</p><p>现在知道了 EPUB 需要的所有元数据，可以加入真正的图书内容了。可以使用 下载 的内容，也可以自己写，只要文件名和元数据匹配即可。</p><p>然后创建下列文件和文件夹：</p><ul><li>title.html：图书的标题页。创建该文件并在其中包含引用封面图片的 img 元素，src 的属性值为images/cover.png。</li><li>images：在 OEBPS 下创建该文件夹，然后复制给定的示例图片（或者创建自己的图片）并命名为 cover.png。</li><li>content.html：图书的实际文字内容。</li><li>stylesheet.css：将该文件放在和 XHTML 文件相同的 OEBPS 目录中。该文件可以包含任意 CSS 声明，比如设置字体或者文字颜色。清单 10 给出了一个 CSS 文件的例子。<br>EPUB 图书中的 XHTML 和 CSS</li></ul><p>清单 9 包含了一个有效的 EPUB 内容页。将其作为标题页（title.html），用一个类似的页面作为主要内容页（content.html）。</p><h4 id="清单-9-示例-title-页面（title-html）"><a href="#清单-9-示例-title-页面（title-html）" class="headerlink" title="清单 9. 示例 title 页面（title.html）"></a>清单 9. 示例 title 页面（title.html）</h4><pre><code>  &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;    &lt;head&gt;      &lt;title&gt;Hello World: My First EPUB&lt;/title&gt;      &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;stylesheet.css&quot; /&gt;    &lt;/head&gt;    &lt;body&gt;      &lt;h1&gt;Hello World: My First EPUB&lt;/h1&gt;      &lt;div&gt;&lt;img src=&quot;images/cover.png&quot; alt=&quot;Title page&quot;/&gt;&lt;/div&gt;    &lt;/body&gt;  &lt;/html&gt;</code></pre><p>EPUB 的 XHTML 需要符合几条要求，和一般的 Web 开发不同：</p><ul><li>内容必须是有效的 XHTML 1.1：XHTML 1.0 Strict 和 XHTML 1.1 的主要区别是去掉了 name属性（使用 ID 引用锚元素）。</li><li>img 元素只能引用电子图书的本地图片：该元素不能引用 Web 上的图片。</li><li>避免使用 script：EPUB 阅读器不一定支持 JavaScript 代码。<br>EPUB 支持 CSS 的方式有一些细微的差别，但是不会影响样式表的一般用法（详情参阅 OPS 规范）。清单 10 中的简单 CSS 文件可以设置基本的字体，并把标题设为红色。</li></ul><p>清单 10. 电子图书的示例样式表（stylesheet.css）</p><pre><code>  body {    font-family: sans-serif;       }  h1,h2,h3,h4 {    font-family: serif;         color: red;  }</code></pre><p>有趣的是，EPUB 非常支持 CSS 2 @font-face 规则，允许内嵌字体。如果创建技术文档，这点可能无关紧要，但是如果用多种语言或针对特定领域编写 EPUB，能够指定具体的字体数据就很有必要了。</p><p>现在已经准备好了创建 EPUB 图书所需的所有内容。下一节将按照 OCF 规范将图书装订起来，并看看如何进行验证。</p><h3 id="打包和检查-EPUB"><a href="#打包和检查-EPUB" class="headerlink" title="打包和检查 EPUB"></a>打包和检查 EPUB</h3><p>现在，应当可以对 EPUB 包进行打包。这个包可以是您自己创建的一本新书，也可使用从本文 下载 部分获得的原始文件。</p><p>用 ZIP 打包 EPUB 文件</p><p>EPUB 规范的 OEBPS Container Format 讨论了 EPUB 和 ZIP，最重要的几点是：</p><ul><li>档案中的第一个文件必须是 mimetype 文件（参见本教程 Mimetype一节）。mimetype 文件不能被压缩。这样非 ZIP 工具就能从 EPUB 包的第 30 个字节开始读取原始字节，从而发现 mimetype。</li><li>ZIP 档案不能加密。EPUB 支持加密，但不是在 ZIP 文件这一层上。<br>在类 UNIX® 操作系统上，使用 ZIP 2.3 可通过两个命令来创建 EPUB ZIP 文件，如 清单 11 所示（这些命令假设当前工作目录为 EPUB 项目。）</li></ul><h4 id="清单-11-将-EPUB-打包成有效的-epub-zip-文件"><a href="#清单-11-将-EPUB-打包成有效的-epub-zip-文件" class="headerlink" title="清单 11. 将 EPUB 打包成有效的 epub+zip 文件"></a>清单 11. 将 EPUB 打包成有效的 epub+zip 文件</h4><pre><code>$ zip -0Xq  my-book.epub mimetype$ zip -Xr9Dq my-book.epub *</code></pre><p>第一个命令创建了一个新的 ZIP 档案，并添加了没有进行压缩的 mimetype 文件。第二个命令添加其他内容。选项 -X 和 -D 最大限度地减少 .zip 文件中无关紧要的信息；-r 递归地包含 META-INF 和 OEBPS 目录的内容。</p><p>EPUB 验证</p><p>虽然 EPUB 标准并不很难，但其 XML 文件必须符合特定的模式。如果使用模式感知的 XML 编辑器生成元数据和 XHTML，就能事半功倍。对 EpubCheck 包进行最后检查（参见 参考资料）。</p><p>Adobe 负责维护 EpubCheck 包，它是采用 Berkeley Software Distribution (BSD) 许可证的开源项目。它是一个可以作为独立工具、Web 应用程序运行的 Java 程序，或者可以将它集成到在 Java Runtime Environment (JRE) 1.5 或更高版本下运行的应用程序中。</p><p>在命令行中运行非常简单。清单 12 给出了一个例子。</p><h4 id="清单-12-运行-EpubCheck-工具程序"><a href="#清单-12-运行-EpubCheck-工具程序" class="headerlink" title="清单 12. 运行 EpubCheck 工具程序"></a>清单 12. 运行 EpubCheck 工具程序</h4><pre><code>$ java -jar /path/to/epubcheck.jar my-book.epub</code></pre><p>如果没有创建辅助文件或者元数据文件出错，可能会看到 清单 13 所示的错误消息。</p><p>清单 13. EpubCheck 错误</p><pre><code>my-book.epub: image file OEBPS/images/cover.png is missingmy-book.epub: resource OEBPS/stylesheet.css is missingmy-book.epub/OEBPS/title.html(7): &#39;OEBPS/images/cover.png&#39;:      referenced resource missing in the packageCheck finished with warnings or errors!</code></pre><p>这时候可能需要设置 CLASSPATH 使它指向 EpubCheck 的安装位置，因为确实需要导入几个外部库。如果得到这样的消息则需要设置 CLASSPATH：</p><pre><code>org.xml.sax.SAXParseException: no implementation available for schema language    with namespace URI &quot;http://www.ascc.net/xml/schematron&quot;</code></pre><p>如果验证成功，就会看到 “No errors or warnings detected（没有检测到错误或警告）”。祝贺您完成了第一个 EPUB！</p><p>查看 EPUB</p><p>测试不仅仅是验证，还要保证书的外观看起来不错。样式表能正确工作吗？章节的逻辑顺序是否正确？书中是否包含了所有需要的内容？</p><p>有多重 EPUB 阅读器可供选择。图 1 显示了 Adobe Digital Editions (ADE) 的屏幕截图，这是最常用的 EPUB 阅读器。</p><p>参考<br><a href="http://www.cnblogs.com/linlf03/archive/2011/12/15/2285953.html" target="_blank" rel="noopener">http://www.cnblogs.com/linlf03/archive/2011/12/15/2285953.html</a><br><a href="https://www.ibm.com/developerworks/cn/xml/tutorials/x-epubtut/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/xml/tutorials/x-epubtut/index.html</a><br><a href="https://www.ibm.com/developerworks/xml/tutorials/x-epubtut/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/xml/tutorials/x-epubtut/index.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> epub </tag>
            
            <tag> 电子书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript_object</title>
      <link href="2017/04/01/javascript-object/"/>
      <url>2017/04/01/javascript-object/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript-的对象"><a href="#JavaScript-的对象" class="headerlink" title="JavaScript 的对象"></a>JavaScript 的对象</h1><h2 id="作为映射表的-JS-对象"><a href="#作为映射表的-JS-对象" class="headerlink" title="作为映射表的 JS 对象"></a>作为映射表的 JS 对象</h2><p>JS 对象的“可见”结构（从客户代码的角度去看）基本上是一个映射表，类似 Map, Dictionay 之类的数据结构。</p><p>映射表的键是个字符串，表示属性名，并且可以是任意字符串（包括空），不要求是合法的 JS 标识符。<br>只有合法的 JS 标识符可以用圆点表示法 <code>map.fontSize</code> ，否则只有用下标表示法 <code>map[&#39;font-size&#39;]</code>；如果属性名是个变量，也要用下标表示法 <code>map[propName]</code>。</p><p>映射表的值的类型是任意的，包括函数、null、undefined。</p><p>所有的属性总是公开可访问的。</p><p>一些基本操作：</p><ul><li>创建空映射表或空对象： <code>var map = Object.create(null)</code> 或 <code>var map = {}</code>（两者的不同在后面解释）。</li><li>读属性 <code>var v = map.prop</code> 或者 <code>var v = map[&#39;prop&#39;]</code></li><li>增加/修改属性 <code>map.prop = value</code> 或者 <code>map[&#39;prop&#39;] = value</code></li><li>删除属性 <code>delete map.prop</code> 或者 <code>delete map[&#39;prop&#39;]</code></li><li>取得所有的属性名 <code>var keys = Object.keys(map)</code>，返回一个字符串的数组。</li><li>属性是否存在 <code>if (&#39;prop&#39; in map)</code>；不至于混淆时也可以用 <code>if (map.prop !== undefined)</code> 或 <code>if (map.prop)</code>。</li><li>遍历 <code>for (var name in map) { map[name] = ... }</code></li></ul><p>用类似 Map 的结构来实现 JS 对象，给予了 JS 对象极大的灵活性。</p><p>JS 对象可以用字面量来表示，这也来带了很大的便利性。例如，对象字面量可以用来实现”命名参数“：<br><code>createElement({tag: &#39;img&#39;, src: &#39;a.png&#39;, width: 100, height: 100, alt: &#39;...&#39;})</code>。<br>这特别适用于参数数量较多，或很多参数是可选的情形。<br>对象字面量还演变出一种流行的跨平台数据文件格式 - JSON。</p><p>ES5 中没有专门的 Map 数据结构，一般都是拿对象来代替。但这也有一些缺点：</p><ul><li>键不能是字符串以外的类型</li><li>不支持弱引用，类似 Java 的 WeakHashMap</li></ul><p>ES2015(ES6) 有了专门的 <a href="http://ju.outofmemory.cn/entry/49982" target="_blank" rel="noopener">Map、Set、WeakMap 数据结构</a>，解决了上述问题。</p><h2 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h2><p>JS 中很方便的一个特性就是对象字面量，应该大量地使用。<br>例子：</p><pre><code class="js">function createCircle(r) {  var circle = {    // 数据成员    radius: r,    // 方法    getArea: function () {        var radius = this.radius;        return Math.PI * radius * radius;    },    // getter 和 setter，ES5    get area() { return this.getArea(); },    set area(a) { this.radius = Math.sqrt(a / Math.PI); },    // 简略的方法语法，ES2015    scale(s) { this.radius = this.radius * s; }  };  return circle;}var c1 = createCircle(3);</code></pre><p>不过，字面量上的方法都是对象的直接属性，会占用不必要的内存。下面会讨论解决的方法。</p><h2 id="基于原型的面向对象"><a href="#基于原型的面向对象" class="headerlink" title="基于原型的面向对象"></a>基于原型的面向对象</h2><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><p>什么是基于原型的面向对象？我们按照 JS 中的实现总结如下：</p><ul><li>没有类的概念，可以直接创建对象（通过字面量或者逐步添加属性）。</li><li>一个对象可以直接继承另一个对象，后者称为前者的原型。这个过程可以递归，形成原型链。</li><li>读取某对象的一个属性（包括调用方法）时，如果它本身没有定义，则沿着其原型链向上查找；如果它本身定义了，则会隐藏原型链上的同名属性。<br>这样就实现了继承和覆盖。写入一个属性时，不考虑原型，直接写入对象本身。</li><li>一个对象最多只有一个原型，也就是单继承。但多个对象可以共有一个原型。</li><li>对象的原型可以在运行时被任意变更。</li></ul><p>可以看出，基于原型的面向对象机制非常简单，没有类、构造器、接口等概念；而且也非常灵活，原型中增删的属性会立即反映到到派生的对象上。</p><p>JS 本质上只支持基于原型的面向对象，并没有类的概念。JS 最初创建的时候，为了实现起来简单，采用了基于原型的面向对象。<br>但当时出于营销的考虑，JS 被要求模仿 Java 的语法，因此糅合了一些基于类的面向对象的特征，主要是引入了构造器。<br>最终的结果是很糟糕的：两种面向对象风格都不完善，用起来都不顺手，造成了长达十几年的混乱。<br>直到最近，ES5 才完善了基于原型的面向对象，到 ES6 实现了基于类的面向对象。</p><h3 id="实际的例子"><a href="#实际的例子" class="headerlink" title="实际的例子"></a>实际的例子</h3><p>下面我们利用基于原型的面向对象创建一些“圆”对象。</p><pre><code class="js">//”圆“的原型var circle = {  r : 0, //这其实是不太必要，派生对象总是会覆盖它  getArea: function () { return this.r * this.r * 3.14; }};var c1 = Object.create(circle);c1.r = 1; //覆盖了circle.rvar c2 = Object.create(circle);c2.r = 2;c1.getArea(); //3.14 //getArea 读到的是 c1.r 而不是 circle.rc2.getArea(); //12.56</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">Object.create(prototype)</a> 函数是 ES5 引入的，根据给定的原型创建一个新对象。在 ES5 之前，这是无法直接做的。</p><p>还可以进一步继承：</p><pre><code class="js">//positionedCircle 增加了圆心坐标和求原点到圆心距离的方法var positionedCircle = Object.create(circle);positionedCircle.x = positionedCircle.y = 0;positionedCircle.getRange = function () {   return Math.sqrt(this.x * this.x + this.y * this.y); };var c3 = Object.create(positionedCircle);c3.r = c3.x = c3.y = 2; //覆盖 positionedCircle.x/yc3.getArea(); //12.56 //circle 的方法仍然有效c3.getRange(); //2.828</code></pre><p>这样，整体的继承关系可以用缩进表示为：</p><pre><code>Object.prototype  circle    c1    c2    positionedCircle      c3</code></pre><p>通过字面量创建的对象，如 circle，其原型总是 <code>Object.prototype</code>，基本上这就是所有 JS 对象的根原型了。</p><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>不过，上面的代码还有一个不足：创建对象需要的步骤太多。相比之下，等效的基于类的OO就只要一个表达式 <code>new Circle(5)</code>。</p><p>所以，基于原型的OO通常会提供“工厂方法”来创建对象，例如</p><pre><code class="js">circle.New = function NewCircle(r) {  var c = Object.create(this);  c.r = r;  return c;};var c4 = circle.New(4);c4.r; //4</code></pre><p>或者建立一种通用的“工厂方法”，利用命名参数：</p><pre><code class="js">function newObject(prototype, args) {  var c = Object.create(prototype);  for(var key in args) {    c[key] = args[key];  }  return c;}var c5 = newObject(positionedCircle, {x:1,y:2,r:3});c5.getRange(); //2.236</code></pre><h3 id="基于原型的面向对象模式"><a href="#基于原型的面向对象模式" class="headerlink" title="基于原型的面向对象模式"></a>基于原型的面向对象模式</h3><p>从上面的例子中可以看出，基于原型的OO有一个模式：行为（即方法）通常定义在原型对象上，而数据则定义在末端的派生对象上；原型对象通常是单例的，而末端的派生对象则可以有许多。用基于类的OO来类比，则前者相当于类，后者相当于实例。</p><p>JS 语言的内置对象基本上都应用了这个模式，例如数组的原型是 <code>Array.prototype</code> 对象，各种数组方法，如 push, concat, forEach, 都定义在这个对象上。</p><p>但是，有一些设计模式将方法也定义在末端派生对象上，例如：</p><pre><code class="js">//1.直接创建普通对象function makeCircle1(r) {  return {    r : r,    getArea: function () { return this.r * this.r * 3.14; }  };}//2.通过闭包封装数据function makeCircle2(r) {  return {    getRadius : function() { return r; },    getArea: function () { return r * r * 3.14; }  };}</code></pre><p>这样做代码固然是简单，但也有个很大的缺点：对象的内存占用增加了，因为（1）对象要增加几个指向方法的条目（2）每次创建对象都要创建新方法 – 尤其是闭包模式，这是不可避免的。</p><p>通过闭包封装数据还有一个缺点 – 不易调试，因为闭包捕获的变量对调试器也不可见（除非正好步入了闭包中）。而在 Java 等语言中，私有字段对调试器还是可见的，也可以通过反射获得。</p><p>那么怎么解决 JS 对象缺乏私有成员的问题呢？很多人采用命名约定，例如下划线开头的是私有成员。我赞成这种做法。毕竟，私有成员只是一种编码契约，并不提供运行时安全，没必要为此走得太远。</p><h3 id="运行时类型鉴别（RTTI）"><a href="#运行时类型鉴别（RTTI）" class="headerlink" title="运行时类型鉴别（RTTI）"></a>运行时类型鉴别（RTTI）</h3><p>运行时类型鉴别（RTTI）的方法是 <code>base.isPrototypeOf(derived)</code>，可以判断 base 是否在 derived 的原型链上。<br>这有点类似基于类的 Java 中的 <code>instanceof</code> 操作符。</p><pre><code class="js">circle.isPrototypeOf(c1); //truecircle.isPrototypeOf(c3); //truepositionedCircle.isPrototypeOf(c3); //truepositionedCircle.isPrototypeOf(c1); //falsecircle.isPrototypeOf(circle); //falseObject.prototype.isPrototypeOf(circle); //true</code></pre><h3 id="动态修改类型"><a href="#动态修改类型" class="headerlink" title="动态修改类型"></a>动态修改类型</h3><p>由于原型也是普通对象，我们可以在运行时给它添加新的方法：</p><pre><code class="js">positionedCircle.moveBy = function moveBy(dx, dy) { this.x += dx; this.y += dy;}c3.moveBy(-1, -1);c3.x; //1</code></pre><h3 id="属性-proto"><a href="#属性-proto" class="headerlink" title="属性 __proto__"></a>属性 <code>__proto__</code></h3><p>JS 对象的 <code>__proto__</code> 属性可用于读、写其原型对象。在 ECMAScript 规范中，对象的原型用<code>[[Prototype]]</code> 内部属性来表示，在 <code>__proto__</code> 出现之前，没有办法直接操作这个属性。</p><p><code>__proto__</code> 在 FF 和 webkit/Chrome 很早就实现，IE11 和 Edge 也实现了，并在 ES6 标准化。<br>同时，ES6 引入了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" rel="noopener"><code>Object.setPrototypeOf(o, prototype)</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/GetPrototypeOf" target="_blank" rel="noopener"><code>Object.getPrototypeOf(o)</code></a>，与 <code>__proto__</code> 属性等效。</p><p>利用它可以动态改变已有对象的原型：</p><pre><code class="js">c1.__proto__ = positionedCircle; //动态变更原型c1.x = c1.y = 1;c1.getRange(); //1.414c1.getArea(); //3.14 //circle 的方法仍然有效</code></pre><p><code>__proto__</code> 还可以用于对象字面量，极大地简化对象创建，很多情况下使工厂方法变得不必要：</p><pre><code class="js">var c6 = {__proto__: positionedCircle, x:1, y:1, r:2};</code></pre><h3 id="无原型的对象"><a href="#无原型的对象" class="headerlink" title="无原型的对象"></a>无原型的对象</h3><p>几乎所有 JS 对象的原型链的尽头都是 <code>Object.prototype</code>，但这不是绝对的，完全可以创建无原型的对象：<code>Object.create(null)</code>或<code>{__proto__: null}</code>。</p><p>无原型对象有什么用呢？我能想到的一个用处是：作为真正的 Map 数据结构。因为普通对象从 <code>Object.prototype</code> 继承了许多属性，用做 Map 时会有意想不到的结果。</p><pre><code class="js">//从用户 id 到用户信息的 Mapvar users = {};function setUser(user) {  users[user.id] = user;}function getUser(id) {  return users[id];}setUser({id: &#39;tiger&#39;, name: &#39;老虎&#39;});console.dir(getUser(&#39;tiger&#39;));console.dir(getUser(&#39;constructor&#39;)); //??? 应该没这个用户</code></pre><p><code>constructor</code> 正是从 <code>Object.prototype</code> 继承的一个属性，我们当然不希望将它误当做用户对象。所以，将 JS 对象用做 Map 数据结构时，最好使用无原型对象。</p><h2 id="基于类的面向对象"><a href="#基于类的面向对象" class="headerlink" title="基于类的面向对象"></a>基于类的面向对象</h2><p>到 ES5 为止，JS 并不真正支持基于类的面向对象，仅仅是在基于原型的体制上做了一点包装，看起来有点像 Java。</p><h3 id="基本构造"><a href="#基本构造" class="headerlink" title="基本构造"></a>基本构造</h3><p>JS 中基于类的面向对象主要靠以下构造来支持：</p><ul><li><p><code>new</code> 操作符和构造函数</p><p>  构造函数也是普通函数，但调用方式不同，即通过 new 来调用：<code>new ClassName(arg)</code>，这与其它OO语言类似。调用时，系统创建一个新的空对象，作为 <code>this</code> 参数传给构造函数，构造函数负责初始化其属性。构造函数也被称为“伪类”，或简称“类”，但其实与真正的类相去甚远。</p></li><li><p>构造函数的<code>.prototype</code> 属性</p><p>  调用构造函数时系统创建的新对象，其原型被自动设置为构造函数的<code>.prototype</code> 属性（如<code>ClassName.prototype</code>）。事实上系统自动为每个函数提供一个<code>.prototype</code> 属性，可以在它上面添加属性和方法。当然，也可以将<code>.prototype</code>完全替换掉，效果没有什么不同。</p></li><li><p><code>instanceof</code> 操作符</p><p>  <code>instanceof</code> 是 <code>isPrototypeOf()</code> 函数以外的另一个 RTTI 工具，明显是模仿 Java。前者作用于构造函数而不是原型，不过两者还是有紧密联系的：当 <code>ClassName.prototype.isPrototypeOf(obj) === true</code> 时，<code>obj instanceof ClassName === true</code>。</p></li></ul><p>JS 自带的 API 中大量利用了这种方式，例如数组的构造器是 <code>Array</code>，原型是 <code>Array.prototype</code>，创建数组的语法是<code>new Array(5)</code>。</p><h3 id="实际的例子-1"><a href="#实际的例子-1" class="headerlink" title="实际的例子"></a>实际的例子</h3><p>下面我们“基于原型的面向对象”中的例子改写为基于类的方式。</p><pre><code class="js">//”圆“的构造器function Circle(r) {  //new 方式调用时，系统创建对象，并绑定到 this。  //可以在这里初始化实例的字段。  this.r = r;  //尽管也可以在这里将方法直接定义到 this 上，但如前所述，会占用更多内存。  //构造函数无需返回值}//Circle.prototype 是系统提供的属性，自动成为新建对象的原型，//所以将方法定义在这里。注意 this 不能省略。Circle.prototype.getArea = function () {  return this.r * this.r * 3.14; };var c1 = new Circle(5); //c1.getArea(); //78.5//RTTI验证Circle.prototype.isPrototypeOf(c1); //true//系统提供的.prototype 自动继承 Object.prototypeObject.prototype.isPrototypeOf(Circle.prototype); //truec1 instanceof Circle; //true//继承的类，有位置的圆function PositionedCircle(r, x, y) {  //调用基类构造器，也就继承了父类的字段  Circle.call(this, r);   //增加子类的字段  this.x = x;  this.y = y;}//为了继承父类的方法，要让子类的 .prototype 继承父类的 .prototype，//这里暴露了基于原型的本质。PositionedCircle.prototype = Object.create(Circle.prototype);// 修正 .prototype.constructor 的指向。虽然没什么大用。PositionedCircle.prototype.constructor = PositionedCircle;//定义子类的方法。PositionedCircle.prototype.getRange = function() {  return Math.sqrt(this.x * this.x + this.y * this.y); };var c2 = new PositionedCircle(1,1,2);c2.getArea(); //3.14c2.getRange(); //2.236//RTTI验证c2 instanceof PositionedCircle; //truec2 instanceof Circle; //trueCircle.prototype.isPrototypeOf(c2); //true</code></pre><p>基于类的方式有一个隐患：构造器是普通函数，也可以在没有 <code>new</code> 的情况下调用，这时 <code>this</code> 就成了全局对象，创建的字段就成了全局变量！所以为了防止误用，一方面应该把构造器首字母大写，其它函数小写，另一方面可以在构造器开头检查 this 是否为全局对象。</p><h3 id="ES2015-ES6-中的类"><a href="#ES2015-ES6-中的类" class="headerlink" title="ES2015(ES6) 中的类"></a>ES2015(ES6) 中的类</h3><pre><code class="js">//”圆“的构造器class Circle {  // r = 0; // 这种类似 Java 的成员初始化方法还是不支持的。  // 构造器。constructor 在此处是个关键字，而非普通函数。  constructor(r) {    //可以在这里初始化实例的字段。    this.r = r;  }  // 方法的定义。自动成为 Circle.prototype 上的属性。  // 注意不需要 function 关键字，也没有“:”。  getArea() {    return this.r * this.r * 3.14;   }}var c1 = new Circle(5);c1.getArea(); //78.5//RTTI验证Circle.prototype.isPrototypeOf(c1); //truec1 instanceof Circle; //true// 继承的类，有位置的圆class PositionedCircle extends Circle {  constructor(r, x, y) {    // 调用基类构造器，必须在访问 this 前调用。super 在此处是个关键字。    super(r);     // 增加子类的字段    this.x = x;    this.y = y;  }  // 定义子类的方法。  getRange() {    return Math.sqrt(this.x * this.x + this.y * this.y);  }}var c2 = new PositionedCircle(1,1,2);c2.getArea(); //3.14c2.getRange(); //2.236//RTTI验证c2 instanceof PositionedCircle; //truec2 instanceof Circle; //trueCircle.prototype.isPrototypeOf(c2); //true</code></pre><p>可以看出，ES2015 中的类和的语法很接近 Java，比 ES5 中模拟类的语法简洁了不少。<br>不过两者的语义几乎是等效的，所以 Babel 等编译器可以把 ES2015 代码编译为 ES5 的代码。</p><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>直接定义在伪类上的属性就是静态成员。前面讲到的 <code>.prototype</code> 属性，<code>Object.create()</code>, <code>Object.keys()</code>, <code>Array.isArray()</code> 等函数都是静态成员。</p><p>这与Java等语言的静态（static）成员是类似的。不过有一点不同：JS 类的静态成员不能通过其实例调用（道理应该很简单）。</p><h3 id="继承内置类型"><a href="#继承内置类型" class="headerlink" title="继承内置类型"></a>继承内置类型</h3><p>前面提到的面向对象的做法，并非能适用于一切类型。JS 的内置类型，例如 <code>Array</code>, <code>Function</code> 等，在 ES5 时期是不可被继承的。<br>论及整个 Web 平台时，包括 Element 等类型也是无法被继承的。我们只能用一些动态修改 <code>__proto__</code> 这样的技巧来间接实现。</p><p>如果我们尝试用 ES5 的方法继承 Array 类型：</p><pre><code class="js">function ArrayEx(length) {  Array.call(this, length);}ArrayEx.prototype = Object.create(Array.prototype);var aa = new ArrayEx(3);// 鉴定类型aa instanceof Array; // true; 但别高兴太早。Array.isArray(aa); // false; 不是数组！aa.length; // 0; 怎么回事？！aa[0] = 5; // 好吧，写入一个元素试试。aa[0]; // 5; 似乎成功了！aa.length; // 0; 不行...aa.forEach(function (e) { console.log(e) }); // 什么都没有输出。</code></pre><p>改用 ES2015 的方法：</p><pre><code class="js">class ArrayEx6 extends Array {  constructor(length) {    super(length);  }  // 增加一个方法  get last() { return this.length ? this[this.length - 1] : undefined; }}var aa = new ArrayEx6(3);Array.isArray(aa); // true;aa.length; // 3; 成了！aa[3] = 4;aa.last; // 4; 很好！</code></pre><p>目前，继承内置类型的唯一办法就是使用 ES2015 的语法。</p><h3 id="基于原型还是基于类"><a href="#基于原型还是基于类" class="headerlink" title="基于原型还是基于类"></a>基于原型还是基于类</h3><p>可以看出，基于类的方式与基于原型的方式达到的效果类似，但本质还是基于原型。<br>那么，JS 中到底那种方式更好一些呢？很多人认为<a href="http://stackoverflow.com/questions/2800964/benefits-of-prototypal-inheritance-over-classical" target="_blank" rel="noopener">基于原型更好</a>。</p><p>在 ES5 的时代，我会同意基于原型更好。比起纯粹的基于原型，伪类更加复杂，多了不少概念，绕了很大的弯子。<br>比起真正的基于类的语言，语法又很怪异：没有 class 关键字，定义字段和调用父构造器也很怪，暴露了不少基于原型的细节（prototype 属性）。</p><p>而且在 ES5 之前，情况更糟：还没有 <code>Object.create()</code>。在基于原型的方向，由于构造函数是唯一可以指定对象原型的方式，所以也离不开构函数，不是纯粹的基于原型；在基于类的方向，实现继承的 <code>PositionedCircle.prototype = Object.create(Circle.prototype)</code> 之类的也得改为<br><code>PositionedCircle.prototype = new Circle(0)</code>，这不但更难理解，还增加了一个不必要的继承层次。<br>因此，面向对象机制就成为 JS 中被批评最多的问题之一，而且似乎也造成 JS 开发者中面向对象的使用明显不足。</p><p>不过，在 ES2015 引入了专门的类语法后，增进了代码的可读性，便于书写文档注释，这就使得基于类的方式更为可行。</p><h3 id="继承的局限性"><a href="#继承的局限性" class="headerlink" title="继承的局限性"></a>继承的局限性</h3><p>尽管继承在一些时候很有用，但是必须强调一点：尽量少用继承！无论是基于类还是基于原型。这是从其它编程语言的发展史中得出的经验教训。</p><p>假定我们要实现一个文本编辑器类（<code>TextEditor</code>），它要能产生一些事件，供客户代码来监听。为此我们还实现了一个用来发送事件的类 <code>EventEmitter</code>：</p><pre><code class="js">class EventEmitter {  // 注册事件处理器  on(type/*事件类型，string */, handler/* 事件处理函数*/) { /* ... */ }  // 产生事件  emit(type/*事件类型，string */, ...args /* 事件的参数 */) { /* ... */ }}</code></pre><p>如果用继承的方式，就是这样：</p><pre><code class="js">class TextEditor1 extends EventEmitter {  deleteSelection() {    //触发事件    this.emit(&#39;change&#39;);  }}// 使用var editor = new TextEditor1();editor.on(&#39;change&#39;, function() { /* ... */  });</code></pre><p>由于 JS 只支持单继承，EventEmitter 这个相对外围的功能就占据了这唯一的机会。<br>此外，emit 方法也没必要作为公共的 API，因为客户代码并不会直接产生事件。</p><p>不用继承，那么用什么呢？方法有多种，针对这里的具体情况，可以选择组合或者覆盖。</p><h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><pre><code class="js">class TextEditor2 {  constructor() {    // EventEmitter 变成成员。前置下划线表示私有成员，这是个惯例。    this._em = new EventEmitter();  }  deleteSelection() {    // 触发事件，注意有一层间接    this._em.emit(&#39;change&#39;);  }  // 注册事件。简单包装一下。  // 注意，EventEmitter.emit() 方法不再暴露出来。  on(type, handler) { this._em.on(type, handler); }}</code></pre><p>尽管组合会多出少量包装用的代码，但会使得代码更合理、更灵活。</p><h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><p>如果预料事件处理的代码是相对固定的，不需要动态增删处理器，则可以更简单地使用“覆盖”法。<br>这是利用了 JS 的“对象的自有属性会覆盖原型上的同名属性”这一规则。</p><pre><code class="js">class TextEditor3 {  deleteSelection() {    // 触发事件    this._emitChange();  }  // 这是留给客户代码的事件监听器。默认什么也不做。  // 注意这个方法是定义在原型上的。  onChange() { }  // 私有方法。调用事件监听器。  // 想一想为什么要捕获异常？  _emitChange() {    try {      this.onChange();    } catch(e) {      console.log(e);    }  }}// 客户代码var editor = new TextEditor3();// 注册事件监听器。覆盖原型上的方法。editor.onChange = function() { /* ... */  };</code></pre><p>在其它语言中也有类似的做法。例如 Android 的 <code>Activity</code> 类有 <code>onTouchEvent()</code> 方法，子类可以通过覆盖此方法来处理触摸事件。<br>由于 JS 的动态特性，无需继承就可以达到相同的目的。</p><h2 id="命名空间和模块模式"><a href="#命名空间和模块模式" class="headerlink" title="命名空间和模块模式"></a>命名空间和模块模式</h2><p>JS 运行环境的全局变量（包括函数）太多了，在浏览器中尤其如此（输入<code>this</code>看结果），新出现的 web 技术还在不断扩大这个名单：localStorage、Worker、URL、Blob、FileReader… 一些著名JS 库也会创建自己的全局变量，如 jQuery。因此，如果像前面那些例子一样，用英语常用词作为全局变量的名字，那就太冒险了。让我们面对现实：常用词已经被浏览器预定了，简单前缀+常用词已经被其它 JS 库预定了。</p><p>幸好，有几种技术可以解决这个问题，包括命名空间、CMD模块、AMD模块等。这里我们只讲命名空间，因为它比较简单，而且在浏览器中工作得很好（不适用node.js，请按其惯例操作）。</p><p>JS 并不直接支持命名空间。Java 和 C# 中命名空间都是用 ‘.’ 分隔的标识符，JS 可以用对象来模拟。例如 <code>java.util.HashMap</code> 这个 Java 类用 JS 实现的话，<code>java</code> 和 <code>util</code> 都是普通对象，而 HashMap 是个伪类。</p><pre><code class="js">//HashMap.js//用自执行函数包裹代码是个好习惯，这样其局部变量如 ju、HashMap 不会进入全局作用域。(function() {// 仅当 java 和 java.util 不存在时才初始化，这样允许在多个 JS 文件中共同定义一个命名空间this.java = this.java || {};var ju = this.java.util = this.java.util || {}; //取个短的别名 ju 方便后面使用//构造函数。先定义在局部作用域，方便内部引用。function HashMap() {  //...}ju.HashMap = HashMap; //“导出”了 HashMap 类HashMap.prototype.get = function get(key) {}HashMap.prototype.set = function set(key, value) {}//...})();//使用的地方, testHashMap.js(function() {//JS 没有 Java 的 import 或 C# 的 using，为了便于使用，取一个局部变量作为别名。//同样放到自执行函数中，否则 HashMap 又成为全局变量了。var HashMap = java.util.HashMap;function testHashMap() {  var map = new HashMap();  map.set(&#39;JS&#39;, &#39;JavaScript&#39;);  console.log(map);}})();</code></pre><p>不过，这样的 JS 的命名空间和 Java、C# 毕竟还是有区别：后者只是一种语法，几乎没有运行时开销；而前者是实际的对象，每个 ‘.’ 都意味着一次属性查找，这是有运行时开销的。所以取别名不只是为了简洁，还有性能的考虑。考虑到命名空间实际上是个整体，我主张用’_’代替’.’，例如 <code>java_util.HashMap</code>，这不但提高了性能，还进一步降低了命名冲突的可能。</p><p>尽管命名空间模式解决了问题，但还是有些不足：语法有点晦涩，仪式性的代码有点多。我们将会看到，typescript 改善了语法，ES6 也可能做一些改进。</p><h2 id="类型策略"><a href="#类型策略" class="headerlink" title="类型策略"></a>类型策略</h2><p>在设计 API 的时候，如何保证传入的对象的类型符合期望？静态类型语言的编译器/虚拟机会检查类型，我们只需要给参数指定适当的类或接口即可。但 JS 如何呢？有两种常见策略：RTTI 和“鸭子类型”。</p><h3 id="RTTI-策略"><a href="#RTTI-策略" class="headerlink" title="RTTI 策略"></a>RTTI 策略</h3><p>该策略利用 <code>typeof</code>，<code>instanceof</code> 以及 <code>isPrototypeOf()</code> 来检查对象是否继承自规定的基类/原型。这是一种较强的检查，效果类似静态类型语言的检查。</p><p>但 RTTI 策略也有个很大的缺陷。面向对象设计的一个重要经验是：“要针对接口编程而不是针对实现编程”。不幸的是，JS 并没有接口，也就没有检查“是否实现某接口”的工具，所以使用 RTTI 接近于鼓励“针对实现编程”。因此，只建议在非常必要的情况下使用 RTTI。</p><h3 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h3><p>JS 动态类型的特点，使得设计类型安全的代码变得很困难，不过这也带来了很大的灵活性。JS 经常采用“<a href="http://zh.wikipedia.org/zh-cn/Duck_typing" target="_blank" rel="noopener">鸭子类型</a>”的策略:</p><blockquote><p>在程序设计中，鸭子类型（英语：duck typing）是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由当前方法和属性的集合决定。</p></blockquote><p>话虽如此，但是如何判断该对象的方法和属性符合期望，却很不容易，还会带来不小的性能开销。所以实际上流行的做法是：基本不做运行时检查，而是通过API文档给出契约，通过单元测试和实际运行来确认是否符合契约。</p><p>可以看出，两种策略都有自己的局限性。实际编程中，可以以鸭子类型为主，RTTI为辅。typescript 则提供了静态类型检查，可以较好地补足 JS 的类型策略。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1" target="_blank" rel="noopener">重新介绍 JavaScript（JS 教程）</a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Inheritance" target="_blank" rel="noopener">JavaScript 中的继承</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> prototype </tag>
            
            <tag> object </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js_prototype</title>
      <link href="2017/03/29/js-prototype/"/>
      <url>2017/03/29/js-prototype/</url>
      
        <content type="html"><![CDATA[<h2 id="原型基础"><a href="#原型基础" class="headerlink" title="原型基础"></a>原型基础</h2><pre><code class="javascript">function Foo(){};console.log(Foo.prototype.constructor === Foo) //true</code></pre><pre><code class="javascript">function Foo();var foo = new Foo();console.log(foo.__proto__ === Foo.prototype) //true</code></pre><pre><code class="javascript">function Foo(){};console.log(Foo.prototype.__proto__ === Object.prototype); // true</code></pre><p>Foo.prototype 是Object预创建的一个对象，是Object创建的一个实例，所以，Foo.prototype.<em>_proto</em> 是Object.prototype的引用</p><p>原型链：</p><pre><code class="javascript">     __proto__                   __proto__                        __proto__foo  ---------- Foo.prototype --------------- Object.prototype ------------ null</code></pre><p>在javascript中，函数式特殊对象，所有函数都是构造函数Function的实例</p><pre><code class="javascript">function Foo() {};console.log(Foo.__proto__ === Object.prototype); //falseconsole.log(Foo.__proto__ === Function.prototype); // true</code></pre><p>函数Foo.<em>_proto</em> 指向到 Function.prototype, 说明函数 Foo 是 Function的一个实例</p><pre><code class="javascript"> function Foo(){}; console.log(Foo.__proto__ === Function.prototype); //true console.log(Foo.prototype.__proto__ === Object.prototype);//true</code></pre><p>Foo.prototype 是Object预定义的对象，构造函数为Object,所以<strong>proto</strong>指向 Object.prototype</p><pre><code class="javascript">     __proto__                   __proto__                        __proto__foo  ---------- Foo.prototype --------------- Object.prototype ------------ null     __proto__                   __proto__                        __proto__Foo  ---------- Function.prototype --------------- Object.prototype ------------ null            __proto__                          __proto__                       __proto__Function  -------------  Function.prototype --------------- Object.prototype ------------ null         __proto__                         __proto__                        __proto__Object  ------------ Function.prototype --------------- Object.prototype ------------ null</code></pre><p>Object、Function、Array 等这些函数，他们的构造函数都是 Function 的实例</p><p>基于原型链的基础</p><pre><code class="javascript">function A(){    console.log(&#39;A init&#39;)}A.prototype.play = function(){  console.log(&#39;A play&#39;);}function B(){  console.log(&#39;B init&#39;)}function C(){}C.prototype = A.prototype;B.prototype = new C();C.constructor = C;var B = new B();B.play();//output B init &gt;&gt; A play</code></pre><h2 id="ES6-class"><a href="#ES6-class" class="headerlink" title="ES6 class"></a>ES6 class</h2><h3 id="ES6的写法"><a href="#ES6的写法" class="headerlink" title="ES6的写法"></a>ES6的写法</h3><pre><code class="javascript">class Animal {    // 构造方法，实例化的时候将会被调用，如果不指定，那么会有一个不带参数的默认构造函数.    constructor(name,color) {      this.name = name;      this.color = color;    }    // toString 是原型对象上的属性    toString() {      console.log(&#39;name:&#39; + this.name + &#39;,color:&#39; + this.color);    }  } var animal = new Animal(&#39;dog&#39;,&#39;white&#39;); animal.toString(); console.log(animal.hasOwnProperty(&#39;name&#39;)); //true console.log(animal.hasOwnProperty(&#39;toString&#39;)); // false console.log(animal.__proto__.hasOwnProperty(&#39;toString&#39;)); // true class Cat extends Animal {  constructor(action) {    // 子类必须要在constructor中指定super 方法，否则在新建实例的时候会报错.    // 如果没有置顶consructor,默认带super方法的constructor将会被添加、    super(&#39;cat&#39;,&#39;white&#39;);    this.action = action;  }  toString() {    console.log(super.toString());  } } var cat = new Cat(&#39;catch&#39;) cat.toString(); // 实例cat 是 Cat 和 Animal 的实例，和Es5完全一致。 console.log(cat instanceof Cat); // true console.log(cat instanceof Animal); // true</code></pre><h3 id="ES5的写法（此处实现为typescript编译"><a href="#ES5的写法（此处实现为typescript编译" class="headerlink" title="ES5的写法（此处实现为typescript编译)"></a>ES5的写法（此处实现为typescript编译)</h3><pre><code class="javascript">var __extends = (this &amp;&amp; this.__extends) || (function () {    var extendStatics = Object.setPrototypeOf ||        ({ __proto__: [] } instanceof Array &amp;&amp; function (d, b) { d.__proto__ = b; }) ||        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };    return function (d, b) {        extendStatics(d, b);        function __() { this.constructor = d; }        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());    };})();var Animal = (function () {    // 构造方法，实例化的时候将会被调用，如果不指定，那么会有一个不带参数的默认构造函数.    function Animal(name, color) {        this.name = name;        this.color = color;    }    // toString 是原型对象上的属性    Animal.prototype.toString = function () {        console.log(&#39;name:&#39; + this.name + &#39;,color:&#39; + this.color);    };    return Animal;}());var Cat = (function (_super) {    __extends(Cat, _super);    function Cat(action) {        var _this =         // 子类必须要在constructor中指定super 方法，否则在新建实例的时候会报错.        // 如果没有置顶consructor,默认带super方法的constructor将会被添加、        _super.call(this, &#39;cat&#39;, &#39;white&#39;) || this;        _this.action = action;        return _this;    }    Cat.prototype.toString = function () {        console.log(_super.prototype.toString.call(this));    };    return Cat;}(Animal));</code></pre><p>类的<strong>prototype</strong>属性和<strong><strong>proto</strong></strong>属性<br>在 class 中。同时具有 <strong>proto</strong> 和 prototype 两个属性，存在两条继承链。</p><ul><li>子类的 <strong>proto</strong> 属性，表示构造函数的继承，总是指向父类。</li><li>子类的 prototype 的 <strong>proto</strong> 属性表示方法的继承，总是指向父类的 prototype 属性<pre><code class="javascript">class Cat extends Animal {}console.log(Cat.__proto__ === Animal); // trueconsole.log(Cat.prototype.__proto__ === Animal.prototype); // true</code></pre></li></ul><p>第一条 Cat.<strong>proto</strong> === Animal 这条原型链</p><pre><code class="javascript">class Cat extends Animal {   construcotr() {     return Animal.__proto__.call(this);  }}</code></pre><p>第二条对原型链 Cat.prototype.<strong>proto</strong> === Animal.prototype 完成方法的继承</p><pre><code class="javascript">Cat.prototype.__proto__ = Animal.prototype</code></pre><p>特殊情况：</p><ul><li>1 </li></ul><pre><code class="javascript"> class A extends Object {} console.log(A.__proto__ === Object); // true console.log(A.prototype.__proto__ === Object.prototype); </code></pre><p>A继承Object，A的<strong>prototype</strong> 指向父类Object. A的 prototype.<strong>proto</strong> 指向父类Object的prototype</p><ul><li>2</li></ul><pre><code class="javascript">class Cat {}console.log(Cat.__proto__ === Function.prototype); //trueconsole.log(Cat.prototype.__proto__ === Object.prototype); //true</code></pre><p>由于Cat不存在任何继承，就相当于一个普通函数，由于函数都是Function 的实例，所以 Cat.<strong>proto</strong>指向 Function.prototype. 第二条继承链指向父类（Function.prototype） 的prototype属性，所以 Cat.prototype.<strong>proto</strong> === Object.prototype. Cat调用后会返回Object实例，所以 A.prototype.<strong>proto</strong> 指向构造函数（Object）的prototype</p><ul><li>3</li></ul><pre><code class="javascript">class Cat extends null {};console.log(Cat.__proto__ === Function.prototype); // true;console.log(Cat.prototype.__proto__ === null); //true</code></pre><p>Cat是一个普通函数，所以继承 Function.prototype .第二条继承链不继承任何方法，所以 Cat.prototype.<strong>proto</strong> == null</p><p>原型三角关系 prototype、proto(<strong>proto</strong>)、constructor<br>(原型三角关系图地址)[<a href="https://www.processon.com/embed/579c671de4b0e645bc6a0c10]" target="_blank" rel="noopener">https://www.processon.com/embed/579c671de4b0e645bc6a0c10]</a></p><pre><code class="javascript">    -----                   -----    |对象|                  |函数|    -----                   -----                                         ------------------------------------------                                        |代码：function Foo(){};var f1 = new Foo()|                                        ------------------------------------------    ----               ----------                             |f1| -------------&gt;|Foo(继承)|    ----               ----------     |    proto     |     ∨     ---------------  constructor    ---------    |Foo.prototype| --------------&gt; |  Foo  | ----------------------proto--------------    |             | &lt;-------------- |       |               |                         |       ---------------  prototype      ---------               |                         ∨      |                                 |                 ----------               ---------------------     |   proto                     constructor ---------&gt;|Function|--prototype --&gt;|Function.prototype |     |                                 |                 |        |&lt;-constructor--|                   |           |                                 |                 ----------               ---------------------     ∨                                 ∨                                              ∧             |    ------------------ constructor -----------                                        |             |    |Object.prototype|  --------&gt;  |  Object |                                        |             |--- |                |  &lt;--------  |         |---------------------proto---------------             ||   ------------------  prototype  -----------                                                      ||           ∧                                                                                       ||           |                                                                                       |proto       -----------------------------------proto-------------------------------------------------||     -------  -----&gt;| null|      -------</code></pre><p>参考链接：<br><a href="https://segmentfault.com/a/1190000002904199" target="_blank" rel="noopener">ECMAScript 6 的新特性</a><br><a href="https://github.com/maxzhang/maxzhang.github.com/issues/5" target="_blank" rel="noopener">https://github.com/maxzhang/maxzhang.github.com/issues/5</a><br><a href="http://www.cnblogs.com/xiaohuochai/p/5721552.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaohuochai/p/5721552.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> prototype </tag>
            
            <tag> 原型 </tag>
            
            <tag> __proto__ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hammerJs</title>
      <link href="2017/03/27/hammerJs/"/>
      <url>2017/03/27/hammerJs/</url>
      
        <content type="html"><![CDATA[<p>hammerJS是一个优秀的、轻量级的触屏设备手势库，现在已经更新到2.04版本，跟1.0版本有点天壤地别了，毕竟改写了事件名并新增了许多方法，允许同时监听多个手势、自定义识别器，也可以识别滑动方向。</p><p>不过对于新版本的hammerJS却及其匮乏中文指引文档，就着这一点我还是上 <a href="http://hammerjs.github.io" target="_blank" rel="noopener">官网</a> 翻译下英文文档，写一篇跟大家分享吧 <em>（其实hammer的API写的很不怎样，内容和排版都很马虎了事，建议先仔细研究 <a href="http://hammerjs.github.io/examples" target="_blank" rel="noopener">examples</a> 后再查阅。你也可以通过Aaron猪肉荣的Hammer系列文章来学习）</em> 。</p><p>注：本文将所有API中提到的 “input” 翻译为 “交互”，它实际包括mousedown, mousemove, touchmove, pointercancel事件。</p><h4 id="GENERAL"><a href="#GENERAL" class="headerlink" title="GENERAL"></a>GENERAL</h4><h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>HammerJS是一个开源的库，可以识别由 touch, mouse 和 pointerEvents 触发的系列手势。它非常小巧，压缩后仅有3.96kb，并没有多余的脚本依赖。</p><p>你可以从 <a href="https://github.com/hammerjs/hammer.js/tree/master/" target="_blank" rel="noopener">Github</a> 上获取最新版的HammerJS，或者直接下载 <a href="http://hammerjs.github.io/dist/hammer.min.js" target="_blank" rel="noopener">压缩版</a> 或 未压缩的 <a href="http://hammerjs.github.io/dist/hammer.js" target="_blank" rel="noopener">开发版</a> 的HammerJS源码。</p><p><a href="http://hammerjs.github.io/changelog" target="_blank" rel="noopener">点此</a> 获取版本变动日志。</p><p>也可以 <a href="https://github.com/hammerjs/hammer.js/tree/1.1.x" target="_blank" rel="noopener">点这里</a> 获取更旧的1.1版本。</p><p>2.0版本的变动：彻底重写了源码，包括可复用的识别器 <em>（recognizer）</em> 、提升了对最新移动端浏览器可用的触摸行为css属性的支持，另支持了多个hammer实例同时使用，让多用户同时使用一台设备也不在话下。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>HammerJS的使用方式非常简单，只要将库引入到文件中，并创建一个新的实例即可：</p><pre class="prettyprint hljs javascript"><span style="color: #0000ff;"><span class="hljs-keyword">var</span> hammertime = <span style="color: #0000ff;"><span class="hljs-keyword">new</span> <span style="color: #000000;">Hammer(myElement, myOptions);hammertime.on(<span class="hljs-string">'pan'</span>, <span style="color: #0000ff;"><span class="hljs-function"><span class="hljs-keyword">function</span></span><span style="color: #000000;"><span class="hljs-function">(<span class="hljs-params">ev</span>)</span> {    <span class="hljs-built_in">console</span>.log(ev);});</span></span></span></span></span></pre><p>它会默认为这个对象添加一系列识别器，包括 tap&lt;点&gt;, doubletap&lt;双点击&gt;, press&lt;按住&gt;, 水平方位的pan&lt;平移&gt; 和 swipe&lt;快速滑动&gt;, 以及多触点的 pinch&lt;捏放&gt; 和 rotate&lt;旋转&gt;识别器。不过呢，其中的 pinch 和 rotate 默认是不可用的，因为它们可能会导致元素被卡住，如果你想启用它们，可以加上这两句：</p><pre class="prettyprint hljs dart">hammertime.<span class="hljs-keyword">get</span>(<span class="hljs-string">'pinch'</span>).<span class="hljs-keyword">set</span>({ enable: <span style="color: #0000ff;"><span class="hljs-keyword">true</span> <span style="color: #000000;">});hammertime.<span class="hljs-keyword">get</span>(<span class="hljs-string">'rotate'</span>).<span class="hljs-keyword">set</span>({ enable: <span style="color: #0000ff;"><span class="hljs-keyword">true</span> });</span></span></span></pre><p>若要允许识别器识别垂直方位或全部方位的 pan 和 swipe，可以这么写：</p><pre class="prettyprint hljs less"><span class="hljs-selector-tag">hammertime</span><span class="hljs-selector-class">.get</span>(<span class="hljs-string">'pan'</span><span style="color: #000000;">)<span class="hljs-selector-class">.set</span>({ <span class="hljs-attribute">direction</span>: Hammer.DIRECTION_ALL });<span class="hljs-selector-tag">hammertime</span><span class="hljs-selector-class">.get</span>(<span class="hljs-string">'swipe'</span>)<span class="hljs-selector-class">.set</span>({ <span class="hljs-attribute">direction</span>: Hammer.DIRECTION_VERTICAL });</span></pre><p>另建议加上如下meta标签，防止doubletap 或 pinch 缩放了viewport：</p><pre class="prettyprint hljs xml"><span style="color: #0000ff;"><span class="hljs-tag"><</span><span style="color: #800000;"><span class="hljs-tag"><span class="hljs-name">meta</span></span> <span style="color: #ff0000;"><span class="hljs-tag"><span class="hljs-attr">name</span></span><span style="color: #0000ff;"><span class="hljs-tag">=<span class="hljs-string">"viewport"</span></span><span style="color: #ff0000;"> <span class="hljs-tag"><span class="hljs-attr">content</span></span><span style="color: #0000ff;"><span class="hljs-tag">=<span class="hljs-string">"user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1"</span></span><span style="color: #0000ff;"><span class="hljs-tag">></span></span></span></span></span></span></span></span></pre><h4 id="更多控制"><a href="#更多控制" class="headerlink" title="更多控制"></a>更多控制</h4><p>你可以为你的实例设置属于你自己的识别器，虽然要多写一点代码，但能让你控制更多能被识别的手势：</p><pre class="prettyprint hljs cs"><span style="color: #0000ff;"><span class="hljs-keyword">var</span></span> mc = <span style="color: #0000ff;"><span class="hljs-keyword">new</span></span> <span style="color: #000000;">Hammer.Manager(myElement, myOptions);mc.<span class="hljs-keyword">add</span>(</span> <span style="color: #0000ff;"><span class="hljs-keyword">new</span></span> Hammer.Pan({ direction: Hammer.DIRECTION_ALL, threshold: <span class="hljs-number">0</span> <span style="color: #000000;">}) );mc.<span class="hljs-keyword">add</span>(</span> <span style="color: #0000ff;"><span class="hljs-keyword">new</span></span> Hammer.Tap({ <span class="hljs-keyword">event</span>: <span class="hljs-string">'quadrupletap'</span>, taps: <span class="hljs-number">4</span> <span style="color: #000000;">}) );mc.<span class="hljs-keyword">on</span>(</span><span class="hljs-string">"pan"</span><span style="color: #000000;">, handlePan);mc.<span class="hljs-keyword">on</span>(</span><span class="hljs-string">"quadrupletap"</span>, handleTaps);</pre><p>上述的代码创建了一个实例（mc），它包含了一个 pan 和一个 quadrupletap 手势，识别器实例会在它们被添加（add）之后就不断地执行，且（一个识别器实例）只能识别一个（手势）。</p><h4 id="贴士和窍门"><a href="#贴士和窍门" class="headerlink" title="贴士和窍门"></a>贴士和窍门</h4><h4 id="1-试着避免垂直方向上的-pan-swipe"><a href="#1-试着避免垂直方向上的-pan-swipe" class="headerlink" title="1. 试着避免垂直方向上的 pan/swipe"></a>1. 试着避免垂直方向上的 pan/swipe</h4><p>垂直方向上的平移操作一般是用来滚动你的页面的，而且有些（过时的）浏览器不会传递事件，导致Hammer无法识别这些手势。你可以尝试换另一种可替换的途径来实现相同的动作。</p><h4 id="2-在设备上做测试"><a href="#2-在设备上做测试" class="headerlink" title="2. 在设备上做测试"></a>2. 在设备上做测试</h4><p>有时候Hammer需要做一些调整，像swipe的速率或其它阈值，如果你在一台反应较慢的设备上做测试，那么你要保证你的回调越简单越好。有些站点例如 <a href="http://jankfree.org/" target="_blank" rel="noopener">JankFree.org</a> 上有专门的文章来介绍如何提升展示效果。</p><h4 id="3-去掉Windows-Phone点击时的高亮效果"><a href="#3-去掉Windows-Phone点击时的高亮效果" class="headerlink" title="3. 去掉Windows Phone点击时的高亮效果"></a>3. 去掉Windows Phone点击时的高亮效果</h4><p>你在Windows Phone上的IE10和IE11里tap某元素时，会有一个小小的tap高亮效果，加上这个meta标签可以取消这种效果：</p><pre class="prettyprint hljs xml"><span class="hljs-tag"><<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"msapplication-tap-highlight"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"no"</span> /></span></pre><h4 id="4-“我怎么选择不了文本了！”"><a href="#4-“我怎么选择不了文本了！”" class="headerlink" title="4. “我怎么选择不了文本了！”"></a>4. “我怎么选择不了文本了！”</h4><p>Hammer设置了一个属性用来提升桌面平移操作的用户体验（UX）。常规来说，当你在桌面级浏览器上拖动页面时，你应该是可以正常选中文本的，但user-select这个CSS属性禁用了这功能。如果你在意文本选择功能，同时觉得桌面级的体验没必要太尽善尽美，你可以很轻松地取消这个默认选项——确保在创建实例之前执行：</p><pre class="prettyprint hljs css"><span style="color: #0000ff;"><span class="hljs-selector-tag">delete</span></span> <span class="hljs-selector-tag">Hammer</span><span class="hljs-selector-class">.defaults</span><span class="hljs-selector-class">.cssProps</span><span class="hljs-selector-class">.userSelect</span>;</pre><div><p>5. “在tap之后，导致触发了一个click事件，我不想这样！”</p><p>这种click事件我们称之为一个“幽灵点击”事件，我创建了一个小函数来避免触摸后导致click，对此， <a href="https://developers.google.com/mobile/articles/fast_buttons#ghost" target="_blank" rel="noopener">Ryan Fioravanti的文章</a> 给了我很大的灵感。</p></div><h4 id="浏览器-终端的支持"><a href="#浏览器-终端的支持" class="headerlink" title="浏览器/终端的支持"></a>浏览器/终端的支持</h4><p>无须担心你的浏览器或系统不在下方的列表上，Harmmer可以运行在除了IE8-的任何地方。浏览器若对触摸行为（touch-action）提供原生支持，那么对比那些不支持的浏览器，会有更好的体验。查看 <a href="http://hammerjs.github.io/touch-action/" target="_blank" rel="noopener">touch-action</a> 页面了解更多。</p><p><img src="http://img0.tuicool.com/VnAVFn.jpg!web" alt=""></p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p><a href="http://codepen.io/jtangelder/pen/lgELw" target="_blank" rel="noopener">1. 基础实例</a></p><p><a href="http://codepen.io/jtangelder/pen/ABFnd" target="_blank" rel="noopener">2. 垂直方向的pan识别器</a></p><p><a href="http://codepen.io/jtangelder/pen/zKHDk" target="_blank" rel="noopener">3. 同时识别（用RecognizeWith实现）Pinch和Rotate</a></p><p><a href="http://codepen.io/jtangelder/pen/qeCAs" target="_blank" rel="noopener">4. 用RecognizeWith操作Quadrupletap（自定义的，表示4个tap）识别器</a></p><p><a href="http://codepen.io/jtangelder/pen/pBuIw" target="_blank" rel="noopener">5. SingleTap&lt;单点&gt;和DoubleTap&lt;双点击&gt;(配合recognizeWith/requireFailure)</a></p><p>更多实例可以查看 <a href="https://github.com/hammerjs/hammer.js/tree/master/tests" target="_blank" rel="noopener">github上的库文件</a> 。</p><h4 id="HAMMER"><a href="#HAMMER" class="headerlink" title="HAMMER"></a>HAMMER</h4><h4 id="常规API"><a href="#常规API" class="headerlink" title="常规API"></a>常规API</h4><p>Hammer</p><p>Hammer.defaults</p><p>Hammer.Manager</p><p>Hammer.Recognizer</p><p>Hammer.input event</p><p>Event object</p><p>Constants</p><p>Utils</p><h4 id=""><a href="#" class="headerlink" title="=============================="></a>==============================</h4><h4 id="Hammer"><a href="#Hammer" class="headerlink" title="Hammer"></a>Hammer</h4><p>创建并返回一个带有系列默认识别器集合的Manager实例，该集合内包含了诸如 tap, doubletap, pan, swipe, press, pinch 和 rotate 识别器。你应该在初始化时执行它，其语法为：</p><p>Contructor(HTMLElement, [options])</p><p>参数里一个是你的页面元素，另一个是可选的识别器选项options，options会融入Hammer.defaults中去，当然，在Hammer.defaults.preset中定义的识别器集合也会被添加进来。</p><p>如果识别器选项options为空，那么初始化的时候不会有额外的识别器被添加进来：</p><pre class="prettyprint hljs dart"><span style="color: #0000ff;"><span class="hljs-keyword">var</span></span> myElement = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'hitarea'</span><span style="color: #000000;">);</span> <span style="color: #0000ff;"><span class="hljs-keyword">var</span></span> mc = <span style="color: #0000ff;"><span class="hljs-keyword">new</span></span> Hammer(myElement);</pre><p>==============================</p><h4 id="Hammer-defaults"><a href="#Hammer-defaults" class="headerlink" title="Hammer.defaults"></a>Hammer.defaults</h4><p>创建实例时初始化的默认值，包括你定义的options选择器项。其属性包括：</p><h4 id="touchAction-‘compute’"><a href="#touchAction-‘compute’" class="headerlink" title="touchAction: ‘compute’"></a>touchAction: ‘compute’</h4><p>其值可为 <em>compute, auto, pan-y, pan-x</em> 或 <em>none</em> 。默认选项会基于识别器为你选择一个正确值。</p><div><p>domEvents: false</p><p>让Hammer也能禁用DOM事件。若不禁用会有些慢，故默认是禁用的。如果你想实现事件委托，那么建议你将其设为true。</p></div><div><p>enable: true</p><p>接受一个boolean值, 或返回一个boolean值的函数。（官网就这样一句话，也没说具体啥作用，汗~）</p></div><div><p><span>cssProps: {….}</span></p><p>可以改善交互事件操作的系列css属性。更多详情可以查阅 <a href="http://hammerjs.github.io/jsdoc/Hammer.defaults.cssProps.html" target="_blank" rel="noopener">JSDoc</a> 。</p></div><div><p><span>preset: [….]</span></p><p>调用Hammer()的时候就安装了默认的识别器。如果建立一个新的Manager，这些将被跳过。</p></div><p>==============================</p><h4 id="Hammer-Manager"><a href="#Hammer-Manager" class="headerlink" title="Hammer.Manager"></a>Hammer.Manager</h4><p>Manager是所有识别器实例的容器，它为你的元素安装了交互事件监听器，并设置了触摸事件特性。</p><p>constructor(HTMLElement, [options])</p><p>参数为你的元素（HTMLElement）和选项（options），选项将合并到Hammer.defaults中去：</p><pre class="prettyprint hljs verilog"><span style="color: #0000ff;"><span class="hljs-keyword">var</span></span> mc = <span style="color: #0000ff;"><span class="hljs-keyword">new</span></span> Hammer<span class="hljs-variable">.Manager</span>(myElement);</pre><p>你可以在选项中使用 recognizers 来设置一个初始化识别器，它是一个数组，写法如下：</p><pre class="prettyprint hljs groovy"><span style="color: #0000ff;">var</span> mc = <span style="color: #0000ff;"><span class="hljs-keyword">new</span></span> <span style="color: #000000;">Hammer.Manager(myElement, { <span class="hljs-symbol">recognizers:</span> [</span> <span style="color: #008000;"><span class="hljs-comment">//</span></span><span style="color: #008000;"> <span class="hljs-comment">RecognizerClass, [options], [recognizeWith, ...], [requireFailure, ...]</span></span> <span style="color: #000000;">[Hammer.Rotate],        [Hammer.Pinch, { <span class="hljs-string">enable:</span></span> <span style="color: #0000ff;"><span class="hljs-literal">false</span></span> }, [<span class="hljs-string">'rotate'</span><span style="color: #000000;">]],        [Hammer.Swipe,{ <span class="hljs-string">direction:</span> Hammer.DIRECTION_HORIZONTAL }],    ]});</span></pre><h4 id="set-options"><a href="#set-options" class="headerlink" title="set(options)"></a>set(options)</h4><p>修改一个Manager实例的选项，该方法是推荐使用的，它可以在需要的时候更新touchAction的值：</p><pre class="hljs css"><span class="hljs-selector-tag">mc</span><span class="hljs-selector-class">.set</span>({ <span class="hljs-attribute">enable</span>: <span style="color: #0000ff;">true</span> });</pre><h3 id="get-string-add-Recognizer-和-remove-Recognizer"><a href="#get-string-add-Recognizer-和-remove-Recognizer" class="headerlink" title="get(string), add(Recognizer) 和 remove(Recognizer)"></a><span>get(string), add(Recognizer)</span> 和 <span>remove(Recognizer)</span></h3><div><p>添加一个新的Recognizer实例到Manager中，添加的顺序跟识别器执行的顺序一致。get方法会返回被添加的Recognizer实例。</p><p>get和remove方法都把一个（识别器中的）事件名或识别器实例来作为一个参数。</p><p>Add 和 remove 方法也接受一个识别器数组来作为参数：</p></div><pre class="prettyprint hljs less"><span style="color: #008000;"><span class="hljs-comment">//</span></span><span style="color: #008000;"> <span class="hljs-comment">both return instance of myPinchRecognizer</span></span><span class="hljs-selector-tag">mc</span><span class="hljs-selector-class">.get</span>(<span class="hljs-string">'pinch'</span><span style="color: #000000;">);<span class="hljs-selector-tag">mc</span><span class="hljs-selector-class">.get</span>(myPinchRecognizer);</span></pre><pre class="prettyprint hljs less"><span class="hljs-selector-tag">mc</span><span class="hljs-selector-class">.add</span>(myPinchRecognizer); <span style="color: #008000;"><span class="hljs-comment">//</span></span><span style="color: #008000;"> <span class="hljs-comment">returns the recognizer</span></span><span class="hljs-selector-tag">mc</span><span class="hljs-selector-class">.add</span>([mySecondRecogizner, myThirdRecognizer]);</pre><pre class="prettyprint hljs less"><span style="color: #000000;"><span class="hljs-selector-tag">mc</span><span class="hljs-selector-class">.remove</span>(myPinchRecognizer);<span class="hljs-selector-tag">mc</span><span class="hljs-selector-class">.remove</span>(</span><span class="hljs-string">'rotate'</span><span style="color: #000000;">);<span class="hljs-selector-tag">mc</span><span class="hljs-selector-class">.remove</span>([myPinchRecognizer,</span> <span class="hljs-string">'rotate'</span>]);</pre><h3 id="on-events-handler-和-off-events-handler"><a href="#on-events-handler-和-off-events-handler" class="headerlink" title="on(events, handler) 和 .off(events, [handler])"></a><span>on(events, handler)</span> 和 <span>.off(events, [handler])</span></h3><p>监听由被添加的识别器触发的事件，或者移除那些绑定了的事件。参数中将事件通过空格隔开可处理多个事件：</p><pre class="prettyprint hljs javascript">mc.on(<span class="hljs-string">"pinch"</span>, <span style="color: #0000ff;"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span style="color: #000000;"><span class="hljs-function">(<span class="hljs-params">ev</span>)</span> {    <span class="hljs-built_in">console</span>.log(ev.scale);});</span></pre><h3 id="stop-force"><a href="#stop-force" class="headerlink" title="stop([force])"></a><span>stop([force])</span></h3><p>停止当前交互会话的识别器（Stop recognizing for the current input session）。当使用force参数时，将强制立刻停止识别器执行周期。</p><h3 id="destroy"><a href="#destroy" class="headerlink" title="destroy()"></a><span>destroy()</span></h3><p>解绑所有交互事件并让manager失去作用，但它没有解绑任何dom事件监听器。</p><p>==============================</p><h4 id="Hammer-Recognizer"><a href="#Hammer-Recognizer" class="headerlink" title="Hammer.Recognizer"></a>Hammer.Recognizer</h4><p>每一个识别器都是从这个类中扩展出来的，所有识别器都会有一个enable选项，其值为boolean或者一个回调函数，用来启用/禁用非底层的识别器。</p><p>constructor([options])</p><p>只有选项作为参数：</p><pre class="prettyprint hljs cs"><span style="color: #0000ff;"><span class="hljs-keyword">var</span></span> pinch = <span style="color: #0000ff;"><span class="hljs-keyword">new</span></span> Hammer.Pinch(); <span style="color: #008000;"><span class="hljs-comment">//</span></span><span style="color: #008000;"><span class="hljs-comment">创建一个识别器</span></span>mc.<span class="hljs-keyword">add</span>(pinch); <span style="color: #008000;"><span class="hljs-comment">//</span></span><span style="color: #008000;"> <span class="hljs-comment">添加到Manager实例中</span></span></pre><h4 id="set-options-1"><a href="#set-options-1" class="headerlink" title="set(options)"></a>set(options)</h4><p>在识别器实例中修改一个选项。该方法是推荐使用的，它可以在需要的时候更新touchAction的值。</p><p><span>recognizeWith(otherRecognizer) </span> 和 <span>dropRecognizeWith(otherRecognizer)</span></p><div><p>在当前识别器运行的时候同步运行所给的其它识别器（otherRecognizer），当你需要在最后结合pan和swipe手势时，或者需要同时pinch和ratate一个对象时，它会很有帮助。</p><p>移除这种联系时，只会移除当前识别器上的连接，而不是其它识别器（otherRecognizer）上的连接。</p><p>这两个方法都支持一个识别器组成的数组来作为参数。</p><p>如果识别器被添加到了Manager上，那么该方法也支持将其它识别器(otherRecognizer)的事件名 <em>（字符串形式）</em> 来作为参数。</p></div><p><a href="http://hammerjs.github.io/recognize-with" target="_blank" rel="noopener">了解更多recognizeWith</a></p><p><span>requireFailure(otherRecognizer) </span> 和 <span>dropRequireFailure(otherRecognizer)</span></p><div><p>只有当其它识别器（otherRecognizer）无效时才执行该识别器。</p><p>移除这种联系时，只会移除当前识别器上的连接，而不是其它识别器（otherRecognizer）上的连接。</p><p>这两个方法都支持一个识别器组成的数组来作为参数。</p><p>如果识别器被添加到了Manager上，那么该方法也支持将其它识别器(otherRecognizer)的事件名 <em>（字符串形式）</em> 来作为参数。</p></div><p><a href="http://hammerjs.github.io/require-failure" target="_blank" rel="noopener">了解更多requireFailure</a></p><p>==============================</p><h4 id="Hammer-input-事件"><a href="#Hammer-input-事件" class="headerlink" title="Hammer.input 事件"></a>Hammer.input 事件</h4><p>hammer.input可以触发一个“秘密的”事件，它发生在每一个接收中的交互中，也让你能对原生的交互来做相关处理。它是一个小而强大的特性。</p><pre class="prettyprint hljs javascript">hammertime.on(<span class="hljs-string">"hammer.input"</span>, <span style="color: #0000ff;"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span style="color: #000000;"><span class="hljs-function">(<span class="hljs-params">ev</span>)</span> {   <span class="hljs-built_in">console</span>.log(ev.pointers);});</span></pre><p>==============================</p><h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><p>每一个Hammer触发的事件都会收到一个包含了如下属性的事件对象：</p><p><img src="http://img0.tuicool.com/BR7zMn2.png!web" alt=""></p><p>==============================</p><p>常量/Constants <em>（这个建议查阅源码338行起，主要是用于标志事件轮廓，可通过上文“事件对象”的direction、offsetDirection等属性来获取）</em></p><p>所有常量都定义于Hammer对象中，因为它们都是二进制标识，你可以使用位运算来操作它们。MDN上有一些关于位运算的优秀 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators" target="_blank" rel="noopener">文档</a> 。</p><h4 id="方位-Directions"><a href="#方位-Directions" class="headerlink" title="方位/Directions"></a>方位/Directions</h4><p>用于定义一个识别器的方位，并用来读取一个事件的对应值。</p><p><img src="http://img0.tuicool.com/NrmeUrq.png!web" alt=""></p><p>交互事件/Input Events</p><p>Hammer匹配所有交互 (mousedown, mousemove, touchmove, pointercancel)事件类型为如下值：</p><p><img src="http://img2.tuicool.com/nEVz22E.png!web" alt=""></p><h4 id="识别器状态-Recognizer-States"><a href="#识别器状态-Recognizer-States" class="headerlink" title="识别器状态/Recognizer States"></a>识别器状态/Recognizer States</h4><p>由识别器在内部定义自己的状态：</p><p><img src="http://img2.tuicool.com/uq2q2e3.png!web" alt=""></p><p>==============================</p><h4 id="工具-Utils"><a href="#工具-Utils" class="headerlink" title="工具/Utils"></a>工具/Utils</h4><h4 id="Hammer-on-element-types-handler"><a href="#Hammer-on-element-types-handler" class="headerlink" title="Hammer.on(element, types, handler)"></a>Hammer.on(element, types, handler)</h4><p>addEventListener的封装，可以接受多个事件类型为参数：</p><pre class="prettyprint hljs javascript">Hammer.on(<span class="hljs-built_in">window</span>, <span class="hljs-string">"load resize scroll"</span>, <span style="color: #0000ff;"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span style="color: #000000;"><span class="hljs-function">(<span class="hljs-params">ev</span>)</span> {    <span class="hljs-built_in">console</span>.log(ev.type);});</span></pre><h4 id="Hammer-off-element-types-handler"><a href="#Hammer-off-element-types-handler" class="headerlink" title="Hammer.off(element, types, handler)"></a>Hammer.off(element, types, handler)</h4><p>如同Hammer.on，是removeEventListener的封装，也允许多个事件类型为参数。</p><h4 id="Hammer-each-obj-handler"><a href="#Hammer-each-obj-handler" class="headerlink" title="Hammer.each(obj, handler)"></a>Hammer.each(obj, handler)</h4><p>遍历一个数组或对象：</p><pre class="prettyprint hljs css"><span class="hljs-selector-tag">Hammer</span><span class="hljs-selector-class">.each</span>(<span class="hljs-selector-attr">[10,20,30,40]</span>, <span style="color: #0000ff;"><span class="hljs-selector-tag">function</span></span><span style="color: #000000;">(<span class="hljs-selector-tag">item</span>, <span class="hljs-selector-tag">index</span>, <span class="hljs-selector-tag">src</span>) { });<span class="hljs-selector-tag">Hammer</span><span class="hljs-selector-class">.each</span>({<span class="hljs-attribute">a</span>:</span><span class="hljs-number">10</span>, b:<span class="hljs-number">20</span>, c:<span class="hljs-number">30</span>}, <span style="color: #0000ff;"><span class="hljs-selector-tag">function</span></span>(<span class="hljs-selector-tag">item</span>, <span class="hljs-selector-tag">key</span>, <span class="hljs-selector-tag">src</span>) { });</pre><h4 id="Hammer-merge-obj1-obj2"><a href="#Hammer-merge-obj1-obj2" class="headerlink" title="Hammer.merge(obj1, obj2)"></a>Hammer.merge(obj1, obj2)</h4><p>把obj2的属性混到obj1中去，不过obj1的已有属性不会被重写：</p><pre class="prettyprint hljs swift"><span style="color: #0000ff;"><span class="hljs-keyword">var</span></span> options = <span style="color: #000000;">{    b:</span> <span style="color: #0000ff;"><span class="hljs-literal">false</span></span> <span style="color: #000000;">};</span> <span style="color: #0000ff;"><span class="hljs-keyword">var</span></span> defaults = <span style="color: #000000;">{    a:</span> <span style="color: #0000ff;"><span class="hljs-literal">true</span></span><span style="color: #000000;">,    b:</span> <span style="color: #0000ff;"><span class="hljs-literal">true</span></span><span style="color: #000000;">,    <span class="hljs-built_in">c</span>: [</span><span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><span style="color: #000000;">]};<span class="hljs-type">Hammer</span>.merge(options, defaults);</span> <span style="color: #008000;"><span class="hljs-comment">//</span></span><span style="color: #008000;"> <span class="hljs-comment">options.a == true</span></span> <span style="color: #008000;"><span class="hljs-comment">//</span></span><span style="color: #008000;"> <span class="hljs-comment">options.b == false</span></span> <span style="color: #008000;"><span class="hljs-comment">//</span></span><span style="color: #008000;"> <span class="hljs-comment">options.c == [1,2,3]</span></span></pre><h4 id="Hammer-extend-obj1-obj2"><a href="#Hammer-extend-obj1-obj2" class="headerlink" title="Hammer.extend(obj1, obj2)"></a>Hammer.extend(obj1, obj2)</h4><p>把obj2的属性扩展到obj1中去，不过obj1的已有属性会被重写：</p><pre class="prettyprint hljs swift"><span style="color: #0000ff;"><span class="hljs-keyword">var</span></span> obj1 = <span style="color: #000000;">{    a:</span> <span style="color: #0000ff;"><span class="hljs-literal">true</span></span><span style="color: #000000;">,    b:</span> <span style="color: #0000ff;"><span class="hljs-literal">false</span></span><span style="color: #000000;">,    <span class="hljs-built_in">c</span>: [</span><span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><span style="color: #000000;">]};</span> <span style="color: #0000ff;"><span class="hljs-keyword">var</span></span> obj2 = <span style="color: #000000;">{    b:</span> <span style="color: #0000ff;"><span class="hljs-literal">true</span></span><span style="color: #000000;">,    <span class="hljs-built_in">c</span>: [</span><span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span><span style="color: #000000;">]};<span class="hljs-type">Hammer</span>.extend(obj1, obj2);</span> <span style="color: #008000;"><span class="hljs-comment">//</span></span><span style="color: #008000;"> <span class="hljs-comment">obj1.a == true</span></span> <span style="color: #008000;"><span class="hljs-comment">//</span></span><span style="color: #008000;"> <span class="hljs-comment">obj1.b == true</span></span> <span style="color: #008000;"><span class="hljs-comment">//</span></span><span style="color: #008000;"> <span class="hljs-comment">obj1.c == [4,5,6]</span></span></pre><h4 id="Hammer-inherit-child-base-properties"><a href="#Hammer-inherit-child-base-properties" class="headerlink" title="Hammer.inherit(child, base, [properties])"></a>Hammer.inherit(child, base, [properties])</h4><p>简单的类继承：</p><pre class="prettyprint hljs javascript"><span style="color: #0000ff;"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span style="color: #000000;"><span class="hljs-function"><span class="hljs-title">Animal</span>(<span class="hljs-params">name</span>)</span> {</span> <span style="color: #0000ff;"><span class="hljs-keyword">this</span></span>.name = <span style="color: #000000;">name;}</span> <span style="color: #0000ff;"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span style="color: #000000;"> <span class="hljs-function"><span class="hljs-title">Dog</span>(<span class="hljs-params"></span>)</span> {    Animal.apply(</span><span style="color: #0000ff;"><span class="hljs-keyword">this</span></span><span style="color: #000000;">, <span class="hljs-built_in">arguments</span>);}Hammer.inherit(Dog, Animal, {    <span class="hljs-attr">bark</span>:</span> <span style="color: #0000ff;"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span style="color: #000000;"><span class="hljs-function">(<span class="hljs-params"></span>)</span> {        alert(</span><span style="color: #0000ff;"><span class="hljs-keyword">this</span></span><span style="color: #000000;">.name);    }});</span> <span style="color: #0000ff;"><span class="hljs-keyword">var</span></span> dog = <span style="color: #0000ff;"><span class="hljs-keyword">new</span></span> Dog(<span class="hljs-string">'Spaikie'</span><span style="color: #000000;">);dog.bark();</span></pre><h4 id="Hammer-bindFn-fn-scope"><a href="#Hammer-bindFn-fn-scope" class="headerlink" title="Hammer.bindFn(fn, scope)"></a>Hammer.bindFn(fn, scope)</h4><p>Function.bind的简化形式：</p><pre class="prettyprint hljs javascript"><span style="color: #0000ff;"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span style="color: #000000;"> <span class="hljs-function"><span class="hljs-title">myFunction</span>(<span class="hljs-params">ev</span>)</span> {    <span class="hljs-built_in">console</span>.log(</span><span style="color: #0000ff;"><span class="hljs-keyword">this</span></span> === myContext); <span style="color: #008000;"><span class="hljs-comment">//</span></span><span style="color: #008000;"> <span class="hljs-comment">is true</span></span><span style="color: #000000;">}</span> <span style="color: #0000ff;"><span class="hljs-keyword">var</span></span> myContext = <span style="color: #000000;">{    <span class="hljs-attr">a</span>:</span> <span style="color: #0000ff;"><span class="hljs-literal">true</span></span><span style="color: #000000;">,    <span class="hljs-attr">b</span>:</span> <span style="color: #0000ff;"><span class="hljs-literal">false</span></span> <span style="color: #000000;">};<span class="hljs-built_in">window</span>.addEventListener(</span><span class="hljs-string">'load'</span>, Hammer.bindFn(myFunction, myContext), <span style="color: #0000ff;"><span class="hljs-literal">false</span></span>);</pre><h4 id="Hammer-prefixed-obj-name"><a href="#Hammer-prefixed-obj-name" class="headerlink" title="Hammer.prefixed(obj, name)"></a>Hammer.prefixed(obj, name)</h4><p>获取浏览器的（前缀）属性值：</p><pre class="prettyprint hljs coffeescript">Hammer.prefixed(<span class="hljs-built_in">document</span>.body.style, <span class="hljs-string">'userSelect'</span><span style="color: #000000;">);</span> <span style="color: #008000;"><span class="hljs-regexp">//</span></span> <span style="color: #008000;">returns <span class="hljs-string">"webkitUserSelect"</span> <span class="hljs-literal">on</span> Chrome <span class="hljs-number">35</span></span></pre><p><img src="http://img2.tuicool.com/aqENNf.jpg!web" alt=""></p><p>关于hammer的API就翻译到这里，剩余的几个页面内容篇幅较少也较好读懂，请自行查阅和理解。</p><p>这篇文章是10月8日提笔的，后续因为换工作、换城市的事宜被搁置、尘封在草稿箱，直到今天突然想起才决定把它写完，供打算入门hammer的朋友做个参考吧（再次吐槽hammer的api写的很草率）。</p><p>共勉~</p><p><a href="http://www.tuicool.com/articles/VNRjym7" target="_blank" rel="noopener">原文地址</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hammerJS </tag>
            
            <tag> touch </tag>
            
            <tag> pen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="2017/03/22/link/"/>
      <url>2017/03/22/link/</url>
      
        <content type="html"><![CDATA[<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><h2 id="关于node"><a href="#关于node" class="headerlink" title="关于node"></a>关于node</h2><ul><li>npm<br><a href="http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html" target="_blank" rel="noopener">npm scripts:http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html</a><br><a href="http://www.ruanyifeng.com/blog/2016/01/npm-install.html" target="_blank" rel="noopener">npm 模块安装机制简介:http://www.ruanyifeng.com/blog/2016/01/npm-install.html</a><br><a href="http://www.ruanyifeng.com/blog/2015/05/command-line-with-node.html" target="_blank" rel="noopener">node命令行开发教程:http://www.ruanyifeng.com/blog/2015/05/command-line-with-node.html</a></li></ul><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><ul><li><p>函数式相关文章<br><a href="http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html" target="_blank" rel="noopener">函数式编程入门:http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html</a><br><a href="https://www.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details" target="_blank" rel="noopener">JS函数式编程指南:https://www.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details</a><br><a href="http://lucasmreis.github.io/blog/pointfree-javascript/" target="_blank" rel="noopener">pointfree</a><br><a href="http://fr.umio.us/favoring-curry/" target="_blank" rel="noopener">favoring</a></p></li><li><p>函数式库<br><a href="http://www.ruanyifeng.com/blog/2017/03/ramda.html" target="_blank" rel="noopener">ramdajs中文介绍:http://www.ruanyifeng.com/blog/2017/03/ramda.html</a><br><a href="http://ramdajs.com/" target="_blank" rel="noopener">ramdajs原地址:http://ramdajs.com/</a><br><a href="http://ramdajs.com/docs/" target="_blank" rel="noopener">ramdajsDOCS:http://ramdajs.com/docs/</a></p></li></ul><h2 id="git相关"><a href="#git相关" class="headerlink" title="git相关"></a>git相关</h2><p><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="noopener">git-remote：http://www.ruanyifeng.com/blog/2014/06/git_remote.html</a><br><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">git-command-list:http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></p><p>未完，待续<del>~</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> link </tag>
            
            <tag> 链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ramda库</title>
      <link href="2017/03/07/ramda%E5%BA%93/"/>
      <url>2017/03/07/ramda%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="ramda的详细资料"><a href="#ramda的详细资料" class="headerlink" title="ramda的详细资料"></a>ramda的详细资料</h1><p>ramda是一个以<em>函数式编程</em>为核心思想的库，函数式编程可以参考该源码。</p><h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><p><a href="https://github.com/ramda/ramda" target="_blank" rel="noopener">ramda github</a><br><a href="https://github.com/ramda/ramda/tree/master/dist" target="_blank" rel="noopener">ramda source</a> </p><h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><p><a href="http://ramdajs.com/docs/" target="_blank" rel="noopener">ramda API</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> curry </tag>
            
            <tag> compose </tag>
            
            <tag> 函数式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web-bugs</title>
      <link href="2017/03/07/web-bugs/"/>
      <url>2017/03/07/web-bugs/</url>
      
        <content type="html"><![CDATA[<h3 id="Chrome52-53-无前缀的-CSS-clip-path-url-无效，但开发工具中显示已经生效"><a href="#Chrome52-53-无前缀的-CSS-clip-path-url-无效，但开发工具中显示已经生效" class="headerlink" title="Chrome52-53: 无前缀的 CSS clip-path: url() 无效，但开发工具中显示已经生效"></a>Chrome52-53: 无前缀的 CSS clip-path: url() 无效，但开发工具中显示已经生效</h3><p>-webkit-clip-path 是有效的</p><h3 id="Chrome52：CSS-clip-path-url-作用于-html-元素时，如果引用的-SVG-clipPath-元素的-clipPathUnits-“userSpaceOnUse”-（这是默认值），裁剪区的坐标原点是页面原点，"><a href="#Chrome52：CSS-clip-path-url-作用于-html-元素时，如果引用的-SVG-clipPath-元素的-clipPathUnits-“userSpaceOnUse”-（这是默认值），裁剪区的坐标原点是页面原点，" class="headerlink" title="Chrome52：CSS clip-path: url() 作用于 html 元素时，如果引用的 SVG clipPath 元素的 clipPathUnits = “userSpaceOnUse” （这是默认值），裁剪区的坐标原点是页面原点，"></a>Chrome52：CSS clip-path: url() 作用于 html 元素时，如果引用的 SVG clipPath 元素的 clipPathUnits = “userSpaceOnUse” （这是默认值），裁剪区的坐标原点是页面原点，</h3><p>正确的应该是被裁剪的元素的原点。</p><p>53修复这个问题。注意 clipPathUnits = “objectBoundingBox” 时并没有问题。</p><h3 id="Chrome52-53-CSS-clip-path-url-作用于-svg-元素时，不支持到外部文件的-url，裁剪完全被忽略"><a href="#Chrome52-53-CSS-clip-path-url-作用于-svg-元素时，不支持到外部文件的-url，裁剪完全被忽略" class="headerlink" title="Chrome52-53: CSS clip-path: url() 作用于 svg 元素时，不支持到外部文件的 url，裁剪完全被忽略"></a>Chrome52-53: CSS clip-path: url() 作用于 svg 元素时，不支持到外部文件的 url，裁剪完全被忽略</h3><h3 id="Chrome52-53-CSS-clip-path-url-作用于-html-元素时，不支持到外部文件的-url，而且如果使用外部文件的-url，片段部分（-xxx）被解释为本文件内的-id"><a href="#Chrome52-53-CSS-clip-path-url-作用于-html-元素时，不支持到外部文件的-url，而且如果使用外部文件的-url，片段部分（-xxx）被解释为本文件内的-id" class="headerlink" title="Chrome52-53: CSS clip-path: url() 作用于 html 元素时，不支持到外部文件的 url，而且如果使用外部文件的 url，片段部分（#xxx）被解释为本文件内的 id"></a>Chrome52-53: CSS clip-path: url() 作用于 html 元素时，不支持到外部文件的 url，而且如果使用外部文件的 url，片段部分（#xxx）被解释为本文件内的 id</h3><h3 id="Windows-长路径"><a href="#Windows-长路径" class="headerlink" title="Windows 长路径"></a>Windows 长路径</h3><p>经过测试，moz 平台对长路径（&gt;260）的支持是不完全的：</p><ul><li>OS.File 支持，但需要自行添加 “\?&quot; 前缀</li><li>File() 构造器不支持</li><li>fetch 对 file-url 不支持</li><li>file-url，img 标签不支持，video/script/link 等未测试</li></ul><p>Chrome 也不支持 img 的长 file-url。</p><p>Firefox 的 bug:<br><a href="https://bugzilla.mozilla.org/buglist.cgi?quicksearch=long%20path&amp;list_id=13154723" target="_blank" rel="noopener">https://bugzilla.mozilla.org/buglist.cgi?quicksearch=long%20path&amp;list_id=13154723</a><br><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=744413" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=744413</a><br><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=422777" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=422777</a></p><h3 id="Firefox-Changing-width-height-of-images-continuously-causes-very-high-memory-and-CPU-usage"><a href="#Firefox-Changing-width-height-of-images-continuously-causes-very-high-memory-and-CPU-usage" class="headerlink" title="Firefox: Changing width/height of images continuously causes very high memory and CPU usage"></a>Firefox: Changing width/height of images continuously causes very high memory and CPU usage</h3><p><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1292446" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=1292446</a><br>简单地缩放图像就会导致很高的内存和处理器占用。这也是导致备课大师图像不显示、黑屏的诱因之一。<br>测试 image-scale.html<br>Chrome 和 Edge 不存在这个问题。用 CSS transform 代替 style.width|height 也可以避免这个问题。</p><h3 id="Firefox-在页面刷新时自动恢复表单字段的状态，包括-disabled-状态"><a href="#Firefox-在页面刷新时自动恢复表单字段的状态，包括-disabled-状态" class="headerlink" title="Firefox 在页面刷新时自动恢复表单字段的状态，包括 disabled 状态"></a>Firefox 在页面刷新时自动恢复表单字段的状态，包括 disabled 状态</h3><p>if disabled state is changed with javascript, the normal state doesn’t return after refreshing the page<br><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=654072" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=654072</a></p><p>参考 form-restore-ff-test.htm</p><p>表单的恢复是在 DOMContentdLoaded 执行前，且不会产生 “change” 事件。</p><h3 id="firefox-黑屏"><a href="#firefox-黑屏" class="headerlink" title="firefox 黑屏"></a>firefox 黑屏</h3><p>备课大师1.0.90（使用xulrunner 45）出现在某些 dell 台式机上。<br>可能与显卡和硬件加速渲染有关。<br>关闭硬件加速渲染的选项：<br>layers.acceleration.disabled;false</p><p>可能相关的bug：<br><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=593858" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=593858</a></p><p>更新：更可能的原因是 xulrunner-stub 没有用 /largememoryaware 编译，因此能使用的内存比 firefox 预期的要小一半，<br>导致一些模块出问题。改用 /largememoryaware 后似乎问题消失了。</p><h3 id="xulrunner-45-远程调试崩溃"><a href="#xulrunner-45-远程调试崩溃" class="headerlink" title="xulrunner 45 远程调试崩溃"></a>xulrunner 45 远程调试崩溃</h3><p>可能相关的bug：<br>devtools.debugger.source-maps-enabled;false<br>devtools.styleeditor.source-maps-enabled;true<br>在 46 或者用 FF 46 调试 xulrunner 45 似乎没问题了。</p><h3 id="chrome-url-中不能有连续的-‘-’"><a href="#chrome-url-中不能有连续的-‘-’" class="headerlink" title="chrome-url 中不能有连续的 ‘..’"></a>chrome-url 中不能有连续的 ‘..’</h3><p>chrome-url with contiguous dots (.) is not a valid url?<br><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1255687" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=1255687</a></p><h3 id="chrome-url-中的-2540-解释不正确"><a href="#chrome-url-中的-2540-解释不正确" class="headerlink" title="chrome-url 中的 %2540 解释不正确"></a>chrome-url 中的 %2540 解释不正确</h3><p>例如，在地址栏输入 chrome://myhtml/content/%2540<br>错误页面显示：Firefox 无法在 /D:/project/MyHTML/@ 找到该文件。<br>但实际上，%2540 应该解释为 %40。有类似错误的还有 “%2530” -&gt; 0 ，”%2520a” -&gt; “ a”<br>注意，只有该url映射到磁盘文件时才出现这个问题，映射到zip文件内的则不会；非windows系统未测试。</p><h3 id="反复缩放较大的图片，会造成内存占用急剧升高，然后图片不显示"><a href="#反复缩放较大的图片，会造成内存占用急剧升高，然后图片不显示" class="headerlink" title="反复缩放较大的图片，会造成内存占用急剧升高，然后图片不显示"></a>反复缩放较大的图片，会造成内存占用急剧升高，然后图片不显示</h3><p>有时网页甚至变成黑屏，程序崩溃。</p><h3 id="EventSource-Server-Sent-Event-doesn’t-retry-after-OS-suspend-resume"><a href="#EventSource-Server-Sent-Event-doesn’t-retry-after-OS-suspend-resume" class="headerlink" title="EventSource (Server Sent Event) doesn’t retry after OS suspend/resume"></a>EventSource (Server Sent Event) doesn’t retry after OS suspend/resume</h3><p>FF: <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1251117" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=1251117</a><br>Chrome: 存在，尚未报告。实际上更严重，resume 之后不发送 error 事件就中断了连接。</p><h3 id="EventSource-Server-Sent-Event-doesn’t-retry-if-the-server-is-down-during-the-first-attempt-to-connect"><a href="#EventSource-Server-Sent-Event-doesn’t-retry-if-the-server-is-down-during-the-first-attempt-to-connect" class="headerlink" title="EventSource (Server Sent Event) doesn’t retry if the server is down during the first attempt to connect"></a>EventSource (Server Sent Event) doesn’t retry if the server is down during the first attempt to connect</h3><p>FF: <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1251121" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=1251121</a><br>Chrome: 不存在。</p><h3 id="Window-open-doesn’t-resolve-relative-url-correctly-when-iframe-involved"><a href="#Window-open-doesn’t-resolve-relative-url-correctly-when-iframe-involved" class="headerlink" title="Window.open() doesn’t resolve relative url correctly when iframe involved"></a>Window.open() doesn’t resolve relative url correctly when iframe involved</h3><p>FF: <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1044950" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=1044950</a><br>Chrome: 存在，尚未报告</p><h3 id="object-type-text-html-对错误的url仍然显示空白文档，而不是后备内容"><a href="#object-type-text-html-对错误的url仍然显示空白文档，而不是后备内容" class="headerlink" title="object type=text/html 对错误的url仍然显示空白文档，而不是后备内容"></a>object type=text/html 对错误的url仍然显示空白文档，而不是后备内容</h3><p>Chrome: 存在，尚未报告<br>FF: 无此问题</p><h3 id="file-协议的-content-type"><a href="#file-协议的-content-type" class="headerlink" title="file: 协议的 content-type"></a>file: 协议的 content-type</h3><p>FF: <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1037762" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=1037762</a><br>XHR 设置 content-type 头为 application/xml，解释内容为 xml</p><p>Chrome: 尚未报告。XHR 没有设置 content-type 头，但正确解释了内容。</p><p>whatwg maillist: [whatwg] How to determine content-type of file: protocol</p><h3 id="分离的-video-元素仍会导致视频加载和解码（除非设置preload-none），造成很大的内存占用"><a href="#分离的-video-元素仍会导致视频加载和解码（除非设置preload-none），造成很大的内存占用" class="headerlink" title="分离的 video 元素仍会导致视频加载和解码（除非设置preload=none），造成很大的内存占用"></a>分离的 video 元素仍会导致视频加载和解码（除非设置preload=none），造成很大的内存占用</h3><p>规范如此？</p><h3 id="MutationObserver-在初始解析阶段不能及时发送事件"><a href="#MutationObserver-在初始解析阶段不能及时发送事件" class="headerlink" title="MutationObserver 在初始解析阶段不能及时发送事件"></a>MutationObserver 在初始解析阶段不能及时发送事件</h3><h3 id="getComputedStyle-用于外部文档中的节点以及分离的节点"><a href="#getComputedStyle-用于外部文档中的节点以及分离的节点" class="headerlink" title="getComputedStyle 用于外部文档中的节点以及分离的节点"></a>getComputedStyle 用于外部文档中的节点以及分离的节点</h3><p>[cssom] getComputedStyle and elements outside the tree<br>  <a href="http://lists.w3.org/Archives/Public/www-style/2010Apr/0433.html" target="_blank" rel="noopener">http://lists.w3.org/Archives/Public/www-style/2010Apr/0433.html</a></p><p><a href="http://lists.w3.org/Archives/Public/www-style/2010Apr/0435.html" target="_blank" rel="noopener">http://lists.w3.org/Archives/Public/www-style/2010Apr/0435.html</a><br>  Gecko’s behavior for win.getComputedStyle(elt) is to take the element<br>elt and compute its style based on the styles of the current document of<br>window |win|.  This means that selector matching will be performed based<br>on the DOM (fragment) the element is in, but using the list of rules<br>from window |win|.  This applies to not only document rules but UA rules<br>too (so if the document in |win| is in quirks mode, quirks rules will be<br>applied to the element).</p><p>This was a conscious design decision in an area where the spec was …<br>somewhat underspecific.  We did consider throwing in this situation, but<br>decided against it because it was simpler to just write the code without<br>assuming anything about window identity, etc.</p><blockquote><p>My question is whether this is a bug in Firefox or a feature I should<br>somehow (how?) keep.</p></blockquote><p>There may be things that depend on the “element not in dom tree”<br>behavior.  At least I seem to recall seeing bugs on that.  The other is<br>mostly a source of developer confusion when they use the wrong window, I<br>think…  But all use of getComputedStyle I’ve encountered is<br>conditioned on various browser sniffing, so changing this stuff is very<br>likely to cause compat issues no matter what we do.  :(</p><p>-Boris</p><p><a href="http://lists.w3.org/Archives/Public/www-style/2010Jul/0252.html" target="_blank" rel="noopener">http://lists.w3.org/Archives/Public/www-style/2010Jul/0252.html</a></p><blockquote><p>A number of Google teams have come to us with bugs of their pages<br>working in Gecko, but not WebKit due to this issue. In practice, it’s<br>not too hard to work around, so changing WebKit hasn’t been a high<br>priority, but it’s pretty clear (anecdotally anyways) that developers<br>expect the Gecko behavior.</p></blockquote><p>Thanks for this Ojan!</p><p>It should be possible for us (Opera) to change this as well so I have<br>attempted to align the specification with Gecko. I would very much<br>appreciate feedback.</p><h3 id="多重组合键"><a href="#多重组合键" class="headerlink" title="多重组合键"></a>多重组合键</h3><p>多重组合键似乎不被支持，如 ctrl+shift+Z，在FF上的contenteditable中只能检测到ctrl+Z。</p><h2 id="object-中的浏览器原生支持的内容"><a href="#object-中的浏览器原生支持的内容" class="headerlink" title="object 中的浏览器原生支持的内容"></a>object 中的浏览器原生支持的内容</h2><p>如果在 object 中引用 html、svg、xhtml、xml 等浏览器原生支持的内容，浏览器的行为并不一致：<br>        html    svg xhtml<br>FF31    y       y   y<br>Cr36    y       n   y<br>E       y       n   n</p><p>embed 待查。</p><h2 id="Mozilla-Firefox-的"><a href="#Mozilla-Firefox-的" class="headerlink" title="Mozilla/Firefox 的"></a>Mozilla/Firefox 的</h2><h3 id="iframe-的父元素上有滚动条，则用空格-page-up-down-时导致滚动位置与滚动条位置不同步。"><a href="#iframe-的父元素上有滚动条，则用空格-page-up-down-时导致滚动位置与滚动条位置不同步。" class="headerlink" title="iframe 的父元素上有滚动条，则用空格/page up/down 时导致滚动位置与滚动条位置不同步。"></a>iframe 的父元素上有滚动条，则用空格/page up/down 时导致滚动位置与滚动条位置不同步。</h3><p>mbeditor，待确认</p><h3 id="chrome-url-的-iframe-中的-html-xhtml-的事件监听器的-this-不正确"><a href="#chrome-url-的-iframe-中的-html-xhtml-的事件监听器的-this-不正确" class="headerlink" title="chrome-url 的 iframe 中的 html/xhtml 的事件监听器的 this 不正确"></a>chrome-url 的 iframe 中的 html/xhtml 的事件监听器的 this 不正确</h3><p>参考 D:\project\MyFirefoxAddon\xhtml-iframe-this<br>触发条件：</p><ol><li>内外两个文档都是(x)html</li><li>内外两个文档都是通过 chrome-url 加载</li><li>在外层文档的脚本中注册事件监听器</li><li>通过 addEventListener 而不是 onclick 注册</li></ol><p>注意 firefox 自带的 (x)html 文档作为外层文档时，不存在这个问题，不知道为什么。例如，外层文档是<br>chrome://devtools/content/framework/connect/connect.xhtml<br>内层文档是<br>chrome://devtools/content/layoutview/view.xhtml<br>或者 chrome://xhtml-iframe-this/content/inner.html</p><p>用这个方法加入 iframe:</p><p>(function () {<br>  var frame = document.createElement(‘iframe’);<br>  frame.style.cssText = ‘position:absolute;top:0;width:700px;height:400px;background-color:white’;<br>  //frame.src = ‘chrome://devtools/content/framework/connect/connect.xhtml’;<br>  //frame.src = ‘chrome://devtools/content/layoutview/view.xhtml’;<br>  //frame.src = ‘chrome://devtools/content/animationinspector/animation-inspector.xhtml’;</p><p>  frame.src = ‘chrome://xhtml-iframe-this/content/inner.html’;<br>  document.body.appendChild(frame);<br>  frame.onload = function() {<br>    frame.contentDocument.addEventListener(“click”, function(ev) { alert(this.nodeName)});<br>  };<br>})();</p><p>则不存在问题。<br>但如果把 firefox 自带的 (x)html 文档抽离出来，则没有这种效果，参考<br>chrome://myhtml/content/view.xhtml<br>chrome://myhtml/content/animation-inspector.xhtml</p><p>解决办法：不使用 this 而是使用 ev.currentTarget。</p><h3 id="FF-上-outline-会包围溢出的子元素。"><a href="#FF-上-outline-会包围溢出的子元素。" class="headerlink" title="FF 上 outline 会包围溢出的子元素。"></a>FF 上 outline 会包围溢出的子元素。</h3><p>参考 <a href="http://stackoverflow.com/questions/10662902/css-outline-different-behavior-behavior-on-webkit-gecko" target="_blank" rel="noopener">http://stackoverflow.com/questions/10662902/css-outline-different-behavior-behavior-on-webkit-gecko</a><br>   <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=687311" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=687311</a><br>   <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=480888" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=480888</a></p><p>可以用伪元素实现多重 box-shadow 来代替 outline，或者在伪元素上用 outline。<br>这个行为似乎CSS规范没有明确定义。</p><h3 id="视频元素导致大量的内存占用"><a href="#视频元素导致大量的内存占用" class="headerlink" title="视频元素导致大量的内存占用"></a>视频元素导致大量的内存占用</h3><p>Reduce resource consumption <video> elements in Desktop Firefox <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1038527" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=1038527</a><br><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1054170" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=1054170</a></p><p>FF 和 Chrome 都有此问题。即使是分离的 video 节点，也会开始加载视频，并消耗等量的内存。</p><h3 id="windows-上视频文件没有及时关闭"><a href="#windows-上视频文件没有及时关闭" class="headerlink" title="windows 上视频文件没有及时关闭"></a>windows 上视频文件没有及时关闭</h3><p>On Windows, media file is locked for a long time after the web page referencing it has been unloaded<br>  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1068596" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=1068596</a><br>destroying VIDEO element does not reduce memory usage<br>  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=962986" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=962986</a></p><p>注意，即使是 detached, 不可达的 video元素，在页面unload后也是不会立即关闭相应文件的（尽管会停止播放）。<br>关闭文件的唯一方法似乎是给 src 设置不可用的 url，然后调用 load() 方法。</p><p>1068596 已经修复。不过这个修复并不彻底，有时候文件仍然被锁定。重现的方法：<br>在备课大师中尝试删除打开中的、含有视频的文档。</p><h3 id="svg-元素的-ClientBox-与-transform"><a href="#svg-元素的-ClientBox-与-transform" class="headerlink" title="svg 元素的 ClientBox 与 transform"></a>svg 元素的 ClientBox 与 transform</h3><p>transform 属性与 CSS transform 属性对 getBoundingClientRect() 的影响不同。</p><p>getBoundingClientRect() doesn’t take CSS transform into account for SVG elements<br>  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1066435" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=1066435</a></p><p>getBoundingClientRect differs from all other browsers for transformed SVG elements<br>  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=755947" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=755947</a></p><p>[CSSOM] Revisiting transforms and getBoundingClientRect()<br>  <a href="http://lists.w3.org/Archives/Public/www-style/2011May/0385.html" target="_blank" rel="noopener">http://lists.w3.org/Archives/Public/www-style/2011May/0385.html</a><br>  没有明确结论。</p><p>[CSSOM] Interaction of getBoundingClientRect/getClientRects with transforms<br>  <a href="http://lists.w3.org/Archives/Public/www-style/2010Aug/0615.html" target="_blank" rel="noopener">http://lists.w3.org/Archives/Public/www-style/2010Aug/0615.html</a></p><h3 id="从XHR读取的xhtml-document，无法设置-object-embed-元素的-data-src-属性"><a href="#从XHR读取的xhtml-document，无法设置-object-embed-元素的-data-src-属性" class="headerlink" title="从XHR读取的xhtml document，无法设置 object/embed 元素的 data/src 属性"></a>从XHR读取的xhtml document，无法设置 object/embed 元素的 data/src 属性</h3><p>Modifying data attribute of <object> causes NS_ERROR_UNEXPECTED exception<br>  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1065920" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=1065920</a></p><h3 id="CSS-变换的-iframe-中的元素无法正确全屏"><a href="#CSS-变换的-iframe-中的元素无法正确全屏" class="headerlink" title="CSS 变换的 iframe 中的元素无法正确全屏"></a>CSS 变换的 iframe 中的元素无法正确全屏</h3><p>Fullscreen is broken for element in CSS-transformed iframe<br><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1139412" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=1139412</a>  </p><p>测试：iframe-fullscreen.html</p><h3 id="Letter-spacing-is-applied-to-zero-width-characters-zwsp-zwj-zwnj"><a href="#Letter-spacing-is-applied-to-zero-width-characters-zwsp-zwj-zwnj" class="headerlink" title="Letter spacing is applied to zero width characters (zwsp, zwj, zwnj)"></a>Letter spacing is applied to zero width characters (zwsp, zwj, zwnj)</h3><p><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=253143" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=253143</a></p><h3 id="CSS-letter-spacing-style-extends-after-last-letter-of-element-with-letter-spacing"><a href="#CSS-letter-spacing-style-extends-after-last-letter-of-element-with-letter-spacing" class="headerlink" title="CSS letter-spacing style extends after last letter of element with letter-spacing"></a>CSS letter-spacing style extends after last letter of element with letter-spacing</h3><p><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=125390" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=125390</a></p><h3 id="如果video的src属性是url-encoded-中文，则无法播放？"><a href="#如果video的src属性是url-encoded-中文，则无法播放？" class="headerlink" title="如果video的src属性是url-encoded 中文，则无法播放？"></a>如果video的src属性是url-encoded 中文，则无法播放？</h3><p>经查证，31以上无此问题。</p><h3 id="MutationObserver-在初始解析阶段漏掉一些节点"><a href="#MutationObserver-在初始解析阶段漏掉一些节点" class="headerlink" title="MutationObserver 在初始解析阶段漏掉一些节点"></a>MutationObserver 在初始解析阶段漏掉一些节点</h3><h3 id="CSS-opacity-animation-生成了多余的-stacking-context"><a href="#CSS-opacity-animation-生成了多余的-stacking-context" class="headerlink" title="CSS opacity animation 生成了多余的 stacking context"></a>CSS opacity animation 生成了多余的 stacking context</h3><p>z-index-opacity-anim.htm<br>FF 35 已经修复。</p><h3 id="HTML-select-元素在展开状态下如果被设置了-visibility-hidden，则会变成黑色"><a href="#HTML-select-元素在展开状态下如果被设置了-visibility-hidden，则会变成黑色" class="headerlink" title="HTML select 元素在展开状态下如果被设置了 visibility: hidden，则会变成黑色"></a>HTML select 元素在展开状态下如果被设置了 visibility: hidden，则会变成黑色</h3><p><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=376607" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=376607</a><br><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=206000" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=206000</a><br>ff-select-black.htm</p><p>Firefox 直到 35 都有这个问题。chrome 37则是让展开部分也立即消失。</p><p>display:none; FF会让展开部分也立即消失；chrome也一样<br>opacity:0; FF只显示展开部分，其它部分消失，并且点击原来的位置仍可以展开；chrome也一样</p><h3 id="剪贴板未实现最新的规范"><a href="#剪贴板未实现最新的规范" class="headerlink" title="剪贴板未实现最新的规范"></a>剪贴板未实现最新的规范</h3><p>dataTransfer.items undefined in Firefox<br><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=906420" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=906420</a></p><h3 id="copy-paste-的局限性"><a href="#copy-paste-的局限性" class="headerlink" title="copy,paste 的局限性"></a>copy,paste 的局限性</h3><p>copy 要求有非空的选区存在；paste 要求有可编辑区域的存在，并有焦点。<br><a href="http://caniuse.com/#search=Clipboard" target="_blank" rel="noopener">http://caniuse.com/#search=Clipboard</a></p><p>Empty clipboardData when pasting image content（意味着无法粘贴print screen的图像）<br><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=891247" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=891247</a></p><h3 id="Selection-selectAllChildren-可以选中脱离主文档的节点"><a href="#Selection-selectAllChildren-可以选中脱离主文档的节点" class="headerlink" title="Selection.selectAllChildren() 可以选中脱离主文档的节点"></a>Selection.selectAllChildren() 可以选中脱离主文档的节点</h3><p>Selection.selectAllChildren() can select detached nodes<br>  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1178681" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=1178681</a></p><h3 id="Selection-selectAllChildren-可能抛出异常"><a href="#Selection-selectAllChildren-可能抛出异常" class="headerlink" title="Selection.selectAllChildren() 可能抛出异常"></a>Selection.selectAllChildren() 可能抛出异常</h3><p>Selection.selectAllChildren() throws NS_ERROR_FAILURE exception if called in mousedown handler and current selection is in a contenteditable<br><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1178676" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=1178676</a></p><p>触发条件：在任意 mousedown 处理器中调用 selectAllChildren()；调用时选区和焦点都位于一个 contenteditable 中。</p><h3 id="selectstart-selectionchange-事件"><a href="#selectstart-selectionchange-事件" class="headerlink" title="selectstart/selectionchange 事件"></a>selectstart/selectionchange 事件</h3><p>FF 43 开始实现，需要设置 dom.select_events.enabled = true<br><a href="https://developer.mozilla.org/en-US/docs/Web/Events/selectionchange" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/Events/selectionchange</a></p><p>polyfill：<a href="https://github.com/2is10/selectionchange-polyfill/" target="_blank" rel="noopener">https://github.com/2is10/selectionchange-polyfill/</a></p><h3 id="firefox-android-版没有视频全屏按钮"><a href="#firefox-android-版没有视频全屏按钮" class="headerlink" title="firefox android 版没有视频全屏按钮"></a>firefox android 版没有视频全屏按钮</h3><p>Provide fullscreen button for video<br>  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1018468" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=1018468</a><br>  已经修复，不过似乎没有随32发布，可能会随33发布。<br>在没有全屏按钮的情况下，长按视频可以弹出上下文菜单，其中有全屏选项。</p><h3 id="mime-错误"><a href="#mime-错误" class="headerlink" title="mime 错误"></a>mime 错误</h3><p>windows 曾经遇到 <input type=file> 对 .swf 文件报告了错误的类型 application/ms-download，并发现 firefox 的文件关联中有多余的项。<br>恢复出厂状态可以解决，也有资料说删除 profile 中的 mimeTypes.rdf 可以解决。<br>可能相关的bug:<br>ajaxSketch breaks handling of local SVG files<br>  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=332690" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=332690</a><br>Firefox mimeTypes.rdf corruption<br>  <a href="http://cephas.net/blog/2007/01/05/firefox-mimetypesrdf-corruption/" target="_blank" rel="noopener">http://cephas.net/blog/2007/01/05/firefox-mimetypesrdf-corruption/</a><br>Mimetype corruption in Firefox<br>  <a href="http://techblog.procurios.nl/k/n618/news/view/15872/14863/mimetype-corruption-in-firefox.html" target="_blank" rel="noopener">http://techblog.procurios.nl/k/n618/news/view/15872/14863/mimetype-corruption-in-firefox.html</a></p><h3 id="flash-android-拖拽操作"><a href="#flash-android-拖拽操作" class="headerlink" title="flash android 拖拽操作"></a>flash android 拖拽操作</h3><p>Slider control of adobe flash doesn’t work with touch screen, seems mouse/touch_move events are not sent <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1065232" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=1065232</a><br><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1052196" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=1052196</a><br>结论是 firefox android 确实没有实现将click、mouseup/ mousedown以外的鼠标/触摸事件转发到 flash。但这个 bug “不会修改”，因为 flash mobile 已经停止支持。<br>但是欢迎外人提供补丁：<br>  If anyone comes along and feels like working on it, though, the place to add this would be in nsPluginInstanceOwner::ProcessEvent() here: <a href="http://dxr.mozilla.org/mozilla-central/source/dom/plugins/base/nsPluginInstanceOwner.cpp?from=nsPluginInstanceOwner.cpp&amp;case=true#1843" target="_blank" rel="noopener">http://dxr.mozilla.org/mozilla-central/source/dom/plugins/base/nsPluginInstanceOwner.cpp?from=nsPluginInstanceOwner.cpp&amp;case=true#1843</a></p><p>触摸操作不起作用。<br>测试文件：zgdsy.swf （中图社提供）; D:\project\MyHTML\kcx.swf。<br>flash中应该只处理了鼠标拖拽事件。<br>在独立的flash播放器，如smart flash player，swf player, 以及 android 原生浏览器中，该flash是可以触摸操作的。</p><p>另外一些例子，adobe提供的：<br><a href="http://www.adobe.com/devnet/actionscript/samples.html" target="_blank" rel="noopener">http://www.adobe.com/devnet/actionscript/samples.html</a><br>  <a href="http://www.adobe.com/devnet/actionscript/samples/interactivity_3.html" target="_blank" rel="noopener">http://www.adobe.com/devnet/actionscript/samples/interactivity_3.html</a><br>    <a href="http://www.adobe.com/content/dotcom/en/devnet/actionscript/samples/interactivity_3/_jcr_content/articlecontentAdobe/generic/file.res/3_joystick%5b1%5d.swf" target="_blank" rel="noopener">http://www.adobe.com/content/dotcom/en/devnet/actionscript/samples/interactivity_3/_jcr_content/articlecontentAdobe/generic/file.res/3_joystick%5b1%5d.swf</a><br>  <a href="http://www.adobe.com/devnet/actionscript/samples/interactivity_2.html" target="_blank" rel="noopener">http://www.adobe.com/devnet/actionscript/samples/interactivity_2.html</a><br>    <a href="http://www.adobe.com/content/dotcom/en/devnet/actionscript/samples/interactivity_2/_jcr_content/articlecontentAdobe/generic/file.res/2_sliders%5B1%5D.swf" target="_blank" rel="noopener">http://www.adobe.com/content/dotcom/en/devnet/actionscript/samples/interactivity_2/_jcr_content/articlecontentAdobe/generic/file.res/2_sliders%5B1%5D.swf</a></p><h3 id="抛出的异常没有显示在控制台中"><a href="#抛出的异常没有显示在控制台中" class="headerlink" title="抛出的异常没有显示在控制台中"></a>抛出的异常没有显示在控制台中</h3><h3 id="3D-CSS-变换的-contenteditable-元素获得焦点时，插入光标有时会出现在编辑区之外，有时会不可输入。"><a href="#3D-CSS-变换的-contenteditable-元素获得焦点时，插入光标有时会出现在编辑区之外，有时会不可输入。" class="headerlink" title="3D CSS 变换的 contenteditable 元素获得焦点时，插入光标有时会出现在编辑区之外，有时会不可输入。"></a>3D CSS 变换的 contenteditable 元素获得焦点时，插入光标有时会出现在编辑区之外，有时会不可输入。</h3><p>翻卡片控件较严重。<br>29-33 有此问题，35无问题，37-41似乎又有问题。</p><h3 id="OS-File-写入-0-长度数据抛出异常"><a href="#OS-File-写入-0-长度数据抛出异常" class="headerlink" title="OS.File 写入 0 长度数据抛出异常"></a>OS.File 写入 0 长度数据抛出异常</h3><p>OS.File.writeAtomic() 以及 file.write() 在数据长度为 0 时抛出异常。<br>29-33 有此问题，35无问题。</p><h3 id="修改html文件中-iframe的src-srcdoc-属性后刷新，iframe-仍加载上次的-src-srcdoc。"><a href="#修改html文件中-iframe的src-srcdoc-属性后刷新，iframe-仍加载上次的-src-srcdoc。" class="headerlink" title="修改html文件中 iframe的src/srcdoc 属性后刷新，iframe 仍加载上次的 src/srcdoc。"></a>修改html文件中 iframe的src/srcdoc 属性后刷新，iframe 仍加载上次的 src/srcdoc。</h3><p>Change inlined content of iframes in a local html file and reload, the content of the iframes is not updated<br><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1139737" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=1139737</a><br><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=356558" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=356558</a><br><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=363840" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=363840</a><br><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=279048" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=279048</a></p><p>39仍有此问题。</p><p>测试 iframe-reload.html</p><h3 id="Windows-桌面版-FF-上不支持触摸事件（metro模式支持）"><a href="#Windows-桌面版-FF-上不支持触摸事件（metro模式支持）" class="headerlink" title="Windows 桌面版 FF 上不支持触摸事件（metro模式支持）"></a>Windows 桌面版 FF 上不支持触摸事件（metro模式支持）</h3><p>这是因为 FF 的实现有bug，导致一些网页无法滚动，所以默认没有打开触摸事件。用 dom.w3c_touch_events.enabled = 1 or 2 可以强行打开。</p><p>在 JS 代码中：<br>var prefs = Components.classes[“@mozilla.org/preferences-service;1”]<br>                    .getService(Components.interfaces.nsIPrefService).getBranch(“dom.w3c_touch_events.”);<br>prefs.setIntPref(“enabled”, 2);</p><p>Some sites won’t touch-scroll using a touch-screen<br>  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=736048" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=736048</a></p><h2 id="Chrome-的"><a href="#Chrome-的" class="headerlink" title="Chrome 的"></a>Chrome 的</h2><h3 id="word-spacing-不能作用于开头的空白"><a href="#word-spacing-不能作用于开头的空白" class="headerlink" title="word-spacing 不能作用于开头的空白"></a>word-spacing 不能作用于开头的空白</h3><p><a href="https://code.google.com/p/chromium/issues/detail?id=404444" target="_blank" rel="noopener">https://code.google.com/p/chromium/issues/detail?id=404444</a></p><h3 id="负-word-spacing-导致意外换行"><a href="#负-word-spacing-导致意外换行" class="headerlink" title="负 word-spacing 导致意外换行"></a>负 word-spacing 导致意外换行</h3><h3 id="inline-block-导致意外换行"><a href="#inline-block-导致意外换行" class="headerlink" title="inline-block 导致意外换行"></a>inline-block 导致意外换行</h3><p><a href="https://bugs.webkit.org/show_bug.cgi?id=35443" target="_blank" rel="noopener">https://bugs.webkit.org/show_bug.cgi?id=35443</a><br><a href="https://code.google.com/p/chromium/issues/detail?id=428647" target="_blank" rel="noopener">https://code.google.com/p/chromium/issues/detail?id=428647</a></p><h3 id="Blob-constructor-produces-corrupted-result-by-recursively-joining-a-blob-and-an-ArrayBuffer"><a href="#Blob-constructor-produces-corrupted-result-by-recursively-joining-a-blob-and-an-ArrayBuffer" class="headerlink" title="Blob constructor produces corrupted result by recursively joining a blob and an ArrayBuffer"></a>Blob constructor produces corrupted result by recursively joining a blob and an ArrayBuffer</h3><p><a href="https://code.google.com/p/chromium/issues/detail?id=429960" target="_blank" rel="noopener">https://code.google.com/p/chromium/issues/detail?id=429960</a></p><h3 id="XHTML-中-script-defer-属性不起作用"><a href="#XHTML-中-script-defer-属性不起作用" class="headerlink" title="XHTML 中 script defer 属性不起作用"></a>XHTML 中 script defer 属性不起作用</h3><h3 id="当-textarea-外有选区，而-textarea-有焦点时，textarea-只能得到-KeyboardEvent，不能得到-InputEvent。"><a href="#当-textarea-外有选区，而-textarea-有焦点时，textarea-只能得到-KeyboardEvent，不能得到-InputEvent。" class="headerlink" title="当 textarea 外有选区，而 textarea 有焦点时，textarea 只能得到 KeyboardEvent，不能得到 InputEvent。"></a>当 textarea 外有选区，而 textarea 有焦点时，textarea 只能得到 KeyboardEvent，不能得到 InputEvent。</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程笔记</title>
      <link href="2017/03/03/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>2017/03/03/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="函数式编程笔记"><a href="#函数式编程笔记" class="headerlink" title="函数式编程笔记"></a>函数式编程笔记</h1><h2 id="柯里化示例1"><a href="#柯里化示例1" class="headerlink" title="柯里化示例1"></a>柯里化示例1</h2><pre><code class="javascript">var adder = function () {    var _args = [];    return function () {        if (arguments.length === 0) {            return _args.reduce(function (a, b) {                return a + b;            });        }        [].push.apply(_args, [].slice.call(arguments));        return arguments.callee;    }};var sum = adder();console.log(sum);     // Functionsum(100,200)(300);    // 调用形式灵活，一次调用可输入一个或者多个参数，并且支持链式调用sum(400);console.log(sum());   // 1000 （加总计算）</code></pre><h2 id="柯里化示例2-currying"><a href="#柯里化示例2-currying" class="headerlink" title="柯里化示例2 currying"></a>柯里化示例2 currying</h2><pre><code class="javascript">var currying = function (fn) {    var _args = [];    return function () {        if (arguments.length === 0) {            return fn.apply(this, _args);        }        Array.prototype.push.apply(_args, [].slice.call(arguments));        return arguments.callee;    }};var multi=function () {    var total = 0;    for (var i = 0, c; c = arguments[i++];) {        total += c;    }    return total;};var sum = currying(multi);  sum(100,200)(300);sum(400);console.log(sum());     // 1000  （空白调用时才真正计算）</code></pre><h2 id="柯里化示例3"><a href="#柯里化示例3" class="headerlink" title="柯里化示例3"></a>柯里化示例3</h2><p>柯里化的基础<br>上面的代码（示例2）其实是一个高阶函数（high-order function）, 高阶函数是指操作函数的函数，它接收一个或者多个函数作为参数，并返回一个新函数。此外，还依赖与闭包的特性，来保存中间过程中输入的参数。即：<br>函数可以作为参数传递<br>函数能够作为函数的返回值<br>闭包<br>柯里化的作用</p><pre><code class="javascript">var addEvent = function(el, type, fn, capture) {     if (window.addEventListener) {         el.addEventListener(type, function(e) {             fn.call(el, e);         }, capture);     } else if (window.attachEvent) {         el.attachEvent(&quot;on&quot; + type, function(e) {             fn.call(el, e);         });     }  };</code></pre><pre><code class="javascript">var addEvent = (function(){    if (window.addEventListener) {        return function(el, sType, fn, capture) {            el.addEventListener(sType, function(e) {                fn.call(el, e);            }, (capture));        };    } else if (window.attachEvent) {        return function(el, sType, fn, capture) {            el.attachEvent(&quot;on&quot; + sType, function(e) {                fn.call(el, e);            });        };    }})();</code></pre><p>Function.prototype.bind 方法也是柯里化应用<br>与 call/apply 方法直接执行不同，bind 方法 将第一个参数设置为函数执行的上下文，其他参数依次传递给调用方法（函数的主体本身不执行，可以看成是延迟执行），并动态创建返回一个新的函数， 这符合柯里化特点。</p><pre><code class="javascript">var foo = {x: 888};var bar = function () {    console.log(this.x);}.bind(foo);               // 绑定bar();                     // 888</code></pre><p>下面是一个 bind 函数的模拟，testBind 创建并返回新的函数，在新的函数中将真正要执行业务的函数绑定到实参传入的上下文，延迟执行了。</p><pre><code class="javascript">Function.prototype.testBind = function (scope) {    var fn = this;                    //// this 指向的是调用 testBind 方法的一个函数，     return function () {        return fn.apply(scope);    }};var testBindBar = bar.testBind(foo);  // 绑定 foo，延迟执行console.log(testBindBar);             // Function (可见，bind之后返回的是一个延迟执行的新函数)testBindBar();                        // 888</code></pre><p>这里要注意 prototype 中 this 的理解。</p><h2 id="组合-compose"><a href="#组合-compose" class="headerlink" title="组合 compose"></a>组合 compose</h2><p>示例1</p><pre><code class="javascript">var compose = function(f,g) {  return function(x) {    return f(g(x));  };};</code></pre><pre><code class="javascript">var toUpperCase = function(x) { return x.toUpperCase(); };var exclaim = function(x) { return x + &#39;!&#39;; };var shout = compose(exclaim, toUpperCase);shout(&quot;send in the clowns&quot;);</code></pre><pre><code class="javascript">var shout = function(x){  return exclaim(toUpperCase(x));};</code></pre><p>示例2</p><pre><code class="javascript">var head = function(x) { return x[0]; };var reverse = reduce(function(acc, x){ return [x].concat(acc); }, []);var last = compose(head, reverse);last([&#39;jumpkick&#39;, &#39;roundhouse&#39;, &#39;uppercut&#39;]);//=&gt; &#39;uppercut&#39;</code></pre><p>** head ** 取第一个元素,** reverse **反转元素序列</p><pre><code class="javascript">// 结合律（associativity）var associative = compose(f, compose(g, h)) == compose(compose(f, g), h);// true</code></pre><p>compose 的调用分组不重要，所以结果都是一样的</p><pre><code class="javascript">compose(toUpperCase, compose(head, reverse));// 或者compose(compose(toUpperCase, head), reverse);</code></pre><pre><code class="javascript">// 前面的例子中我们必须要写两个组合才行，但既然组合是符合结合律的，我们就可以只写一个，// 而且想传给它多少个函数就传给它多少个，然后让它自己决定如何分组。var lastUpper = compose(toUpperCase, head, reverse);lastUpper([&#39;jumpkick&#39;, &#39;roundhouse&#39;, &#39;uppercut&#39;]);//=&gt; &#39;UPPERCUT&#39;var loudLastUpper = compose(exclaim, toUpperCase, head, reverse)loudLastUpper([&#39;jumpkick&#39;, &#39;roundhouse&#39;, &#39;uppercut&#39;]);//=&gt; &#39;UPPERCUT!&#39;</code></pre><pre><code class="javascript">var loudLastUpper = compose(exclaim, toUpperCase, head, reverse);// 或var last = compose(head, reverse);var loudLastUpper = compose(exclaim, toUpperCase, last);// 或var last = compose(head, reverse);var angry = compose(exclaim, toUpperCase);var loudLastUpper = compose(angry, last);// 更多变种...</code></pre><h3 id="pointerfree"><a href="#pointerfree" class="headerlink" title="pointerfree"></a>pointerfree</h3><pre><code class="javascript">// 非 pointfree，因为提到了数据：wordvar snakeCase = function (word) {  return word.toLowerCase().replace(/\s+/ig, &#39;_&#39;);};// pointfreevar snakeCase = compose(replace(/\s+/ig, &#39;_&#39;), toLowerCase);</code></pre><p>示例</p><pre><code class="javascript">// 非 pointfree，因为提到了数据：namevar initials = function (name) {  return name.split(&#39; &#39;).map(compose(toUpperCase, head)).join(&#39;. &#39;);};// pointfreevar initials = compose(join(&#39;. &#39;), map(compose(toUpperCase, head)), split(&#39; &#39;));initials(&quot;hunter stockton thompson&quot;);</code></pre><h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><p>组合的一个常见错误是，在没有局部调用之前，就组合类似 map 这样接受两个参数的函数。</p><pre><code class="javascript">// 错误做法：我们传给了 `angry` 一个数组，根本不知道最后传给 `map` 的是什么东西。var latin = compose(map, angry, reverse);latin([&quot;frog&quot;, &quot;eyes&quot;]);// error// 正确做法：每个函数都接受一个实际参数。var latin = compose(map(angry), reverse);latin([&quot;frog&quot;, &quot;eyes&quot;]);// [&quot;EYES!&quot;, &quot;FROG!&quot;])</code></pre><p><a href="http://www.2cto.com/kf/201412/357997.html" target="_blank" rel="noopener">http://www.2cto.com/kf/201412/357997.html</a></p><p><a href="https://www.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details" target="_blank" rel="noopener">https://www.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> curry </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xulrunner-gecko-firefox</title>
      <link href="2017/01/13/XULRunner-Gecko-Firefox/"/>
      <url>2017/01/13/XULRunner-Gecko-Firefox/</url>
      
        <content type="html"><![CDATA[<h2 id="XULRunner"><a href="#XULRunner" class="headerlink" title="XULRunner"></a>XULRunner</h2><h3 id="软件和工具"><a href="#软件和工具" class="headerlink" title="软件和工具"></a>软件和工具</h3><p>发行版下载<br>下载站点</p><p><a href="http://ftp.mozilla.org/pub/firefox/" target="_blank" rel="noopener">http://ftp.mozilla.org/pub/firefox/</a></p><p><a href="http://download.cdn.mozilla.net/pub/mozilla.org/" target="_blank" rel="noopener">http://download.cdn.mozilla.net/pub/mozilla.org/</a></p><p>xulrunner 在这里：</p><p><a href="http://ftp.mozilla.org/pub/mozilla.org/xulrunner/releases/latest/runtimes/" target="_blank" rel="noopener">http://ftp.mozilla.org/pub/mozilla.org/xulrunner/releases/latest/runtimes/</a> – 稳定版</p><p><a href="http://ftp.mozilla.org/pub/mozilla.org/xulrunner/candidates/" target="_blank" rel="noopener">http://ftp.mozilla.org/pub/mozilla.org/xulrunner/candidates/</a> – beta版</p><p><a href="http://ftp.mozilla.org/pub/mozilla.org/xulrunner/nightly/latest-mozilla-aurora/" target="_blank" rel="noopener">http://ftp.mozilla.org/pub/mozilla.org/xulrunner/nightly/latest-mozilla-aurora/</a> – aurora版</p><p><a href="http://ftp.mozilla.org/pub/mozilla.org/xulrunner/nightly/latest-mozilla-central/" target="_blank" rel="noopener">http://ftp.mozilla.org/pub/mozilla.org/xulrunner/nightly/latest-mozilla-central/</a> – central版</p><p>firefox 在这里：</p><p><a href="http://ftp.mozilla.org/pub/mozilla.org/firefox/" target="_blank" rel="noopener">http://ftp.mozilla.org/pub/mozilla.org/firefox/</a></p><p>注意，xulrunner 只提供英文版，而 firefox 则有各种本地化版本，例如</p><p><a href="http://ftp.mozilla.org/pub/mozilla.org/firefox/nightly/latest-mozilla-aurora-l10n/" target="_blank" rel="noopener">http://ftp.mozilla.org/pub/mozilla.org/firefox/nightly/latest-mozilla-aurora-l10n/</a></p><p>firefox sdk 只在 aurora 里面有，如<br><a href="http://ftp.mozilla.org/pub/firefox/nightly/latest-mozilla-aurora/firefox-47.0a2.en-US.win32.sdk.zip" target="_blank" rel="noopener">http://ftp.mozilla.org/pub/firefox/nightly/latest-mozilla-aurora/firefox-47.0a2.en-US.win32.sdk.zip</a></p><p>可以利用后者的资源文件本地化前者，详见“本地化”。</p><h3 id="XULRunner-参考"><a href="#XULRunner-参考" class="headerlink" title="XULRunner 参考"></a>XULRunner 参考</h3><p>Creating Applications with Mozilla<br>  <a href="http://books.mozdev.org/html/index.html" target="_blank" rel="noopener">http://books.mozdev.org/html/index.html</a></p><p>XULRunner in large projects<br>  <a href="https://adblockplus.org/blog/xulrunner-in-large-projects-part-1-what-is-that-xulrunner-thingy-anyway" target="_blank" rel="noopener">https://adblockplus.org/blog/xulrunner-in-large-projects-part-1-what-is-that-xulrunner-thingy-anyway</a><br>  <a href="https://adblockplus.org/blog/xulrunner-in-large-projects-part-2-why-xulrunner-isn-t-like-java" target="_blank" rel="noopener">https://adblockplus.org/blog/xulrunner-in-large-projects-part-2-why-xulrunner-isn-t-like-java</a><br>  <a href="https://adblockplus.org/blog/xulrunner-in-large-projects-part-3-bugs-bugs-and-more-bugs" target="_blank" rel="noopener">https://adblockplus.org/blog/xulrunner-in-large-projects-part-3-bugs-bugs-and-more-bugs</a><br>  <a href="https://adblockplus.org/blog/xulrunner-in-large-projects-part-4-localization-pitfalls" target="_blank" rel="noopener">https://adblockplus.org/blog/xulrunner-in-large-projects-part-4-localization-pitfalls</a></p><p>Getting_started_with_XULRunner<br>  <a href="https://developer.mozilla.org/zh-CN/docs/Getting_started_with_XULRunner" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Getting_started_with_XULRunner</a><br>Structure_of_an_installable_bundle<br>  <a href="https://developer.mozilla.org/zh-CN/docs/Structure_of_an_installable_bundle" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Structure_of_an_installable_bundle</a><br>XULRunner_tips<br>  <a href="https://developer.mozilla.org/en-US/docs/XULRunner_tips" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/XULRunner_tips</a><br>JavaScript code modules<br>  <a href="https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules</a><br>Windows_and_menus<br>  <a href="https://developer.mozilla.org/zh-CN/docs/Windows_and_menus_in_XULRunner" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Windows_and_menus_in_XULRunner</a><br>Dialogs<br>  <a href="https://developer.mozilla.org/en-US/docs/Dialogs_in_XULRunner" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Dialogs_in_XULRunner</a><br>browser<br>  <a href="https://developer.mozilla.org/en-US/docs/XUL/browser" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/XUL/browser</a><br>Stream<br>  <a href="https://developer.mozilla.org/en-US/docs/XPCOM_Stream_Guide" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/XPCOM_Stream_Guide</a><br>Using JavaScript code modules<br>  <a href="https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Using#Importing_CommonJS_modules" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Using#Importing_CommonJS_modules</a><br>nsIDirectoryService<br>  <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Using_nsIDirectoryService" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Using_nsIDirectoryService</a></p><p>A Brief Introduction To XULRunner<br>  <a href="http://www.kodewerx.org/wiki/A_Brief_Introduction_To_XULRunner:_Part_1" target="_blank" rel="noopener">http://www.kodewerx.org/wiki/A_Brief_Introduction_To_XULRunner:_Part_1</a><br>  <a href="http://www.kodewerx.org/wiki/A_Brief_Introduction_To_XULRunner:_Part_2" target="_blank" rel="noopener">http://www.kodewerx.org/wiki/A_Brief_Introduction_To_XULRunner:_Part_2</a></p><p>Mozilla 错误代码表 error codes<br>  <a href="https://developer.mozilla.org/en-US/docs/Table_Of_Errors" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Table_Of_Errors</a><br>  <a href="http://james-ross.co.uk/mozilla/misc/nserror_list" target="_blank" rel="noopener">http://james-ross.co.uk/mozilla/misc/nserror_list</a></p><p>使用XPCOM:实现高级处理<br>  <a href="http://caoyue.sinaapp.com/?p=430" target="_blank" rel="noopener">http://caoyue.sinaapp.com/?p=430</a></p><p>样例代码<br>  <a href="https://github.com/matthewkastor/XULRunner-Examples" target="_blank" rel="noopener">https://github.com/matthewkastor/XULRunner-Examples</a></p><p>Mozilla研究<br>  Mozilla研究—用户界面的基本要素 <a href="http://www.cnblogs.com/faunus/archive/2009/04/12/1434213.html" target="_blank" rel="noopener">http://www.cnblogs.com/faunus/archive/2009/04/12/1434213.html</a><br>  Mozilla研究—XUL窗口创建和事件处理 <a href="http://www.cnblogs.com/faunus/archive/2009/04/12/1434214.html" target="_blank" rel="noopener">http://www.cnblogs.com/faunus/archive/2009/04/12/1434214.html</a></p><p>Add-ons/Extension Signing<br>  <a href="https://wiki.mozilla.org/Addons/Extension_Signing" target="_blank" rel="noopener">https://wiki.mozilla.org/Addons/Extension_Signing</a>  </p><p>system/child_process<br>  <a href="https://developer.mozilla.org/en-US/Add-ons/SDK/Low-Level_APIs/system_child_process" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Add-ons/SDK/Low-Level_APIs/system_child_process</a></p><h3 id="XUL-应用结构"><a href="#XUL-应用结构" class="headerlink" title="XUL 应用结构"></a>XUL 应用结构</h3><ul><li>myapp/<br>|</li><li>-+ chrome/<br>| |<br>| +-+ content/<br>| | |<br>| | +– main.xul<br>| | |<br>| | +– main.js<br>| |<br>| +– chrome.manifest //用于向下兼容，可以没有<br>|</li><li>-+ defaults/<br>| |<br>| +-+ preferences/<br>|   |<br>|   +– prefs.js<br>|</li><li>– application.ini<br>|</li><li>– chrome.manifest </li></ul><p>与 extension 相比，XUL 应用只是多出了 application.ini 文件，但少了intall.rdf。<br>其它部分，如 chrome.manifest 与 extension 中的写法相同。</p><ul><li>默认执行的 xul<br>The prefs.js file tells XULRunner the name of the XUL file to use as the main window. Here is mine:</li></ul><p>pref(“toolkit.defaultChromeURI”, “chrome://myapp/content/main.xul”);</p><p>如果没有指定，xulrunner 会试图查找 content （chrome.manifest 中，content 指令指明的目录）中与 package 同名的 xul 文件，例如chrome/content/myapp.xul。</p><ul><li>application.ini<br><a href="https://developer.mozilla.org/en-US/docs/XUL_Application_Packaging" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/XUL_Application_Packaging</a></li></ul><p>注意  Profile=MyAppData 可以指定Profile目录。在linux上是 $HOME/.MyAppData。</p><h3 id="Deploying"><a href="#Deploying" class="headerlink" title="Deploying"></a>Deploying</h3><p><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/XULRunner/Deploying_XULRunner_1.8" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Mozilla/Projects/XULRunner/Deploying_XULRunner_1.8</a></p><pre><code>installdir/    application.ini    components/        ... components which are part of the application    chrome/        ... chrome which is part of the application    ... additional application files such as icons, etc    myapplicationname.exe (This is the &quot;stub executable&quot;... you should copy and rename this file from xulrunner-stub.exe in your XULRunner installation.)    xulrunner/        ... copy xulrunner/ to this directory</code></pre><p>When deploying with XULRunner 2.0 and above do the following:</p><pre><code>Move chrome.manifest to the root directory, and adjust resource paths inside chrome.manifest accordinglyWith XULRunner 9.0 or 10.0 you may need to copy &quot;mozutils.dll&quot; and/or &quot;mozcrt19.dll&quot; from the xulrunner directory to the root directory. This should be fixed with XULRunner 11.0With XULRunner 11.0 you may need to copy &quot;gkmedias.dll&quot; from the xulrunner directory to the root directory</code></pre><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>linux/windows：<br>xulrunner <path_to_app>/application.ini</p><p>使用firefox:<br>firefox -app path/to/application.ini</p><h3 id="全屏-fullscreen"><a href="#全屏-fullscreen" class="headerlink" title="全屏/fullscreen"></a>全屏/fullscreen</h3><p>xul 26 可支持全屏，但默认没有打开，mybrowser例子可以在about:config中搜索full-screen打开。<br>相关选项：<br>full-screen-api.enabled;true<br>full-screen-api.allow-trusted-requests-only;true<br>full-screen-api.approval-required;true<br>full-screen-api.content-only;false<br>full-screen-api.pointer-lock.enabled;true</p><p>一般只需要改 full-screen-api.enabled 一项。</p><p>不过窗口管理似乎需要自己实现，mybrowser例子的全屏只是占满整个viewport。</p><h3 id="给-xulrunner-安装扩展"><a href="#给-xulrunner-安装扩展" class="headerlink" title="给 xulrunner 安装扩展"></a>给 xulrunner 安装扩展</h3><ul><li>FF 扩展的兼容性<br><a href="http://stackoverflow.com/questions/18588542/run-firefox-extensions-in-xulrunner" target="_blank" rel="noopener">http://stackoverflow.com/questions/18588542/run-firefox-extensions-in-xulrunner</a><br>Existing extensions may run, with or without modifications in such a xulrunner app. Well, likely with modifications, as most extensions use APIs specific to Firefox or Thunderbird or …</li></ul><p>The add-on SDK is not generally isn’t a good fit for generic xulrunner apps: It is too much tailered against Firefox specifically.<br><a href="http://stackoverflow.com/questions/8334415/adding-add-on-bar-to-a-custom-xulrunner-application" target="_blank" rel="noopener">http://stackoverflow.com/questions/8334415/adding-add-on-bar-to-a-custom-xulrunner-application</a></p><ul><li><p>将扩展安装到 xulrunner 本身中<br>在 xulrunner 目录下建立如下子目录<br>distribution/bundles/&lt;扩展的名字&gt;<br>然后将扩展的文件放到&lt;扩展的名字&gt;下面，让install.rdf、chrome.manifest等文件位于&lt;扩展的名字&gt;目录下；如果是xpi文件则要解压。<br>&lt;扩展的名字&gt; 应该可以随便取。</p></li><li><p>将扩展安装到 xulrunner app 中<br>在 xulrunner 应用的目录下建立如下子目录：<br>extensions/&lt;扩展的名字&gt;<br>将扩展的文件放到&lt;扩展的名字&gt;下面，让install.rdf、chrome.manifest等文件位于&lt;扩展的名字&gt;目录下。<br>或者将扩展的xpi文件直接放到extensions/下面，例如<br>extensions/&lt;扩展的名字&gt;.xpi<br>注意 &lt;扩展的名字&gt; 不可随便取，应当等于 install.rdf 中的 em:id 的值。</p></li><li><p>Extension Manager<br><a href="https://developer.mozilla.org/en-US/docs/XULRunner_tips#Extension_Manager" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/XULRunner_tips#Extension_Manager</a></p></li><li><p>扩展的更新<br><a href="http://stackoverflow.com/questions/12055985/updating-extensions-in-a-xulrunner-application" target="_blank" rel="noopener">http://stackoverflow.com/questions/12055985/updating-extensions-in-a-xulrunner-application</a><br>可以设置自动更新扩展</p></li></ul><h3 id="XUL-语法和控件"><a href="#XUL-语法和控件" class="headerlink" title="XUL 语法和控件"></a>XUL 语法和控件</h3><ul><li>样式表<?xml-stylesheet href="chrome://global/skin" type="text/css"?>这个引用的是默认样式表。如果要自定义，可以在自定义样式表中引入，例如<br>in xul:<?xml-stylesheet href="chrome://basicapp/skin/main.css" type="text/css"?>in basicapp/skin/main.css:<br>@import url(chrome://global/skin/);</li></ul><p>html 样式表是怎样的？</p><ul><li><p>namespace<br>xmlns:xul =”<a href="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul&quot;" target="_blank" rel="noopener">http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul&quot;</a><br>xmlns:html=”<a href="http://www.w3.org/1999/xhtml&quot;" target="_blank" rel="noopener">http://www.w3.org/1999/xhtml&quot;</a><br>注意 xul 中允许混合 html标签。</p></li><li><p>window<br>这是顶层元素<br>&lt;xul:window title     =”&amp;mybrowser.title;”</p><pre><code>      xmlns:xul =&quot;http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul&quot;      xmlns:html=&quot;http://www.w3.org/1999/xhtml&quot;      id        =&quot;mybrowser&quot;      width     =&quot;800&quot;      height    =&quot;600&quot;&gt;</code></pre></li><li><p>script<br>&lt;xul:script type=”application/javascript”</p><pre><code>          src=&quot;chrome://myapp/content/mybrowser.js&quot; /&gt;</code></pre><p>html script 可以吗？</p></li><li><p>browser 组件<br>&lt;xul:browser flex=”1”</p><pre><code>           id  =&quot;browser&quot;           src =&quot;&quot;           type=&quot;content-primary&quot; /&gt;</code></pre></li></ul><h2 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h2><p><a href="http://kb.mozillazine.org/Starting_your_Mozilla_application_with_a_specified_profile#Bypassing_the_Profile_Manager" target="_blank" rel="noopener">http://kb.mozillazine.org/Starting_your_Mozilla_application_with_a_specified_profile#Bypassing_the_Profile_Manager</a></p><p>启动profile管理器来选择一个profile：<br>  <xul_app> -P<br>直接选择指定的 profile 名字：<br>  <xul_app> -P profileName<br>直接选择指定的 profile 路径。如果是个空目录，则会在该目录中创建新 profile。<br>  <xul_app> -profile path_to_profile</p><p><xul_app> 可以是 firefox，xulrunner，xulrunner-stub 等。</p><p><xul_app> 最终是调用 XRE_main(argc, argv, …) 函数，以上参数都是传给这个函数的。<br>以编程的方式增加 XRE_main() 的参数也可以实现自定义 profile 路径，例如 duanyao/xulrunner-stub。</p><p>另一个自定义 profile 路径的方法是使用 nsIDirectoryServiceProvider，自定义 “ProfD”。geckofx 采用此方法。</p><h2 id="extension"><a href="#extension" class="headerlink" title="extension"></a>extension</h2><h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><p>从 FF 43 起，扩展将被要求有数字签名才能运行。<br>普通版的 FF 没有可以关闭签名验证的选项，而 developer edition 可以通过修改 xpinstall.signatures.required 偏好来关闭签名验证。<br>签名的方法见[Add-ons/Extension Signing]。</p><h3 id="Comparing-Extension-Toolchains"><a href="#Comparing-Extension-Toolchains" class="headerlink" title="Comparing_Extension_Toolchains"></a>Comparing_Extension_Toolchains</h3><p><a href="https://developer.mozilla.org/en-US/Add-ons/Comparing_Extension_Toolchains" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Add-ons/Comparing_Extension_Toolchains</a></p><p>There are three common methods of developing extensions: the Add-on SDK, manually bootstrapped restartless extensions, and legacy, overlay-based restartful extensions.</p><h3 id="传统-extention"><a href="#传统-extention" class="headerlink" title="传统 extention"></a>传统 extention</h3><p>Building_an_Extension<br>  <a href="https://developer.mozilla.org/en-US/docs/Building_an_Extension" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Building_an_Extension</a></p><p>Getting_Started_with_Firefox_Extensions<br>  <a href="https://developer.mozilla.org/en-US/Add-ons/Overlay_Extensions/XUL_School/Getting_Started_with_Firefox_Extensions" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Add-ons/Overlay_Extensions/XUL_School/Getting_Started_with_Firefox_Extensions</a></p><p>The_Essentials_of_an_Extension<br>  <a href="https://developer.mozilla.org/en-US/Add-ons/Overlay_Extensions/XUL_School/The_Essentials_of_an_Extension" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Add-ons/Overlay_Extensions/XUL_School/The_Essentials_of_an_Extension</a><br>  install.rdf</p><p>Setting_up_extension_development_environment<br>  <a href="https://developer.mozilla.org/en-US/Add-ons/Setting_up_extension_development_environment" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Add-ons/Setting_up_extension_development_environment</a></p><p>Install_Manifests (intall.rdf)<br>  <a href="https://developer.mozilla.org/en-US/Add-ons/Install_Manifests" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Add-ons/Install_Manifests</a></p><p>Chrome_Registration (chrome.manifest)<br>  <a href="https://developer.mozilla.org/en-US/docs/Chrome_Registration" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Chrome_Registration</a></p><h3 id="设置开发环境"><a href="#设置开发环境" class="headerlink" title="设置开发环境"></a>设置开发环境</h3><ul><li>新建开发 profile<br>firefox -no-remote -P dev</li></ul><p>-no-remote 是必要的，这样可以同时运行多个ff进程。</p><ul><li>链接开发中的扩展到 profile<br>定位到刚才创建的 profile 下的 extensions 目录，创建一个文本文件，名字是你的 extension 的 id （在install.rdf中），<br>内容是到你的 extension 的全路径，而且要以 /或\结尾。</li></ul><h3 id="Bootstrapped-extensions"><a href="#Bootstrapped-extensions" class="headerlink" title="Bootstrapped extensions"></a>Bootstrapped extensions</h3><p><a href="https://developer.mozilla.org/en-US/Add-ons/Bootstrapped_extensions" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Add-ons/Bootstrapped_extensions</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Extensions/bootstrap.js" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Extensions/bootstrap.js</a></p><p><a href="http://www.oxymoronical.com/blog/2011/01/Playing-with-windows-in-restartless-bootstrapped-extensions" target="_blank" rel="noopener">http://www.oxymoronical.com/blog/2011/01/Playing-with-windows-in-restartless-bootstrapped-extensions</a></p><h3 id="Add-on-SDK"><a href="#Add-on-SDK" class="headerlink" title="Add-on SDK"></a>Add-on SDK</h3><p>The Add-on SDK consists of two things:</p><pre><code>a command-line tool to help test and package extensionsa set of JavaScript APIs, built into Firefox, to create extensions, including APIs to build user interfaces, to interact with the browser and to interact with web content</code></pre><p><a href="https://developer.mozilla.org/en-US/Add-ons/SDK" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Add-ons/SDK</a><br><a href="https://developer.mozilla.org/en-US/Add-ons/SDK/Tutorials/Installation" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Add-ons/SDK/Tutorials/Installation</a><br><a href="https://developer.mozilla.org/en-US/Add-ons/SDK/Tools/cfx" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Add-ons/SDK/Tools/cfx</a><br><a href="https://developer.mozilla.org/en-US/Add-ons/SDK/Tutorials" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Add-ons/SDK/Tutorials</a><br><a href="https://developer.mozilla.org/en-US/Add-ons/SDK/Guides/XUL_Migration_Guide" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Add-ons/SDK/Guides/XUL_Migration_Guide</a><br><a href="https://developer.mozilla.org/en-US/Add-ons/SDK/Tutorials/Add_a_Menu_Item_to_Firefox" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Add-ons/SDK/Tutorials/Add_a_Menu_Item_to_Firefox</a></p><ul><li>command line tool<br>If you give –profiledir a path to a nonexistent profile, cfx will create a profile there for you. So you just have to make up a path and name the first time, and keep using it:</li></ul><p>cfx run –profiledir=”~/addon-dev/profiles/boogaloo”</p><ul><li>resource<br>属于扩展的资源放在data/目录下，其url的解析要使用<br>self.data.url() 函数，例如：<br>var self = require(“sdk/self”);<br>var url = self.data.url(“content.htm”);<br>得到的结果类似：<br>resource://jid1-mf8k5xsb2s4vng-at-jetpack/hello/data/content.htm</li></ul><p>注意 resource: 协议下的文档默认是没有特权的。</p><ul><li><p>High/Low-Level APIs<br><a href="https://developer.mozilla.org/en-US/Add-ons/SDK/High-Level_APIs" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Add-ons/SDK/High-Level_APIs</a><br><a href="https://developer.mozilla.org/en-US/Add-ons/SDK/Low-Level_APIs" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Add-ons/SDK/Low-Level_APIs</a></p></li><li><p>package.json<br><a href="https://developer.mozilla.org/en-US/Add-ons/SDK/Tools/package_json" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Add-ons/SDK/Tools/package_json</a></p></li><li><p>chrome<br>chrome.manifest 文件默认是没有的，也没有可以用 chrome: 协议访问的资源。<br>可以在工程根目录下自行建立这些文件，例如<br>chrome.manifest<br>chrome/<br>content/<br>locale/<br>skin/</p></li></ul><p>chrome.manifest 的内容是：<br>content  hello  chrome/content/<br>…</p><p>注意，chrome 目录的名字是固定的，否则 SDK 认不出来（其它情况下不要求）。</p><ul><li>io_file<br><a href="https://developer.mozilla.org/en-US/Add-ons/SDK/Low-Level_APIs/io_file" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Add-ons/SDK/Low-Level_APIs/io_file</a><br><a href="https://developer.mozilla.org/en-US/Add-ons/SDK/Low-Level_APIs/io_byte-streams" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Add-ons/SDK/Low-Level_APIs/io_byte-streams</a></li></ul><p>功能不是很强，不适合高效地处理二进制文件。</p><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p><a href="https://developer.mozilla.org/en/extension_versioning,_update_and_compatibility" target="_blank" rel="noopener">https://developer.mozilla.org/en/extension_versioning,_update_and_compatibility</a></p><h3 id="打包和安装"><a href="#打包和安装" class="headerlink" title="打包和安装"></a>打包和安装</h3><p><a href="https://developer.mozilla.org/en-US/Add-ons/Extension_Packaging" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Add-ons/Extension_Packaging</a></p><p>An XPI (XPInstall) file is simply a ZIP file containing the extension files, with the install.rdf file at the root of the ZIP. Users can download and install XPI files off a website or from a local file, by opening it or dragging it into the Extension Manager window.</p><p>Install extension files directly</p><p>If you know the location of the application (if you are installing an extension as part of the application installer, for example), you can install the extension files directly to <appdir>/extensions/<extensionID>. The extension will be found automatically by the extension manager the next time the application is launched.</p><h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><p><a href="https://developer.mozilla.org/en-US/Add-ons/Extension_Frequently_Asked_Questions" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Add-ons/Extension_Frequently_Asked_Questions</a></p><h2 id="特殊协议chrome-和resource"><a href="#特殊协议chrome-和resource" class="headerlink" title="特殊协议chrome:和resource:"></a>特殊协议chrome:和resource:</h2><p>参考：<br><a href="https://developer.mozilla.org/en-US/docs/Chrome_Registration" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Chrome_Registration</a><br><a href="https://developer.mozilla.org/en-US/docs/XUL/Tutorial/The_Chrome_URL" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/XUL/Tutorial/The_Chrome_URL</a></p><p>两者都可以用 chrome.manifest 文件来注册</p><h3 id="chrome"><a href="#chrome" class="headerlink" title="chrome"></a>chrome</h3><p>content</p><p>A content package is registered with the line</p><p>content packagename uri/to/files/ [flags]</p><p>This will register a location to use when resolving the URI chrome://packagename/content/…. The URI may be absolute or relative to the location of the manifest file. Note: it must end with a ‘/‘.</p><p>注意包名（packagename）只能用小写字母，否则会引起大小写不一致的问题，因为<br>FF 会在读取 src/href 等 WebIDL 属性时将包名部分都转化为小写。参考：<br><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=132183" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=132183</a></p><p>chrome 协议下的页面有特权，但是不可以访问 DOM storage。详见 DOM Storage。</p><h3 id="resource"><a href="#resource" class="headerlink" title="resource"></a>resource</h3><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><ul><li>chrome.manifest 注册法<br>在 chrome.manifest 文件中，Aliases can be created using the resource instruction:</li></ul><p>resource aliasname uri/to/files/ [flags]</p><p>This will create a mapping for resource://<aliasname>/ URIs to the path given.</p><p>当前目录的写法是 ‘./‘。</p><p>chrome.manifest 也可以动态注册、删除，即利用 nsIComponentManager<br><a href="https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsIComponentManager" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsIComponentManager</a></p><p>addBootstrappedManifestLocation((in nsILocalFile aLocation)<br>  Loads a “bootstrapped” chrome.manifest file from the specified directory or XPI file. A “bootstrapped” chrome manifest supports some of the instructions allowed in a regular chrome manifest, see the Chrome Registration documentation for details.</p><p>void removeBootstrappedManifestLocation(in interface nsILocalFile aLocation);</p><p>在 JS 中，可以用 Components.manager 获得实例。<br>在 geckofx 中，可以通过 Xpcom.ComponentManager 属性得到实例。</p><ul><li>resource 动态注册法<br>也可以在js代码中注册 resource alias<br>参考 <a href="https://developer.mozilla.org/en/Using_JavaScript_code_modules#Programmatically_adding_aliases" target="_blank" rel="noopener">https://developer.mozilla.org/en/Using_JavaScript_code_modules#Programmatically_adding_aliases</a><br>中 Extending resource: URLs 一节。</li></ul><p>这个方法也可以注册本地磁盘目录为 resource alias。</p><p>用于 bootstrap addon 时（参考 <a href="http://starkravingfinkle.org/blog/2011/01/restartless-add-ons-more-resources/）：" target="_blank" rel="noopener">http://starkravingfinkle.org/blog/2011/01/restartless-add-ons-more-resources/）：</a></p><p>function startup(aData, aReason) {<br>  let resource = Services.io.getProtocolHandler(“resource”).QueryInterface(Ci.nsIResProtocolHandler);<br>  let alias = Services.io.newFileURI(aData.installPath);<br>  if (!aData.installPath.isDirectory())<br>    alias = Services.io.newURI(“jar:” + alias.spec + “!/“, null, null);<br>  resource.setSubstitution(“myaddonpackage”, alias);<br>  …<br>}</p><p>function shutdown(aData, aReason) {<br>  if (aReason == APP_SHUTDOWN) return;</p><p>  let resource = Services.io.getProtocolHandler(“resource”).QueryInterface(Ci.nsIResProtocolHandler);<br>  resource.setSubstitution(“myaddonpackage”, null);<br>  …</p><p>The isDirectory check is needed because it is possible for add-ons to be installed in folders or XPI bundles, which require the jar: URI syntax. The code adds a resource alias, after which you can use URIs like this:</p><p>resource://myaddonpackage/images/someimage.png<br>resource://myaddonpackage/content/somescript.js</p><p>注：可以注册多个 resource: 别名。</p><ul><li><p>限制<br>resource: 映射的路径似乎必须在 addon 的根目录下，否则虽然能注册成功，但访问会失败，xhr访问的时候得到onerror事件，但没有写出原因。</p></li><li><p>addon-sdk<br>注意：addon-sdk开发的扩展不用 chrome.manifest 注册，即使在 chrome.manifest 写了 resource 指令也是无效的。<br>参考：<a href="https://developer.mozilla.org/en-US/Add-ons/SDK/Guides/XUL_Migration_Guide" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Add-ons/SDK/Guides/XUL_Migration_Guide</a><br><a href="https://blog.mozilla.org/addons/2012/01/11/sdk-1-4-known-issue-with-hard-coding-resource-uris/" target="_blank" rel="noopener">https://blog.mozilla.org/addons/2012/01/11/sdk-1-4-known-issue-with-hard-coding-resource-uris/</a><br>addon-sdk 的资源总是在 data 目录下，构建的时候复制到 resources 目录下。<br>addon-sdk 采用动态注册法。</p></li><li><p>权限<br>resource 协议下的页面没有特权，但是可以访问 DOM storage。详见 DOM Storage。<br>There are no security restrictions preventing web content from including content at resource: URIs, so take care what you make visible there.<br>[似乎是说，任意的web页面也可以访问 resource: URIs，所以不要放敏感内容在这里]</p></li></ul><h2 id="manifest-的其他特性"><a href="#manifest-的其他特性" class="headerlink" title="manifest 的其他特性"></a>manifest 的其他特性</h2><h3 id="chrome-1"><a href="#chrome-1" class="headerlink" title="chrome"></a>chrome</h3><p>chrome path_to_manifest<br>chrome 指令可以用来引入另一个 .manifest 文件，这个文件就不一定要叫 chrome.manifest 了。例如<br>  chrome components.manifest</p><h3 id="locale"><a href="#locale" class="headerlink" title="locale"></a>locale</h3><p>  locale branding zh-CN zh-CN/locale/branding/</p><h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><p>用来覆盖一个之前（如在omni.ja中）定义的文件，例如<br>  override chrome://global/locale/dom/dom.properties zh-CN/locale/global/dom/dom.properties</p><h3 id="interfaces"><a href="#interfaces" class="headerlink" title="interfaces"></a>interfaces</h3><p>用来引入 JS 的 XPCOM 接口定义文件（.xpt），它决定了 Components.interfaces 的内容。<br>  interfaces interfaces.xpt</p><h3 id="使用-jar-协议"><a href="#使用-jar-协议" class="headerlink" title="使用 jar 协议"></a>使用 jar 协议</h3><p>manifest 也可以引用位于 zip 包中的位置，这需要在路径部分使用 jar 协议，例如：<br>  content devtools jar:devtools.zip!/chrome/devtools/content/</p><p>“jar:” 后面跟上 zip 文件的相对路径，”!” 后面跟上 zip 内部的路径。<br>jar 协议适用于 content, resource, locale 等指令，但似乎不适用 chrome 和 interfaces 指令。</p><h2 id="XULRunner-net绑定"><a href="#XULRunner-net绑定" class="headerlink" title="XULRunner .net绑定"></a>XULRunner .net绑定</h2><h3 id="geckofx"><a href="#geckofx" class="headerlink" title="geckofx"></a>geckofx</h3><ul><li>源码<br>源码库在此：<a href="https://bitbucket.org/geckofx" target="_blank" rel="noopener">https://bitbucket.org/geckofx</a><br>最新版：<a href="https://bitbucket.org/geckofx/geckofx-29.0" target="_blank" rel="noopener">https://bitbucket.org/geckofx/geckofx-29.0</a></li></ul><p>已经包含以前的版本，可以导出版本历史：<br>hg log &gt; log.txt<br>然后查找版本号“13.0”之类的tag，然后用hg转到该版本：<br>hg update v13.0-0.1</p><ul><li>编译</li></ul><p>下载XULRunner发行版，解压到PutXulRunnerFolderHere中。<br>注意geckofx的版本要和xulrunner一致，它没有向下兼容性。</p><p>VS /monodevelpe直接编译即可。运行GeckoFxTest工程。</p><ul><li>profile 目录<br>默认的是在 local application data directory下，例如<br>C:\Users\duanyao\AppData\Local\Geckofx\DefaultProfile<br>可以通过 Xpcom.ProfileDirectory 设置和读取。</li></ul><ul><li>注册xulrunner应用、扩展<br>geckofx 不会像 xulrunner 可执行程序那样自动注册 xulrunner 应用及其扩展。<br>如果 xulrunner 自带扩展，则扩展仍要逐一注册，不会自动注册。<br>注册至少包括以下3个步骤（顺序应该没关系）：</li></ul><ul><li><p>注册 chrome: 协议映射<br>仍用 chrome.manifest 文件来定义映射，然后调用：<br>Xpcom.ComponentManager.AddBootstrappedManifestLocation(chromeDir)<br>chromeDir 指向 chrome.manifest 文件所在的目录。</p></li><li><p>注册 XPCOM 组件<br>仍用 chrome.manifest 文件登记组件。<br>Xpcom.ComponentRegistrar.AutoRegister(chromeFile);<br>chromeFile 指向 chrome.manifest 文件（不是目录）。</p></li><li><p>注册 preference<br>GeckoPreferences.Load(preffile);<br>preffile 指向包含 pref 调用的 js 文件。</p></li></ul><p>注意，这个方法是有副作用的：将preffile设置为用户的pref文件，这样，当用户通过 about:config 修改偏好后，会把用户设置的偏好都写入该文件。<br>不过，通过 GeckoPreferences.User[] 设置的偏好则不会触发写入，但写入时会包括GeckoPreferences.User[]设置的值。<br>为了避免覆盖 preffile，可以多次调用 GeckoPreferences.Load，在最后一次传入一个临时文件。<br>GeckoPreferences.Load 最终调用 xpcom 接口 nsIPrefService::ReadUserPrefs()，ReadUserPrefs 的这个行为可能是bug。<br>nsIPrefService::ReadUserPrefs() 的实现在：<br><a href="http://mxr.mozilla.org/mozilla-central/source/modules/libpref/src/Preferences.cpp#581" target="_blank" rel="noopener">http://mxr.mozilla.org/mozilla-central/source/modules/libpref/src/Preferences.cpp#581</a><br>  ReadAndOwnUserPrefFile(aFile); //这应该是原因所在，故意的。<br>虽然文档上说可以给 nsIPrefService::ReadUserPrefs() 传入 null，将读取默认的 pref.js，但实际上会抛出异常。我们注意到在geckofx的profile目录下，没有pref.js，这可能是geckofx的bug。<br>所以，为了避免麻烦，在geckofx上不要通过 about:config 修改偏好。</p><ul><li>窗口</li></ul><ul><li>创建隐藏窗口<br>AppShellService.CreateHiddenWindow() </li></ul><ul><li>mozilla IDL 到 C# 的翻译器 IDLImp or IDLImporter<br><a href="https://bitbucket.org/geckofx/idlimp" target="_blank" rel="noopener">https://bitbucket.org/geckofx/idlimp</a><br>如果要使用自定义的 XPCOM 组件，可以用这个工具生成 C# 接口。不过好像有一些错误。</li></ul><h3 id="OpenGeckoSharp"><a href="#OpenGeckoSharp" class="headerlink" title="OpenGeckoSharp"></a>OpenGeckoSharp</h3><p><a href="https://github.com/quantum1423/OpenGeckoSharp" target="_blank" rel="noopener">https://github.com/quantum1423/OpenGeckoSharp</a></p><h2 id="JSM"><a href="#JSM" class="headerlink" title="JSM"></a>JSM</h2><p>Using_JavaScript_code_modules <a href="https://developer.mozilla.org/en/Using_JavaScript_code_modules" target="_blank" rel="noopener">https://developer.mozilla.org/en/Using_JavaScript_code_modules</a><br>通过Javascript code modules在XUL文件之间使用全局变量  <a href="http://blog.csdn.net/forumz/article/details/5719678" target="_blank" rel="noopener">http://blog.csdn.net/forumz/article/details/5719678</a></p><p>var EXPORTED_SYMBOLS = [“foo”, “bar”];<br>function foo() {<br>  return “foo”;<br>}<br>var bar = {<br>  name : “bar”,<br>  size : “3”<br>};<br>var dummy = “dummy”;</p><p>注意：对于 xulrunner 应用，如果修改了 jsm 文件，则必需修改 application.ini 中的 BuildID，否则实际加载的总是旧版本！</p><p><a href="https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Services.jsm" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Services.jsm</a></p><p>Services.jsm<br>In This Article</p><p>The Services.jsm JavaScript code module offers a wide assortment of lazy getters that simplify the process of obtaining references to commonly used services.</p><h3 id="使用-CommonJS-模块"><a href="#使用-CommonJS-模块" class="headerlink" title="使用 CommonJS 模块"></a>使用 CommonJS 模块</h3><p>// import require() into your scope.<br>const { require } = Cu.import(“resource://gre/modules/commonjs/toolkit/require.js”, {})<br>// import the SDK’s base64 module<br>var base64 = require(“sdk/base64”);<br>base64.encode(“hello”); // “aGVsbG8=”<br>// import my module<br>var myModule = require(“resource://path/to/my/module.js”);</p><h2 id="preference"><a href="#preference" class="headerlink" title="preference"></a>preference</h2><p><a href="https://developer.mozilla.org/en-US/Add-ons/Code_snippets/Preferences" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Add-ons/Code_snippets/Preferences</a><br><a href="http://stackoverflow.com/questions/3796084/about-config-preferences-and-js" target="_blank" rel="noopener">http://stackoverflow.com/questions/3796084/about-config-preferences-and-js</a></p><p>// Get the “accessibility.” branch<br>var prefs = Components.classes[“@mozilla.org/preferences-service;1”]<br>                    .getService(Components.interfaces.nsIPrefService).getBranch(“accessibility.”);</p><p>// prefs is an nsIPrefBranch.<br>// Look in the above section for examples of getting one.<br>var value = prefs.getBoolPref(“typeaheadfind”); // get a pref (accessibility.typeaheadfind)<br>prefs.setBoolPref(“typeaheadfind”, !value); // set a pref (accessibility.typeaheadfind)</p><p>preference 条目的文档<br><a href="http://kb.mozillazine.org/About%3aconfig_entries" target="_blank" rel="noopener">http://kb.mozillazine.org/About%3aconfig_entries</a></p><p>defaults/preferences/prefs.js 不支持编程结构，参考<br>  <a href="https://developer.mozilla.org/en-US/docs/Default_Preferences" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Default_Preferences</a></p><p>保存 prefs<br>var prefService = Components.classes[“@mozilla.org/preferences-service;1”]<br>                               .getService(Components.interfaces.nsIPrefService);<br>prefService.savePrefFile(null);</p><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p>File I/O<br>  <a href="https://developer.mozilla.org/en-US/Add-ons/Code_snippets/File_I_O" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Add-ons/Code_snippets/File_I_O</a></p><p>nsIFile<br>  <a href="https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsIFile" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsIFile</a></p><p>FileUtils.jsm<br>  <a href="https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/FileUtils.jsm?redirectlocale=en-US&amp;redirectslug=JavaScript_code_modules%2FFileUtils.jsm" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/FileUtils.jsm?redirectlocale=en-US&amp;redirectslug=JavaScript_code_modules%2FFileUtils.jsm</a></p><ul><li>OS.File<br><a href="https://developer.mozilla.org/en-US/docs/JavaScript_OS.File" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/JavaScript_OS.File</a></li></ul><p>OS.File is a new API designed for efficient, off-main thread, manipulation of files by privileged JavaScript code. This API is intended to replace, in time, most XPCOM-based manipulation of files (nsIFile, subsets of nsIIOService, etc.) by JavaScript code.</p><p><a href="https://developer.mozilla.org/en-US/docs/JavaScript_OS.File/OS.File_for_the_main_thread" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/JavaScript_OS.File/OS.File_for_the_main_thread</a><br><a href="https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/OSFile.jsm/OS.File.DirectoryIterator_for_the_main_thread" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/OSFile.jsm/OS.File.DirectoryIterator_for_the_main_thread</a><br><a href="https://developer.mozilla.org/en-US/docs/JavaScript_OS.File/OS.Path" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/JavaScript_OS.File/OS.Path</a></p><p>XUL环境下的文件 IO 用这个库应该就足够了，不需要再与 sream 打交道。</p><p>OS.File.copy(sourcePath, destPath) 函数可以用于复制文件，不过似乎存在bug，在复制完成前promise就会完成：<br><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1166027" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=1166027</a></p><p>一些有用的路径：<br>  OS.Constants.Path.profileDir profile 的路径。如果在 application.ini 中设置了 Profile=MyAppData，则 OS.Constants.Path.profileDir 为 $HOME/.MyAppData/xxx.default。<br>  tmpDir 临时目录<br>  homeDir 用户主目录</p><ul><li>特殊路径<br>var iop = Components.classes[“@mozilla.org/file/directory_service;1”]<pre><code>    .getService(Components.interfaces.nsIProperties);</code></pre>var dir = iop.get(“ProfD”, Components.interfaces.nsIFile);</li></ul><p>其中 ProfD 可以替换为：<br>CurProcD     Current working directory (usually the application’s installation directory).<br>ProfD     The profile directory.<br>Home     The user’s home directory (for example, /home/username).<br>更多的值可以参考：<br><a href="https://developer.mozilla.org/en-US/Add-ons/Code_snippets/File_I_O" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Add-ons/Code_snippets/File_I_O</a></p><ul><li><p>HTML5 File API<br><a href="https://developer.mozilla.org/en-US/docs/Web/API/File" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/File</a><br>Gecko notes</p><p>  In Gecko, you can use this(File) API from chrome code. See Using the DOM File API in chrome code for details.<br>  Starting in Gecko 6.0 (Firefox 6.0 / Thunderbird 6.0 / SeaMonkey 2.3), privileged code (such as extensions) can pass an nsIFile object to the DOM File constructor to specify the file to reference.<br>  Starting in Gecko 8.0 (Firefox 8.0 / Thunderbird 8.0 / SeaMonkey 2.5), you can use new File to create File objects from XPCOM component code instead of having to instantiate the nsIDOMFile object directly.</p></li></ul><p><a href="https://developer.mozilla.org/en-US/docs/Extensions/Using_the_DOM_File_API_in_chrome_code" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Extensions/Using_the_DOM_File_API_in_chrome_code</a></p><p>不过，看来这种用法只适于读文件，而不是写文件。</p><p>在特权代码中，File.mozFullPath 属性表示 File 对象的全路径。</p><ul><li><p>Channel<br><a href="https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsIChannel" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsIChannel</a><br>This interface allows clients to construct ‘GET’ requests for specific protocols, and manage them in a uniform way. </p></li><li><p>Stream<br>Binary Stream<br><a href="https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsIBinaryOutputStream" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsIBinaryOutputStream</a><br><a href="https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsIBinaryInputStream" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsIBinaryInputStream</a></p></li></ul><p>Stream_Guide<br>  <a href="https://developer.mozilla.org/en-US/docs/XPCOM_Stream_Guide" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/XPCOM_Stream_Guide</a><br>ScriptableInputStream<br>  <a href="https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsIScriptableInputStream" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsIScriptableInputStream</a></p><ul><li><p>NetUtil<br><a href="https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/NetUtil.jsm" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/NetUtil.jsm</a></p><p>asyncFetch()</p></li></ul><p>The asyncFetch() method opens an input source, asynchronously, and gives an nsIInputStream containing the data obtained to the callback provided. The callback may then consume data from the input stream passed to the callback.</p><p>readInputStreamToString()</p><h2 id="DOM-Storage"><a href="#DOM-Storage" class="headerlink" title="DOM Storage"></a>DOM Storage</h2><p>chrome: 协议代码中无法使用 localStorage/sessionStorage 等。尽管这些对象是存在的，但访问它们会出现异常。参考：<br>Can’t access localStorage from chrome:// <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=495747" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=495747</a> 未来可能会解决。</p><p>注意，也无法将 localStorage 替换为自定义实现，赋值无效。<br>可能的变通是：</p><ol><li><p>使用 resource: 协议代码。但这种代码没有特权。参考<br><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=562646" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=562646</a></p></li><li><p>1 另一个变体是，使用http等协议，但是拦截请求。</p></li><li><p>将自定义实现绑定到另一个名字，例如 xxxLocalStorage。<br>具体的，可以使用 XPCOM 获得一个绑定到普通域的 localStorage，然后绑定到 xxxLocalStorage。参考<br><a href="http://stackoverflow.com/questions/20195541/html-5-local-storage-in-xul-application" target="_blank" rel="noopener">http://stackoverflow.com/questions/20195541/html-5-local-storage-in-xul-application</a></p></li></ol><p>var url = “<a href="http://example.com&quot;" target="_blank" rel="noopener">http://example.com&quot;</a>;<br>var ios = Components.classes[“@mozilla.org/network/io-service;1”]<br>          .getService(Components.interfaces.nsIIOService);<br>var ssm = Components.classes[“@mozilla.org/scriptsecuritymanager;1”]<br>          .getService(Components.interfaces.nsIScriptSecurityManager);<br>var dsm = Components.classes[“@mozilla.org/dom/storagemanager;1”]<br>          .getService(Components.interfaces.nsIDOMStorageManager);</p><p>var uri = ios.newURI(url, “”, null);<br>var principal = ssm.getCodebasePrincipal(uri);<br>var storage = dsm.getLocalStorageForPrincipal(principal, “”);</p><p>storage.setItem(“chromekey”, “chromevalue”);</p><h2 id="Javascript-集成"><a href="#Javascript-集成" class="headerlink" title="Javascript 集成"></a>Javascript 集成</h2><p>XPConnect<br><a href="https://developer.mozilla.org/en-US/docs/Mozilla/XPConnect" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Mozilla/XPConnect</a></p><p>mozIJSSubScriptLoader<br><a href="https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/mozIJSSubScriptLoader" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/mozIJSSubScriptLoader</a><br>This interface can be used from privileged JavaScript to load and run JavaScript code from the given URL at runtime.<br>var mozIJSSubScriptLoader = Components.classes[“@mozilla.org/moz/jssubscript-loader;1”]<br>                            .getService(Components.interfaces.mozIJSSubScriptLoader);</p><h3 id="geckofx-js-and-native-interop"><a href="#geckofx-js-and-native-interop" class="headerlink" title="geckofx js and native interop"></a>geckofx js and native interop</h3><p>D:\project\geckofx-29.0.hg\Geckofx-Core\AutoJSContext.cs<br>D:\project\geckofx-29.0.hg\Geckofx-Core\JQuery\JQueryExecutor.cs<br>D:\project\geckofx-29.0.hg\Geckofx-Core\Interop\SpiderMonkey\SpiderMonkey.cs</p><p>D:\project\geckofx-29.0.hg\GeckofxUnitTests\GeckoWebBrowserTests.cs<br>D:\project\geckofx-29.0.hg\GeckofxUnitTests\XPConnectTests.cs<br>D:\project\geckofx-29.0.hg\GeckofxUnitTests\XpComTests.cs</p><pre><code>    public void EvaluateScript_SimpleJavascript_ScriptExecutesAndReturnsExpectedResult()    {        browser.TestLoadHtml(&quot;&quot;);        using (AutoJSContext context = new AutoJSContext(browser.Window.JSContext))        {                            string result;            Assert.IsTrue(context.EvaluateScript(&quot;3 + 2;&quot;, out result));            Assert.AreEqual(5, Int32.Parse(result));            Assert.IsTrue(context.EvaluateScript(&quot;&#39;hello&#39; + &#39; &#39; + &#39;world&#39;;&quot;, out result));            Assert.AreEqual(&quot;hello world&quot;, result);        }                    }</code></pre><p>var instance = Xpcom.CreateInstance<nsISupports>(“@mozilla.org/byte-buffer;1”);</p><h2 id="页面加载状态监视和错误处理"><a href="#页面加载状态监视和错误处理" class="headerlink" title="页面加载状态监视和错误处理"></a>页面加载状态监视和错误处理</h2><p><a href="https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsIWebProgressListener" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsIWebProgressListener</a></p><p>LOCATION_CHANGE_ERROR_PAGE This flag indicates that aWebProgress redirected from the requested document to an internal page to show error status, such as about:neterror, about:certerror and so on. </p><h3 id="geckofx-1"><a href="#geckofx-1" class="headerlink" title="geckofx"></a>geckofx</h3><p>GeckoWebBrowser 有以下.net事件：<br>browser.Navigating<br>  开始导航到某个页面。注意这个事件也会在页面内导航、子框架（frame）导航时产生。<br>  GeckoNavigatingEventArgs.DomWindowTopLevel表示是否是顶层窗口的导航事件, GeckoNavigatingEventArgs.DomWindow 为事件相关的窗口。<br>  这时可以取消导航，GeckoNavigatingEventArgs 是 CancelEventArgs 的子类。<br>browser.Navigated<br>  导航结束，页面将开始解析（如果是新页面）。注意这个事件也会在错误页面、页面内导航、子框架（frame）导航时产生。<br>  （1）如果是新页面，这时JS上下文已经创建，可以注入和执行JS（AutoJSContext.EvaluateScript）；但页面本身尚未解析，html中的JS都还没有开始执行，<br>  因此这是注入跨语言交互代码的理想时机。<br>  （2）如果加载页面时发生网络错误，并且启用了内置错误页面（设置偏好 browser.xul.error_pages.enabled = true），则 GeckoNavigatedEventArgs.IsErrorPage == true；但HTTP错误（4xx, 5xx）不会反映在这里（TODO 如何检测）。顺提，如果没有启用了内置错误页面，则网络错误会通过对话框报告，详见PromptService。<br>  （3）GeckoNavigatedEventArgs.IsSameDocument 表示结局是否仍为原来的文档（即页面内跳转）；GeckoNavigatedEventArgs.DomWindowTopLevel 表示是否是顶层窗口的导航事件，<br>    GeckoNavigatedEventArgs.DomWindow 为事件相关的窗口。<br>browser.Load<br>  类似于 js window.onload 事件，不过会在 js window.onload 事件之前执行。所以如果有要在网页加载完后做处理，更好的时机是 DocumentCompleted 事件。<br>browser.ReadyStateChange<br>  等效于 JS 中的 document 的 readystatechange 事件，可以通过 browser.Window.Document.ReadyState:string 查询状态，有interactive, complete等。<br>browser.DocumentCompleted<br>  新页面、无网络错误时，在 Load 和 JS load 事件之后触发。<br>  如果要对加载完的页面做修改，这是个合适的地方。<br>  GeckoDocumentCompletedEventArgs 与 GeckoNavigatedEventArgs 类似，注意区分错误页面（无此参数）、页面内导航、子框架导航，HTTP错误。<br>  注意，如果有网络错误，并加载了错误页面，这个事件会在 Navigated 事件之前发生。</p><p>总结一下网络错误、并加载了错误页面时的事件：</p><p>使用服务器上关闭的端口时，此方法被调用<br>void nsIWebProgressListener.OnStatusChange(nsIWebProgress aWebProgress, nsIRequest aRequest, int aStatus, string aMessage)<br>aMessage    aStatus<br>Looking up <a href="http://www.baidu.com…">www.baidu.com…</a>   -2142568445<br>Connecting to <a href="http://www.baidu.com…">www.baidu.com…</a>    -2142568441</p><p>void nsIWebProgressListener.OnStateChange(nsIWebProgress aWebProgress, nsIRequest aRequest, uint aStateFlags, int aStatus)</p><p>PromptService : nsIPromptService2,nsIPrompt</p><h2 id="Clipboard"><a href="#Clipboard" class="headerlink" title="Clipboard"></a>Clipboard</h2><p><a href="https://developer.mozilla.org/en-US/docs/Using_the_Clipboard" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Using_the_Clipboard</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Jetpack/docs/System/Clipboard" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Jetpack/docs/System/Clipboard</a></p><h2 id="Debugging-调试"><a href="#Debugging-调试" class="headerlink" title="Debugging/调试"></a>Debugging/调试</h2><p><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/XULRunner/Debugging_XULRunner_applications" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Mozilla/Projects/XULRunner/Debugging_XULRunner_applications</a></p><h3 id="prefs"><a href="#prefs" class="headerlink" title="prefs"></a>prefs</h3><p>/* debugging prefs */<br>pref(“browser.dom.window.dump.enabled”, true);<br>pref(“javascript.options.showInConsole”, true);<br>pref(“javascript.options.strict”, true);<br>pref(“nglayout.debug.disable_xul_cache”, true);<br>pref(“nglayout.debug.disable_xul_fastload”, true);</p><p>也可以打开 about:config 来设置。</p><h3 id="本地控制台"><a href="#本地控制台" class="headerlink" title="本地控制台"></a>本地控制台</h3><p>也就是window.dump()方法，打印到操作系统控制台。默认情况下，dump没有启用，要设置偏好：<br>pref(“browser.dom.window.dump.enabled”, true);</p><p>在windows上，GUI程序默认没有控制台，要采用 -console 参数来启动 FF/xulrunner 才可以打开控制台。<br>此外，windows 的控制台默认编码不是UTF-8，中文系统上是 GBK，这会导致 dump 输出的中文乱码。</p><p>启动控制台编码  重定向文件编码 控制台编码 控制台是否乱码<br>utf8    utf8  gbk 是<br>gbk utf8    gbk 是</p><h3 id="debug-server"><a href="#debug-server" class="headerlink" title="debug server"></a>debug server</h3><p>参考<br>[1] <a href="https://developer.mozilla.org/en-US/docs/Tools/Remote_Debugging/Debugging_Firefox_Desktop" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Tools/Remote_Debugging/Debugging_Firefox_Desktop</a><br>[2]（37+已过时） <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/XULRunner/Debugging_XULRunner_applications" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Mozilla/Projects/XULRunner/Debugging_XULRunner_applications</a></p><p>怎样跟踪 firefox 中调试服务代码的变化？</p><ul><li>调试服务的源码是 devtools 的一部分，在 devtools/ 目录下；发布后则在 omni.ja!/modules/devtools 中。</li><li>可以在 mxr 搜索源码中的关键字：start-debugger-server（启动调试服务的命令行参数）, DebuggerServer, 6000 (调试服务的默认端口), &quot;devtools&quot;, debugger 等。</li></ul><p>在xul应用中，要打开DebuggerServer[2]（这个方法对 37+ 就不适用了）：<br>Components.utils.import(‘resource://gre/modules/devtools/dbg-server.jsm’);<br>if (!DebuggerServer.initialized) {<br>  DebuggerServer.init();<br>  DebuggerServer.addBrowserActors(null);<br>}<br>DebuggerServer.openListener(6000);<br>并设置属性允许远程调试：<br>pref(“devtools.debugger.remote-enabled”, true);</p><p>对于geckofx来说，每个进程只需要运行这个过程一次即可，不需要在每个窗口中运行。</p><p>然后用ff的 web开发者-&gt;连接 来进行远程调试。</p><p>远程调试 firefox 37+ 时，用<br>firefox.exe -P a_profile -no-remote -start-debugger-server 6101<br>启动被调试进程，设定允许chrome调试和远程调试，然后用另一个 firefox 实例连接调试。</p><p>或者，在浏览器中打开 chrome://browser/content/browser.xul 直接调试。</p><p>对于 xulrunner 37+，可以参考 firefox 的代码：</p><p>function startDebugNew() {<br>//<a href="http://mxr.mozilla.org/mozilla-central/search?string=start-debugger-server" target="_blank" rel="noopener">http://mxr.mozilla.org/mozilla-central/search?string=start-debugger-server</a><br>//<a href="http://mxr.mozilla.org/mozilla-central/source/browser/devtools/devtools-clhandler.js#28" target="_blank" rel="noopener">http://mxr.mozilla.org/mozilla-central/source/browser/devtools/devtools-clhandler.js#28</a><br>    var portOrPath = 6101;<br>    let { DevToolsLoader } =<br>      Cu.import(“resource://gre/modules/devtools/Loader.jsm”, {});</p><pre><code>try {  // Create a separate loader instance, so that we can be sure to receive  // a separate instance of the DebuggingServer from the rest of the  // devtools.  This allows us to safely use the tools against even the  // actors and DebuggingServer itself, especially since we can mark  // serverLoader as invisible to the debugger (unlike the usual loader  // settings).  let serverLoader = new DevToolsLoader();  serverLoader.invisibleToDebugger = true;  serverLoader.main(&quot;devtools/server/main&quot;);  let debuggerServer = serverLoader.DebuggerServer;  debuggerServer.init();  debuggerServer.addBrowserActors();  debuggerServer.allowChromeProcess = true;  let listener = debuggerServer.createListener();  listener.portOrPath = portOrPath;  listener.open();  dump(&quot;startDebugNew:Started debugger server on &quot; + portOrPath + &quot;\n&quot;);} catch(e) {  dump(&quot;startDebugNew:Unable to start debugger server on &quot; + portOrPath + &quot;: &quot; + e);}</code></pre><p>}</p><p>对于 xulrunner 45+ （实际上是firefox 45+ 伪装的），xulrunner 的 omni.ja 缺少了</p><h3 id="JavaScript-Console"><a href="#JavaScript-Console" class="headerlink" title="JavaScript Console"></a>JavaScript Console</h3><p>To enable the JS console, start XULRunner with the -jsconsole argument.<br>Note: If you are not using the stub executable to launch the application, the -jsconsole argument is after the application.ini argument: e.g. xulrunner.exe /path/to/application.ini -jsconsole</p><p>By default the JS console only shows errors from web content. To show errors in chrome JavaScript, the pref pref(“javascript.options.showInConsole”, true) must be set.</p><p>不过，console.log/error 输出的信息似乎无法显示在 JavaScript Console 中，eval也无法访问执行上下文中的对象，只有未捕获异常才会显示出来。</p><h3 id="本地js调试器"><a href="#本地js调试器" class="headerlink" title="本地js调试器"></a>本地js调试器</h3><ul><li>Venkman<br>这个扩展可以弹出一个gui调试器，不过需要在应用中去调用 Venkman 的函数，因此有特权代码可以启动它。<br>安装到 xulrunner 中的办法参考本文”给 xulrunner 安装扩展“一节。<br>按照此处的指引安装 Venkman 是可以的（注意装到xulrunner目录下），注意Troubleshooting一节。<br><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/XULRunner/Debugging_XULRunner_applications" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Mozilla/Projects/XULRunner/Debugging_XULRunner_applications</a></li></ul><h3 id="mozrepl"><a href="#mozrepl" class="headerlink" title="mozrepl"></a>mozrepl</h3><p><a href="https://github.com/bard/mozrepl/" target="_blank" rel="noopener">https://github.com/bard/mozrepl/</a> – 原版<br><a href="https://github.com/duanyao/mozrepl" target="_blank" rel="noopener">https://github.com/duanyao/mozrepl</a> – 打补丁适配 geckofx 的版本</p><p>这个扩展可以安装到FF、xulrunner app 或 xulrunner 本身当中。运行时，它在被调试的进程中开启一个telnet服务（端口4242），用telnet客户端连结上去以后可以执行js表达式和语句。<br>不过，它目前似乎在 geckofx 中跑不起来。</p><p>安装到 xulrunner 中的办法参考本文”给 xulrunner 安装扩展“一节。</p><p>运行 app 时，追加 -repl 参数即可启动 mozrepl。<br>如果要自动启动，设置 pref extensions.mozrepl.autoStart = true（mozrepl/defaults/preferences/mozrepl.js中）。</p><p>连接：<br>localhost 4242</p><p>在Windows上，如果没有 telnet 命令，可以安装 netcat 来代替：<br><a href="http://code.google.com/p/yesanshare/downloads/detail?name=nc111nt.zip&amp;can=2&amp;q=" target="_blank" rel="noopener">http://code.google.com/p/yesanshare/downloads/detail?name=nc111nt.zip&amp;can=2&amp;q=</a><br>安装 nc.exe 到 path 中，然后<br>nc localhost 4242</p><p>命令参考：<br><a href="https://github.com/bard/mozrepl/wiki/Tutorial" target="_blank" rel="noopener">https://github.com/bard/mozrepl/wiki/Tutorial</a></p><ul><li>geckofx 适配<br>在.net代码中，首先要按照geckofx一节中”注册xulrunner应用、扩展“的描述注册 mozrepl，然后启动服务器：<br>var mozrepl = Xpcom.CreateInstance&lt;MozRepl.nsIMozRepl&gt;(“@hyperstruct.net/mozlab/mozrepl;1”);<br>mozrepl.Start(4242, true | false);</li></ul><p>geckofx 的一个问题是 nsIWindowMediator 没有包含任何窗口，所以要查询 nsIWindowWatcher 来代替，详见：<br><a href="https://github.com/duanyao/mozrepl" target="_blank" rel="noopener">https://github.com/duanyao/mozrepl</a></p><ul><li>代码分析<br>mozrepl 监听 profile-after-change 事件（似乎会在程序启动时触发），如果设置了 autoStart = true，则启动服务器。</li></ul><p>profile-after-change 监听是在 chrome.manifest 中注册的，参考：<br><a href="http://stackoverflow.com/questions/3169852/how-to-listen-to-profile-after-change-in-xpcom-component-for-ff4" target="_blank" rel="noopener">http://stackoverflow.com/questions/3169852/how-to-listen-to-profile-after-change-in-xpcom-component-for-ff4</a><br>监听的实现代码在 mozrepl/chrome/content/server.js:observe</p><p>服务器是个 XPCOM 组件。<br>接口：nsIMozRepl（MozRepl.idl）<br>实现：mozrepl/chrome/content/server.js<br>CONTRACT_ID = ‘@hyperstruct.net/mozlab/mozrepl;1’<br>CLASS_ID = 57f4284b-1f9b-4990-8525-9ed5cbb23e01<br>启动、停止服务器的方法是<br>void start(in short port, in boolean loopbackOnly);<br>void stop();</p><h3 id="本地代码调试"><a href="#本地代码调试" class="headerlink" title="本地代码调试"></a>本地代码调试</h3><p>VS 中设置 Mozilla symbol server<br><a href="https://developer.mozilla.org/en-US/docs/Using_the_Mozilla_symbol_server" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Using_the_Mozilla_symbol_server</a></p><p>对于 xulrunner 设置 symbol server<br><a href="http://symbols.mozilla.org/xulrunner" target="_blank" rel="noopener">http://symbols.mozilla.org/xulrunner</a></p><p>并且只允许加载下面的符号，以免太慢<br>xul.dll<br>mozjs.dll<br>mozglue.dll</p><p>以及 Mozilla source server<br><a href="https://developer.mozilla.org/en-US/docs/Using_the_Mozilla_source_server" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Using_the_Mozilla_source_server</a></p><p>也可以下载源码包，解压后，当用VS调试时点击调用栈，VS会询问源文件的位置，选择解压后的源文件即可。<br><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/Source_Code/Downloading_Source_Archives" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/Source_Code/Downloading_Source_Archives</a></p><h2 id="拦截网络请求"><a href="#拦截网络请求" class="headerlink" title="拦截网络请求"></a>拦截网络请求</h2><p>Firefox 扩展可以拦截网络请求和回复，因此可以用特殊的http url表示模拟的本地文件系统。<br>参考：<br>  <a href="http://stackoverflow.com/questions/2141469/create-firefox-addon-to-watch-and-modify-xhr-requests-reponses" target="_blank" rel="noopener">http://stackoverflow.com/questions/2141469/create-firefox-addon-to-watch-and-modify-xhr-requests-reponses</a><br>  <a href="http://www.softwareishard.com/blog/firebug/nsitraceablechannel-intercept-http-traffic/" target="_blank" rel="noopener">http://www.softwareishard.com/blog/firebug/nsitraceablechannel-intercept-http-traffic/</a><br>  <a href="http://stackoverflow.com/questions/7222577/firefox-extension-cancel-requests-and-emit-fake-responses" target="_blank" rel="noopener">http://stackoverflow.com/questions/7222577/firefox-extension-cancel-requests-and-emit-fake-responses</a><br>  <a href="https://developer.mozilla.org/en-US/docs/XUL/School_tutorial/Intercepting_Page_Loads" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/XUL/School_tutorial/Intercepting_Page_Loads</a><br>  <a href="https://developer.mozilla.org/en-US/docs/Observer_Notifications" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Observer_Notifications</a> http-on-opening-request</p><ul><li><p>The Easy Way: Load Events<br>监听全局浏览器对象 gBrowser 的 “load” 事件。这个事件类似 web 中的 load 事件，是针对tab中的主文档或iframe中的文档的。<br>可以趁机修改DOM，但是不能在DOM构建前取消或修改响应。</p></li><li><p>HTTP Observers<br>对每个http请求都发出事件。允许在请求发出前修改头，或者取消请求，或者在收到响应后修改响应。<br>使用 nsITraceableChannel，可以在收到响应后修改内容，然后再传递给原来的发起者。<br>相关文档：<br><a href="https://developer.mozilla.org/en-US/docs/Observer_Notifications" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Observer_Notifications</a><br><a href="https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/NsITraceableChannel" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/NsITraceableChannel</a><br>但是，看起来请求还是会发到原来请求的url，并不能做成完全合成的请求/响应。</p></li><li><p>WebProgressListeners<br>针对每个 xul browser 实例（也就是浏览器tab），每个tab打开关闭的时候要添加删除监听器。</p></li><li><p>XPCOM Solutions<br>Document Loader Service<br>相当于全局 Web Progress Listener.<br>nsIDocumentLoader is nothing but a global Web Progress Listener. You can create an XPCOM component that extends nsIWebProgressListener and use the addProgressListener method in the service to include it. </p></li></ul><p>Content Policy<br>只能用于取消请求。</p><h2 id="自定义协议处理器"><a href="#自定义协议处理器" class="headerlink" title="自定义协议处理器"></a>自定义协议处理器</h2><p>Firefox 扩展可以添加自定义协议处理器。<br>  <a href="http://mike.kaply.com/2011/01/18/writing-a-firefox-protocol-handler/" target="_blank" rel="noopener">http://mike.kaply.com/2011/01/18/writing-a-firefox-protocol-handler/</a><br>  <a href="https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsIProtocolHandler" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsIProtocolHandler</a></p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p><a href="https://developer.mozilla.org/en-US/docs/Displaying_web_content_in_an_extension_without_security_issues" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Displaying_web_content_in_an_extension_without_security_issues</a></p><p><a href="https://developer.mozilla.org/en-US/Add-ons/Code_snippets/Interaction_between_privileged_and_non-privileged_pages" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Add-ons/Code_snippets/Interaction_between_privileged_and_non-privileged_pages</a></p><h3 id="同源规则"><a href="#同源规则" class="headerlink" title="同源规则"></a>同源规则</h3><p>mozilla 平台似乎没有 chrome 那样的命令行或API可以关掉同源规则。参考：<br><a href="http://stackoverflow.com/questions/17711924/disable-cross-domain-web-security-in-firefox" target="_blank" rel="noopener">http://stackoverflow.com/questions/17711924/disable-cross-domain-web-security-in-firefox</a><br><a href="http://stackoverflow.com/questions/17088609/disable-firefox-same-origin-policy" target="_blank" rel="noopener">http://stackoverflow.com/questions/17088609/disable-firefox-same-origin-policy</a><br><a href="http://stackoverflow.com/questions/330427/can-i-disable-sop-same-origin-policy-on-any-browser-for-development" target="_blank" rel="noopener">http://stackoverflow.com/questions/330427/can-i-disable-sop-same-origin-policy-on-any-browser-for-development</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Same-origin_policy_for_file:_URIs" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Same-origin_policy_for_file:_URIs</a></p><p>Force CORS Firefox Extension<br><a href="http://www-jo.se/f.pfleger/forcecors" target="_blank" rel="noopener">http://www-jo.se/f.pfleger/forcecors</a></p><p>过去的FF，可以修改 profile 目录下的 prefs.js，加入<br>user_pref(“capability.principal.myapp.id”, “file:///D:/project/MyHTML/xhrtest.html”);<br>user_pref(“capability.principal.myapp.granted”, “UniversalBrowserRead”);<br>注意 about:config 不显示这类配置。<br>但是看起来这个特性被删除了，不起作用，而且FF关闭时会删除这样的配置。</p><p>总结起来就是，最近的FF（28+），不支持放开非特权页面的特权，只有 chrome: 协议的页面能绕开同源限制。参考：<br><a href="https://developer.mozilla.org/en-US/docs/Bypassing_Security_Restrictions_and_Signing_Code" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Bypassing_Security_Restrictions_and_Signing_Code</a></p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>navigator.mozTCPSocket 或者 navigator.TCPSocket 是可以用于浏览器环境的 TCP Socket 实现。<br>W3C正在讨论中，目前只有 mozilla 实现了，只能在特权代码或者特权 web app 中使用。<br>在 xulrunner 或桌面 firefox 中，目前（40）需要设置 dom.mozTCPSocket.enabled = true 来启用（<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1079648）。" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=1079648）。</a></p><h2 id="mozilla-跨不同权限页面的交互"><a href="#mozilla-跨不同权限页面的交互" class="headerlink" title="mozilla 跨不同权限页面的交互"></a>mozilla 跨不同权限页面的交互</h2><h3 id="frame-嵌入"><a href="#frame-嵌入" class="headerlink" title="frame 嵌入"></a>frame 嵌入</h3><p>特权页面中可以嵌入非特权页面，但反过来不行，只会显示一个空白页。</p><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>给非特权页面的 WebIDL 添加的扩展方法，特权页面并不能有效访问，可能是因为安全限制：<br><a href="https://developer.mozilla.org/en-US/Add-ons/Code_snippets/Interaction_between_privileged_and_non-privileged_pages" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Add-ons/Code_snippets/Interaction_between_privileged_and_non-privileged_pages</a><br>Gecko prevents chrome to access custom object properties added by the content, because that can create security holes.<br>Never invoke the web page’s JavaScript functions from your extension - doing this increases the chance of creating a security hole, where a malicious web page can trick the browser to run its code with extended privileges (just like your extension) with, for example, the ability to delete local files.</p><h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><ul><li>web message<br>特权页面可以给非特权页面发送 web message；但从非特权页面发给特权页面似乎没有效果。</li></ul><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="dbus"><a href="#dbus" class="headerlink" title="dbus"></a>dbus</h3><ul><li><p>mozjs-dbus<br><a href="https://github.com/codebutler/mozjs-dbus/wiki" target="_blank" rel="noopener">https://github.com/codebutler/mozjs-dbus/wiki</a><br>makes it possible for Mozilla/Javascript-based applications and extensions to interoperable with<br>D-Bus, which allows for deep integration with the Linux desktop.<br>代码相当老了（5年）。</p></li><li><p>Browser DBus Bridge<br><a href="http://sandbox.movial.com/wiki/index.php/Browser_DBus_Bridge" target="_blank" rel="noopener">http://sandbox.movial.com/wiki/index.php/Browser_DBus_Bridge</a><br>The Browser D-Bus Bridge is a JavaScript D-Bus bindings implementation for web browsers. The Bridge allows privileged JavaScript code to talk to the D-Bus, both session and system bus (if not prohibited by the D-Bus configuration).</p></li></ul><p>The bridge currently supports Gecko-based and WebKit-based browsers. Each of these have their own implementation of the Bridge due to technical differences in the integration, but support the same API on the JavaScript side.<br>代码相当老了。</p><ul><li>D-Bus and other Linux desktop integration improvements, DBuzilla<br><a href="http://zenit.senecac.on.ca/wiki/index.php/D-Bus_and_other_Linux_desktop_integration_improvements" target="_blank" rel="noopener">http://zenit.senecac.on.ca/wiki/index.php/D-Bus_and_other_Linux_desktop_integration_improvements</a><br>代码相当老了（7年）。</li></ul><h2 id="嵌入"><a href="#嵌入" class="headerlink" title="嵌入"></a>嵌入</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.mozilla.org/en-US/docs/Gecko/Embedding_Mozilla/API_overview" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Gecko/Embedding_Mozilla/API_overview</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Gecko/Embedding_Mozilla/Roll_your_own_browser" target="_blank" rel="noopener">Roll your own browser: An embedding how-to</a> on MDN. (out dated)</p><p>将Mozilla源码里的内嵌Gecko示例winEmbed工程移植到VC (1.9)<br>  <a href="http://blog.csdn.net/mzlogin/article/details/7292310" target="_blank" rel="noopener">http://blog.csdn.net/mzlogin/article/details/7292310</a></p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li>nsIWebBrowser</li></ul><p>This is the primary interface to the WebBrowser component.</p><ul><li><p>nsIWebBrowserSetup<br>SETUP_IS_CHROME_WRAPPER=7<br>Boolean. Marks whether the browser is a chrome wrapper. A value of PR_TRUE means the browser is a chrome wrapper. The default value is PR_FALSE. </p></li><li><p>nsIWebBrowserChrome</p></li></ul><p>This interface provides access to the window containing an nsWebBrowser instance.</p><ul><li><p>nsIChromeRegistry<br><a href="https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsIChromeRegistry" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsIChromeRegistry</a></p></li><li><p>nsIXULAppInfo<br>In XULRunner applications nsIXULAppInfo obtains app-specific information from application.ini.<br><a href="https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsIXULAppInfo" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/XPCOM_Interface_Reference/nsIXULAppInfo</a></p></li><li><p>nsIXULRuntime<br>Provides information about the XUL runtime to allow extensions and XUL applications to determine information about the XUL runtime. </p></li><li><p>nsIAppShell<br>Interface for the native event system layer. This interface is designed to be used on the main application thread only. </p></li><li><p>nsIAppStartup<br>This interface is intended to be used as application startup service. It also helps in quitting applications as well. </p></li><li><p>nsIAppShellService<br>Provides the AppShellService. </p></li><li><p>nsIFile/nsILocalFile<br>创建<br>var localFile = Components.classes[“@mozilla.org/file/local;1”]</p><pre><code>          .createInstance(Components.interfaces.nsILocalFile);</code></pre><p>或者<br>Components.utils.import(“resource://gre/modules/FileUtils.jsm”);</p></li></ul><p>var file = new FileUtils.File(“/home”);</p><p>初始化<br>localFile.initWithPath(in AString filePath);<br>  js 中直接传入string，geckofx中传入nsAString对象。</p><h3 id="应用的解析"><a href="#应用的解析" class="headerlink" title="应用的解析"></a>应用的解析</h3><ul><li>application.ini 的解析<br>browser/app/nsBrowserApp.cpp 或者<br>xulrunner/app/nsXULRunnerApp.cpp</li></ul><p><a href="http://mxr.mozilla.org/mozilla-central/source/xulrunner/app/nsXULRunnerApp.cpp" target="_blank" rel="noopener">http://mxr.mozilla.org/mozilla-central/source/xulrunner/app/nsXULRunnerApp.cpp</a></p><p>277   nsCOMPtr<nsIFile> appDataLF;<br>278   rv = XRE_GetFileFromPath(appDataFile, getter_AddRefs(appDataLF));<br>279   if (NS_FAILED(rv)) {<br>280     Output(true, “Error: unrecognized application.ini path.\n”);<br>281     return 2;<br>282   }<br>283<br>284   AutoAppData appData(appDataLF);<br>285   if (!appData) {<br>286     Output(true, “Error: couldn’t parse application.ini.\n”);<br>287     return 2;<br>288   }<br>290   return XRE_main(argc, argv, appData, 0);</p><p>解析代码的实现在<br><a href="http://mxr.mozilla.org/mozilla-central/source/toolkit/xre/CreateAppData.cpp#15" target="_blank" rel="noopener">http://mxr.mozilla.org/mozilla-central/source/toolkit/xre/CreateAppData.cpp#15</a></p><p>nsresult XRE_CreateAppData(nsIFile* aINIFile, nsXREAppData **aAppData)</p><p>xul 应用入口函数是 XRE_main<br><a href="http://mxr.mozilla.org/mozilla-central/source/toolkit/xre/nsAppRunner.cpp#4227" target="_blank" rel="noopener">http://mxr.mozilla.org/mozilla-central/source/toolkit/xre/nsAppRunner.cpp#4227</a><br> XRE_main(int argc, char* argv[], const nsXREAppData* aAppData, uint32_t aFlags)</p><p><a href="http://mxr.mozilla.org/mozilla-central/source/toolkit/xre/nsAppRunner.cpp#2719" target="_blank" rel="noopener">http://mxr.mozilla.org/mozilla-central/source/toolkit/xre/nsAppRunner.cpp#2719</a><br>2718 // Encapsulates startup and shutdown state for XRE_main<br>2719 class XREMain</p><ul><li>chrome.manifest 的解析<br><a href="http://mxr.mozilla.org/mozilla-central/source/xpcom/build/nsXULAppAPI.h#263" target="_blank" rel="noopener">http://mxr.mozilla.org/mozilla-central/source/xpcom/build/nsXULAppAPI.h#263</a><br>240 /<em>*<br>241  * Register XPCOM components found in an array of files/directories.<br>242  * This method may be called at any time before or after XRE_main or<br>243  * XRE_InitEmbedding.<br>244  *<br>245  * @param aFiles An array of files or directories.<br>246  * @param aFileCount the number of items in the aFiles array.<br>247  * @note appdir/components is registered automatically.<br>248  *<br>249  * NS_COMPONENT_LOCATION specifies a location to search for binary XPCOM<br>250  * components as well as component/chrome manifest files.<br>251  *<br>252  * NS_SKIN_LOCATION specifies a location to search for chrome manifest files<br>253  * which are only allowed to register only skin packages and style overlays.<br>254  */<br>255 enum NSLocationType<br>256 {<br>257   NS_COMPONENT_LOCATION,<br>258   NS_SKIN_LOCATION,<br>259   NS_BOOTSTRAPPED_LOCATION<br>260 };<br>261<br>262 XRE_API(nsresult,<br>263         XRE_AddManifestLocation, (NSLocationType aType,<br>264                                   nsIFile</em> aLocation))</li></ul><p>另一个可能的方法是 nsIComponentManager.addBootstrappedManifestLocation((in nsILocalFile aLocation)<br>geckofx 中的代码例子：<br>            var chromeDir = Xpcom.CreateInstance<nsILocalFile> (“@mozilla.org/file/local;1”);<br>            chromeDir.InitWithPath (new nsAString (“D:\project\MBEditor.js.git\mozApp”));<br>            Xpcom.ComponentManager.AddBootstrappedManifestLocation (chromeDir);</p><h2 id="JS-引擎：SpiderMonkey"><a href="#JS-引擎：SpiderMonkey" class="headerlink" title="JS 引擎：SpiderMonkey"></a>JS 引擎：SpiderMonkey</h2><p><a href="https://developer.mozilla.org/en-US/docs/SpiderMonkey/JSAPI_User_Guide" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/SpiderMonkey/JSAPI_User_Guide</a></p><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>JS_AddRoot/JS_RemoveRoot<br><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/JSAPI_reference/JS_AddRoot" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/JSAPI_reference/JS_AddRoot</a><br>The JS_Add*Root and functions add a C/C++ variable to the garbage collector’s root set, the set of variables used as starting points each time the collector checks to see what memory is reachable. The garbage collector aggressively collects and recycles memory that it deems unreachable, so roots are often necessary to protect data from being prematurely collected.</p><h3 id="mozjs-函数签名"><a href="#mozjs-函数签名" class="headerlink" title="mozjs 函数签名"></a>mozjs 函数签名</h3><p>?JS_EvaluateUCScript@@YA_NPAUJSContext@@V?$Handle@PAVJSObject@@@JS@@PB_WIPBDIV?$MutableHandle@VValue@JS@@@3@@Z<br>?JS_ExecuteScript@@YA_NPAUJSContext@@PAVJSObject@@PAVJSScript@@PAVValue@JS@@@Z</p><p>bool JS_EvaluateUCScript(struct JSContext *,class JS::Handle&lt;class JSObject *&gt;,wchar_t const *,unsigned int,char const *,unsigned int,class JS::MutableHandle<class JS::Value>)<br>bool JS_ExecuteScript(struct JSContext *,class JSObject *,class JSScript *,class JS::Value *)</p><p>DomMessageEventArgs</p><p>internal string ConvertValueToString(JsVal value)<br><a href="https://developer.mozilla.org/en-US/docs/SpiderMonkey/JSAPI_Reference/JS_GetStringChars" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/SpiderMonkey/JSAPI_Reference/JS_GetStringChars</a></p><p>wchar_t const * JS_GetStringCharsZAndLength(struct JSContext *,class JSString *,unsigned int *)<br>?JS_GetStringCharsZAndLength@@YAPB_WPAUJSContext@@PAVJSString@@PAI@Z</p><p>wchar_t const * JS_GetStringCharsZ(struct JSContext *,class JSString *)<br>?JS_GetStringCharsZ@@YAPB_WPAUJSContext@@PAVJSString@@@Z</p><p>wchar_t const * JS_GetStringCharsAndLength(struct JSContext *,class JSString *,unsigned int *)<br>?JS_GetStringCharsAndLength@@YAPB_WPAUJSContext@@PAVJSString@@PAI@Z</p><p>unsigned int JS_GetStringLength(class JSString *)<br>?JS_GetStringLength@@YAIPAVJSString@@@Z</p><p>?JS_EvaluateUCScript@@YA_NPAUJSContext@@V?$Handle@PAVJSObject@@@JS@@PB_WIPBDIV?$MutableHandle@VValue@JS@@@3@@Z<br>?JS_ExecuteScript@@YA_NPAUJSContext@@PAVJSObject@@PAVJSScript@@PAVValue@JS@@@Z</p><p>bool JS_EvaluateUCScript(struct JSContext *,class JS::Handle&lt;class JSObject *&gt;,wchar_t const *,unsigned int,char const *,unsigned int,class JS::MutableHandle<class JS::Value>)<br>bool JS_ExecuteScript(struct JSContext *,class JSObject *,class JSScript *,class JS::Value *)</p><p>DomMessageEventArgs</p><p>internal string ConvertValueToString(JsVal value)<br><a href="https://developer.mozilla.org/en-US/docs/SpiderMonkey/JSAPI_Reference/JS_GetStringChars" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/SpiderMonkey/JSAPI_Reference/JS_GetStringChars</a></p><p>wchar_t const * JS_GetStringCharsZAndLength(struct JSContext *,class JSString *,unsigned int *)<br>?JS_GetStringCharsZAndLength@@YAPB_WPAUJSContext@@PAVJSString@@PAI@Z</p><p>wchar_t const * JS_GetStringCharsZ(struct JSContext *,class JSString *)<br>?JS_GetStringCharsZ@@YAPB_WPAUJSContext@@PAVJSString@@@Z</p><p>wchar_t const * JS_GetStringCharsAndLength(struct JSContext *,class JSString *,unsigned int *)<br>?JS_GetStringCharsAndLength@@YAPB_WPAUJSContext@@PAVJSString@@PAI@Z</p><p>unsigned int JS_GetStringLength(class JSString *)<br>?JS_GetStringLength@@YAIPAVJSString@@@Z</p><h2 id="omni"><a href="#omni" class="headerlink" title="omni"></a>omni</h2><p>omni.ja 文件是个特殊的 zip 文件（windows explorer 可打开，7zip不行），里面包含moz平台的界面的xul/css/js代码，包括调试器(devtools)等。</p><p>omni.ja 这个文件名有特殊意义。与 xul.dll (或.so) 同一目录的 omni.ja 会被 xul.dll 自动加载；<br>与 xul 应用的 application.ini 同一目录的 omni.ja 也会被自动加载。</p><p>加载 omni.ja 时，会通过其内部根目录下的 chrome.manifest 来注册。</p><p>如果要修改、调试 xulrunner/firefox 的 omni.ja 的代码，可以将它解压在其所在的目录，再把它改名/删除。<br>正确的压缩命令：zip -qr9XD omni.ja *</p><p>firefox 除了在顶层目录（xul.dll所在的目录）有一个 omni.ja，还在 browser/ 目录下有一个 omni.ja。前者与 xulrunner 的相同，后者是只有 firefox 需要的文件。</p><p>参考：<br><a href="https://developer.mozilla.org/en-US/docs/Mozilla/About_omni.ja_%28formerly_omni.jar%29" target="_blank" rel="noopener">About omni.ja (formerly omni.jar)</a><br><a href="https://blog.mozilla.org/mwu/2010/08/13/omnijar-how-does-it-work/" target="_blank" rel="noopener">Omnijar. How does it work?</a><br><a href="https://blog.mozilla.org/tglek/2010/09/14/firefox-4-jar-jar-jar/" target="_blank" rel="noopener">Firefox 4: jar jar jar</a></p><h2 id="本地化（中文化）-i18n"><a href="#本地化（中文化）-i18n" class="headerlink" title="本地化（中文化） i18n"></a>本地化（中文化） i18n</h2><p>xulrunner 的发行版没有中文版，所以有些界面，如错误页面，是英文的。<br>界面相关的资源在 omni.ja 文件中，这是个特殊的zip文件，参考<br><a href="https://developer.mozilla.org/zh-CN/docs/Mozilla/About_omni.ja_%28formerly_omni.jar%29" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Mozilla/About_omni.ja_%28formerly_omni.jar%29</a></p><p>可以用中文版 firefox 的 omni.ja 文件来替换，从而将 xulrunner 改为中文版。要注意选择与 xulrunner 版本号相同的 firefox。</p><p>geckofx 中，js alert/prompt 等对话框还是有英文，因为用了自定义的对话框。<br>解决办法是修改自定义对话框中的文字，或者用xulrunner本身的对话框。参考：<br>GeckoWebBrowser.UseCustomPrompt() 和 d:\Geckofx-Winforms\PromptService.cs<br><a href="http://localhost" target="_blank" rel="noopener">http://localhost</a><br>javascript:confirm(‘hh’)</p><h2 id="下载-TODO"><a href="#下载-TODO" class="headerlink" title="下载 TODO"></a>下载 TODO</h2><h2 id="插件-plugin"><a href="#插件-plugin" class="headerlink" title="插件/plugin"></a>插件/plugin</h2><h3 id="禁用个别插件"><a href="#禁用个别插件" class="headerlink" title="禁用个别插件"></a>禁用个别插件</h3><p><a href="http://serverfault.com/questions/340195/disable-certain-firefox-plugins-system-wide-by-default" target="_blank" rel="noopener">http://serverfault.com/questions/340195/disable-certain-firefox-plugins-system-wide-by-default</a><br>Disable Certain Firefox Plugins System-wide by Default</p><p>The plugins’ settings are now integrated partially in about:config as of Firefox 22, and fully in 23+. The key names are plugin.state.* where * denotes the internal naming scheme used by Firefox for the discovered plugins. The values (integer) are 0 for disabled (Never Activate in Firefox Tools (Alt + T) &gt; Add-ons &gt; Plugins), 1 for click-to-play (Ask to Activate), and 2 for enabled (Always Activate). Firefox 22 has 0 and 2, and 23+ includes all the three states. The state Ask to Activate (1) is triggered after toggling plugins.click_to_play to true in about:config.</p><p>One way to get the correct names used by Firefox is from a reference/IT PC. Toggle the default states of all the discovered plugins (Firefox Tools (Alt + T) &gt; Add-ons &gt; Plugins) once, to reveal the corresponding plugin.state.* keys in about:config.</p><p>VLC:<br>plugin.state.npvlc</p><p>Acrobat:<br>plugin.state.nppdf<br>注意这不影响 pdf.js。</p><p>Java:<br>plugin.state.java</p><p>Flash:<br>plugin.state.flash</p><p>Silverlight:<br>plugin.state.npctrl</p><p>在禁用后：<br>object标签如果有替代内容，则显示替代内容；如果没有，firefox 显示一个黑色窗口写着“此插件已被禁用”，xulrunner/geckofx只有一个黑窗，没有提示（可能是bug）。</p><h3 id="禁用全部插件"><a href="#禁用全部插件" class="headerlink" title="禁用全部插件"></a>禁用全部插件</h3><p>“plugin.disable” = true </p><h2 id="下载和未知内容的处理"><a href="#下载和未知内容的处理" class="headerlink" title="下载和未知内容的处理"></a>下载和未知内容的处理</h2><p>当触发a[download] 或未知类型的链接时，浏览器一般会弹出对话框提示是否用其它应用程序打开，或者下载保存链接。<br>但xulrunner应用、geckofx则有一些麻烦，有时候会出错（firefox28, xulrunner 29）。</p><h2 id="web控制台"><a href="#web控制台" class="headerlink" title="web控制台"></a>web控制台</h2><p>有时firefox的控制台显示“Web 控制台的日志记录API (console.log, console.info, console.warn, console.error) 已被此页面的脚本禁用。”<br>网页中的console.log是输出不了信息的。这可能是因为某些扩展的问题。尝试禁用一些扩展，看看问题是否解决了。参考：<br>Firefox的Web控制台禁用？<a href="http://codego.net/382392/" target="_blank" rel="noopener">http://codego.net/382392/</a></p><h2 id="内存使用，内存泄露-（memory-usage-amp-leak）"><a href="#内存使用，内存泄露-（memory-usage-amp-leak）" class="headerlink" title="内存使用，内存泄露 （memory usage &amp; leak）"></a>内存使用，内存泄露 （memory usage &amp; leak）</h2><p>A better about:memory: stage 1.75<br>  <a href="https://blog.mozilla.org/nnethercote/2011/05/23/a-better-aboutmemory-stage-1-75/" target="_blank" rel="noopener">https://blog.mozilla.org/nnethercote/2011/05/23/a-better-aboutmemory-stage-1-75/</a></p><p>How to read Firefox “about:memory” correctly?<br>  <a href="http://stackoverflow.com/questions/7146108/how-to-read-firefox-aboutmemory-correctly" target="_blank" rel="noopener">http://stackoverflow.com/questions/7146108/how-to-read-firefox-aboutmemory-correctly</a></p><p>Zombie compartments<br>  <a href="https://developer.mozilla.org/en-US/docs/Zombie_compartments" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Zombie_compartments</a></p><p>Per-class JS object and shape measurements in Firefox’s about:memory<br>  <a href="https://blog.mozilla.org/nnethercote/2014/08/29/per-class-js-object-and-shape-measurements-in-firefoxs-aboutmemory/" target="_blank" rel="noopener">https://blog.mozilla.org/nnethercote/2014/08/29/per-class-js-object-and-shape-measurements-in-firefoxs-aboutmemory/</a></p><p>MemShrink’s 3rd birthday<br>  <a href="https://blog.mozilla.org/nnethercote/2014/06/16/memshrinks-3rd-birthday/" target="_blank" rel="noopener">https://blog.mozilla.org/nnethercote/2014/06/16/memshrinks-3rd-birthday/</a></p><p>MemShrink progress<br>  <a href="https://blog.mozilla.org/nnethercote/category/aboutcompartments/" target="_blank" rel="noopener">https://blog.mozilla.org/nnethercote/category/aboutcompartments/</a></p><p>Firefox 15 plugs the add-on leaks<br>  <a href="https://blog.mozilla.org/nnethercote/2012/07/19/firefox-15-plugs-the-add-on-leaks/" target="_blank" rel="noopener">https://blog.mozilla.org/nnethercote/2012/07/19/firefox-15-plugs-the-add-on-leaks/</a></p><p>Leak Monitor Extension<br>  <a href="http://dbaron.org/mozilla/leak-monitor/" target="_blank" rel="noopener">http://dbaron.org/mozilla/leak-monitor/</a></p><p>Firefox memory leak detection tool<br>  <a href="http://www.squarefree.com/2006/01/13/memory-leak-detection-tool/" target="_blank" rel="noopener">http://www.squarefree.com/2006/01/13/memory-leak-detection-tool/</a></p><p>Please file good memory leak bugs<br>  <a href="http://dbaron.org/log/2006-01#e20060110a" target="_blank" rel="noopener">http://dbaron.org/log/2006-01#e20060110a</a></p><p>System-wide memory measurement for Firefox OS<br>  <a href="https://blog.mozilla.org/nnethercote/2013/12/17/system-wide-memory-measurement-for-firefox-os/" target="_blank" rel="noopener">https://blog.mozilla.org/nnethercote/2013/12/17/system-wide-memory-measurement-for-firefox-os/</a></p><h3 id="ghost-windows"><a href="#ghost-windows" class="headerlink" title="ghost-windows"></a>ghost-windows</h3><p>What is a “ghost window”?<br>  <a href="http://forum.palemoon.org/viewtopic.php?f=26&amp;t=3476" target="_blank" rel="noopener">http://forum.palemoon.org/viewtopic.php?f=26&amp;t=3476</a></p><p>Report number of ghost windows in telemetry<br>  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=737857" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=737857</a></p><h2 id="直接执行特权js代码"><a href="#直接执行特权js代码" class="headerlink" title="直接执行特权js代码"></a>直接执行特权js代码</h2><p>TODO<br>geckofx 中，不创建 browser 对象，直接创建 AutoJSContext:<br> new AutoJSContext()<br> new AutoJSContext(GlobalJSContextHolder.BackstageJSContext)<br>但这样的代码都没有特权，找不到 Components 对象。</p><h2 id="综合代码片段"><a href="#综合代码片段" class="headerlink" title="综合代码片段"></a>综合代码片段</h2><p>Code_snippets/Miscellaneous<br>  <a href="https://developer.mozilla.org/en-US/Add-ons/Code_snippets/Miscellaneous" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Add-ons/Code_snippets/Miscellaneous</a><br>包括：<br>  Saving an arbitrary URL to a local file<br>  Operating system detection</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="UcWORK统一桌面系统"><a href="#UcWORK统一桌面系统" class="headerlink" title="UcWORK统一桌面系统"></a>UcWORK统一桌面系统</h3><p><a href="http://www.qqtech.com/ucwork.htm" target="_blank" rel="noopener">http://www.qqtech.com/ucwork.htm</a></p><pre><code>    UcWORK基于桌面应用的设计思想，采用mozilla技术框架，并进行多方面的扩展实现，UcWork是主平台/框架，其它应用可嵌入到UcWork中，这是我们的主推目标。此种情况是“我为主，人为辅”。    客户或代理商(第三方)可以在界面和服务器层扩展应用。界面和服务层通过UcBUS(即DBUS)交互。在服务层，UcWork除提供DBus接口外，还可提供面向服务层的API接口，供第三方服务层开发调用。</code></pre><h3 id="XULApp-StarterKit"><a href="#XULApp-StarterKit" class="headerlink" title="XULApp StarterKit"></a>XULApp StarterKit</h3><p><a href="https://github.com/racklin/xulapp-starterkit" target="_blank" rel="noopener">https://github.com/racklin/xulapp-starterkit</a></p><p>XULApp StarterKit is a generic framework for XULRunner applications, like Rich Client Platform .</p><p>It provides the “plumbing” that, before, every developer had to write themselves—saving state, connecting actions to menu items, toolbar items and keyboard shortcuts; window management, add-ons mechanism, update mechanism and so on.</p><h2 id="链接-内容处理方式"><a href="#链接-内容处理方式" class="headerlink" title="链接/内容处理方式"></a>链接/内容处理方式</h2><p>Document Loading - From Load Start to Finding a Handler<br>  <a href="http://www-archive.mozilla.org/docs/docshell/uri-load-start.html" target="_blank" rel="noopener">http://www-archive.mozilla.org/docs/docshell/uri-load-start.html</a><br>  <a href="https://developer.mozilla.org/en-US/docs/Document_Loading_-_From_Load_Start_to_Finding_a_Handler" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Document_Loading_-_From_Load_Start_to_Finding_a_Handler</a></p><p>nsIContentPolicy<br><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIContentPolicy" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIContentPolicy</a><br>Interface for content policy mechanism. Implementations of this interface can be used to control loading of various types of out-of-line content, or processing of certain types of inline content</p><p>nsILinkHandler<br>  an internal interface used for link clicks</p><p>nsIURIContentListener<br>  this gives embedders a chance to abort the load if this URI type is something they want to handle in the embedding app.<br>  <a href="http://www-archive.mozilla.org/projects/embedding/embedapiref/embedapi67.html#1086464" target="_blank" rel="noopener">http://www-archive.mozilla.org/projects/embedding/embedapiref/embedapi67.html#1086464</a><br>  onStartURIOpen() Gives the original content listener first crack at stopping a load before it happens.<br>  doContent() Notifies the content listener to hook up an nsIStreamListener capable of consuming the data stream.<br>  canHandleContent() Indicates whether the content listener is capable of handling the content. </p><p>NS_CONTENT_LISTENER_CATEGORYMANAGER_ENTRY of category manager</p><p>nsIStreamListener</p><p>nsIExternalHelperAppService<br>  <a href="https://developer.mozilla.org/en-US/docs/Helper_Apps_%28and_a_bit_of_Save_As%29" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Helper_Apps_%28and_a_bit_of_Save_As%29</a></p><p>  nsIHelperAppLauncher</p><p>  nsExternalAppHandler details</p><pre><code>Implements nsIStreamListener.Gets notifications from Necko as the data comes in.Four primary tasks:    Sets up temporary file and instantiate the nsIHelperAppLauncherDialog in OnStartRequest.    Puts the data in the file as OnDataAvailable notifications come in.    Knows how to launch a helper application on the data based on the nsIMIMEInfo.    Knows how to save the data to disk at a given location if the user decides to do so. </code></pre><h2 id="下载download"><a href="#下载download" class="headerlink" title="下载download"></a>下载download</h2><p>nsIDownloader<br>  <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIDownloader" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIDownloader</a></p><p>Downloads.jsm<br>  <a href="https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Downloads.jsm" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Downloads.jsm</a></p><p>nsIDownloadManager<br>  <a href="https://bitbucket.org/geckofx/geckofx-29.0/issue/73/download-completed-event-the-right-way" target="_blank" rel="noopener">https://bitbucket.org/geckofx/geckofx-29.0/issue/73/download-completed-event-the-right-way</a></p><p>Gecko.LauncherDialog.Download<br>  <a href="https://bitbucket.org/geckofx/geckofx-29.0/issue/34/how-to-download-files-using-this-engine" target="_blank" rel="noopener">https://bitbucket.org/geckofx/geckofx-29.0/issue/34/how-to-download-files-using-this-engine</a></p><p>base/mozglue/GeckoLoader.java.in:80:    private static void setupDownloadEnviron<br>ment(Context context)</p><p>base/updater/UpdateService.java:212:        int autoDownloadPolicy = getAutoDown<br>loadPolicy();</p><p>chrome/content/downloads.js:90:  handleClickEvent: function dl_handleClickEvent(<br>aDownload) {</p><h2 id="gecko-事件"><a href="#gecko-事件" class="headerlink" title="gecko 事件"></a>gecko 事件</h2><p><a href="https://developer.mozilla.org/en-US/docs/Observer_Notifications" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Observer_Notifications</a></p><h2 id="特殊协议"><a href="#特殊协议" class="headerlink" title="特殊协议"></a>特殊协议</h2><h3 id="jar-协议"><a href="#jar-协议" class="headerlink" title="jar 协议"></a>jar 协议</h3><p>与 java 的 jar 协议没什么区别。语法是 jar:sub-url!/path-to/file-in-zip<br>注意’!’之后的路径总是以’/‘开头，不管zip中的实际条目名是否以’/‘开头。<br>jar协议的效果与file、http等没有本质的不同。不过，目前播放音视频时有个限制：未播放的部分不能seek，而且也不一定能正确显示总时长。<br>在android版mozilla上，点击jar协议引用的非web文件，例如.doc，也无法调动外部程序来打开（这应该是个bug）。</p><h2 id="新的嵌入-API"><a href="#新的嵌入-API" class="headerlink" title="+ 新的嵌入 API"></a>+ 新的嵌入 API</h2><p><a href="https://wiki.mozilla.org/Embedding/IPCLiteAPI" target="_blank" rel="noopener">https://wiki.mozilla.org/Embedding/IPCLiteAPI</a></p><h2 id="外部进程的创建和管理"><a href="#外部进程的创建和管理" class="headerlink" title="外部进程的创建和管理"></a>外部进程的创建和管理</h2><p>gecko 实现了一套与 node.js child_process 兼容的 API：</p><p><a href="https://developer.mozilla.org/en-US/Add-ons/SDK/Low-Level_APIs/system_child_process" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Add-ons/SDK/Low-Level_APIs/system_child_process</a></p><p>// Import SDK Stuff<br>var COMMONJS_URI = ‘resource://gre/modules/commonjs’;<br>var { require } = Components.utils.import(COMMONJS_URI + ‘/toolkit/require.js’, {});<br>var child_process = require(‘sdk/system/child_process’);</p><p>//var ls = child_process.spawn(‘ls’, [‘.’]);<br>var ls = child_process.spawn(‘D:\software\UnxUtils\usr\local\wbin\ls.exe’, [‘D:\‘], {encoding: ‘GBK’});<br>//var ls = child_process.spawn(‘C:\Windows\System32\ipconfig.exe’, {encoding: null}); // null 得到的是按字节值直接转化的字符串</p><p>//ls.stdout.setEncoding(‘GBK’); //stdout.setEncoding() 目前无效<br>ls.stdout.on(‘data’, function (data) {<br>  console.log(‘stdout(‘ + data.length + ‘): ‘, data);<br>});</p><p>ls.stderr.on(‘data’, function (data) {<br>  console.log(‘stderr: ‘ + data);<br>});</p><p>ls.on(‘close’, function (code) {<br>  console.log(‘child process exited with code ‘ + code);<br>});</p><p>ls.on(‘error’, function (err) {<br>  console.log(‘child process error ‘, err);<br>});</p><p>实现代码的位置在<br>omni.jar!\modules\commonjs\sdk\system/child_process.js<br>omni.jar!\jsloader\resource\gre\modules\commonjs\sdk\system/child_process.js</p><p>stdout.setEncoding() 目前无效。<br>child_process.spawn(cmd, args, {encoding: ‘GBK’}) 在 Firefox 46 上有效，但 52a2 上无效。<br>也不能向 stdin 写入非ASCII字符。<br>参考：<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1180409" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=1180409</a></p><h2 id="JS-Ctypes"><a href="#JS-Ctypes" class="headerlink" title="JS-Ctypes"></a>JS-Ctypes</h2><p>JS 直接调用 C api.<br>js-ctypes allows application and extension code to call back and forth to native code written in C. C++ support is limited, see bug 505907 for full support. Unlike binary XPCOM components, It allows developers to ship a single binary for use with multiple versions of Firefox.</p><p>二进制数据优化-Harmony typed objects (nés binary data)<br>  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=578700" target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=578700</a><br>  <a href="http://wiki.ecmascript.org/doku.php?id=harmony:typed_objects" target="_blank" rel="noopener">http://wiki.ecmascript.org/doku.php?id=harmony:typed_objects</a><br>  <a href="https://github.com/Yoric/js-js-ctypes" target="_blank" rel="noopener">https://github.com/Yoric/js-js-ctypes</a></p><p>ChromeWorker<br>  <a href="https://developer.mozilla.org/en-US/docs/Web/API/ChromeWorker" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/ChromeWorker</a><br>  If you’re developing privileged code, and would like to create a worker that can use js-ctypes to perform calls to native code, you can do so by using ChromeWorker instead of the standard Worker object. </p><h2 id="web-app"><a href="#web-app" class="headerlink" title="web app"></a>web app</h2><p>mozilla web app 是运行于 firefox OS, 桌面 firefox，移动 firefox 的 web app，三者具有大致统一的规范。<br>mozilla web app 是基于 web 标准的，再加上一些希望成为 web 标准的扩展 api。因此与firefox扩展和xulrunner应用不同，不能使用mozilla特有的底层API，包括XPCOM。<br>事实上，mozilla web app 与 chrome web app 在概念上很相似，互相移植也比较容易。</p><h3 id="packaged-app"><a href="#packaged-app" class="headerlink" title="packaged app"></a>packaged app</h3><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>web app 目前似乎只能通过http安装，如果通过file安装会产生invalid url错误。</p><h3 id="desktop-web-app"><a href="#desktop-web-app" class="headerlink" title="desktop web app"></a>desktop web app</h3><p>安装后会产生一个类似普通应用程序的入口，在windows上就是一个exe文件，例如<br>“C:\Users\duanyao\AppData\Roaming\xhrcontenttypetest-facc7b2fa7338eec4c5fd305b78b8e71\xhr content type test.exe”<br>并且也提供了反安装程序。</p><h3 id="android-web-app"><a href="#android-web-app" class="headerlink" title="android web app"></a>android web app</h3><p>出了从 firefox 中安装，也可以将web app打包为 apk，详见“Open Web Apps for Android”。</p><p>mozilla-apk-cli<br>  npm install -g mozilla-apk-cli<br>  mozilla-apk-cli ./www my_test_app.apk<br>  mozilla-apk-cli is only for testing and debugging your new Android app locally.</p><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><p>Writing your first Firefox OS app<br>  <a href="http://www.adobe.com/devnet/html5/articles/writing-your-first-firefox-os-app.html" target="_blank" rel="noopener">http://www.adobe.com/devnet/html5/articles/writing-your-first-firefox-os-app.html</a><br>Getting Started with Firefox OS: Hosted and Packaged Apps<br>  <a href="http://www.sitepoint.com/getting-started-with-firefox-os-hosted-and-packaged-apps/" target="_blank" rel="noopener">http://www.sitepoint.com/getting-started-with-firefox-os-hosted-and-packaged-apps/</a><br>Packaged apps<br>  <a href="https://developer.mozilla.org/en-US/Marketplace/Options/Packaged_apps" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Marketplace/Options/Packaged_apps</a><br>Open Web Apps for Android<br>  <a href="https://developer.mozilla.org/en-US/Marketplace/Options/Open_web_apps_for_android" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Marketplace/Options/Open_web_apps_for_android</a></p><h2 id="firefox-html"><a href="#firefox-html" class="headerlink" title="firefox.html"></a>firefox.html</h2><p>  Firefox.html is an experiment: trying to re-implement the Firefox UI in HTML.<br>  <a href="https://github.com/paulrouget/firefox.html" target="_blank" rel="noopener">https://github.com/paulrouget/firefox.html</a></p><h2 id="GeckoView"><a href="#GeckoView" class="headerlink" title="GeckoView"></a>GeckoView</h2><p><a href="http://ftp.mozilla.org/pub/mozilla.org/mobile/nightly/latest-mozilla-central-android/" target="_blank" rel="noopener">http://ftp.mozilla.org/pub/mozilla.org/mobile/nightly/latest-mozilla-central-android/</a></p><p>未特别指出时包为 org.mozilla.gecko</p><h3 id="GeckoView-1"><a href="#GeckoView-1" class="headerlink" title="GeckoView"></a>GeckoView</h3><p>mobile/android/base/GeckoView.java</p><p>public Browser addBrowser(String url)<br>public void removeBrowser(Browser browser)<br>public void setCurrentBrowser(Browser browser)<br>public Browser getCurrentBrowser()<br>public List<Browser> getBrowsers()<br>public void setChromeDelegate(ChromeDelegate chrome)<br>public void setContentDelegate(ContentDelegate content)<br>public static void setGeckoInterface(final BaseGeckoInterface geckoInterface)<br>public static GeckoAppShell.GeckoInterface getGeckoInterface()</p><p>GeckoView.Browser</p><p>public void loadUrl(String url)<br>public void reload()<br>public void stop()<br>public boolean canGoBack()<br>public void goBack()<br>public boolean canGoForward()<br>public void goForward()</p><h3 id="interface-GeckoView-ContentDelegate"><a href="#interface-GeckoView-ContentDelegate" class="headerlink" title="interface GeckoView.ContentDelegate"></a>interface GeckoView.ContentDelegate</h3><p>默认空实现 GeckoViewContent<br>onPageStart<br>onPageStop<br>onPageShow<br>onReceivedTitle</p><h3 id="interface-GeckoView-ChromeDelegate"><a href="#interface-GeckoView-ChromeDelegate" class="headerlink" title="interface GeckoView.ChromeDelegate"></a>interface GeckoView.ChromeDelegate</h3><p>默认实现 GeckoViewChrome<br>onReady<br>onAlert<br>onPrompt<br>onConfirm<br>onDebugRequest</p><h3 id="GeckoAppShell"><a href="#GeckoAppShell" class="headerlink" title="GeckoAppShell"></a>GeckoAppShell</h3><p>mobile/android/base/GeckoAppShell.java</p><p>//Adds a listener for a gecko event. This method is thread-safe and may be called at any time.<br>public static void registerEventListener(String event, GeckoEventListener listener)<br>public static void unregisterEventListener(String event, GeckoEventListener listener)</p><pre><code>    GeckoAppShell.registerEventListener(&quot;Gecko:Ready&quot;, this);    GeckoAppShell.registerEventListener(&quot;Content:StateChange&quot;, this);    GeckoAppShell.registerEventListener(&quot;Content:LoadError&quot;, this);    GeckoAppShell.registerEventListener(&quot;Content:PageShow&quot;, this);    GeckoAppShell.registerEventListener(&quot;DOMTitleChanged&quot;, this);    GeckoAppShell.registerEventListener(&quot;Link:Favicon&quot;, this);    GeckoAppShell.registerEventListener(&quot;Prompt:Show&quot;, this);    GeckoAppShell.registerEventListener(&quot;Prompt:ShowTop&quot;, this);</code></pre><p>base/Tabs.java:87:        registerEventListener(“Session:RestoreEnd”);<br>base/Tabs.java:88:        registerEventListener(“SessionHistory:New”);<br>base/Tabs.java:89:        registerEventListener(“SessionHistory:Back”);<br>base/Tabs.java:90:        registerEventListener(“SessionHistory:Forward”);<br>base/Tabs.java:91:        registerEventListener(“SessionHistory:Goto”);<br>base/Tabs.java:92:        registerEventListener(“SessionHistory:Purge”);<br>base/Tabs.java:93:        registerEventListener(“Tab:Added”);<br>base/Tabs.java:94:        registerEventListener(“Tab:Close”);<br>base/Tabs.java:95:        registerEventListener(“Tab:Select”);<br>base/Tabs.java:96:        registerEventListener(“Content:LocationChange”);<br>base/Tabs.java:97:        registerEventListener(“Content:SecurityChange”);<br>base/Tabs.java:98:        registerEventListener(“Content:ReaderEnabled”);<br>base/Tabs.java:99:        registerEventListener(“Content:StateChange”);<br>base/Tabs.java:100:        registerEventListener(“Content:LoadError”);<br>base/Tabs.java:101:        registerEventListener(“Content:PageShow”);<br>base/Tabs.java:102:        registerEventListener(“DOMContentLoaded”);<br>base/Tabs.java:103:        registerEventListener(“DOMTitleChanged”);<br>base/Tabs.java:104:        registerEventListener(“Link:Favicon”);<br>base/Tabs.java:105:        registerEventListener(“Link:Feed”);<br>base/Tabs.java:106:        registerEventListener(“Link:OpenSearch”);<br>base/Tabs.java:107:        registerEventListener(“DesktopMode:Changed”);<br>base/Tabs.java:108:        registerEventListener(“Tab:ViewportMetadata”);</p><p>base/GeckoApp.java:1517:        registerEventListener(“log”);<br>base/GeckoApp.java:1518:        registerEventListener(“Reader:ListCountRequest”);<br>base/GeckoApp.java:1519:        registerEventListener(“Reader:ListStatusRequest”);<br>base/GeckoApp.java:1520:        registerEventListener(“Reader:Added”);<br>base/GeckoApp.java:1521:        registerEventListener(“Reader:Removed”);<br>base/GeckoApp.java:1522:        registerEventListener(“Reader:Share”);<br>base/GeckoApp.java:1523:        registerEventListener(“Reader:FaviconRequest”);<br>base/GeckoApp.java:1524:        registerEventListener(“onCameraCapture”);<br>base/GeckoApp.java:1525:        registerEventListener(“Menu:Add”);<br>base/GeckoApp.java:1526:        registerEventListener(“Menu:Remove”);<br>base/GeckoApp.java:1527:        registerEventListener(“Menu:Update”);<br>base/GeckoApp.java:1528:        registerEventListener(“Gecko:Ready”);<br>base/GeckoApp.java:1529:        registerEventListener(“Gecko:DelayedStartup”);<br>base/GeckoApp.java:1530:        registerEventListener(“Toast:Show”);<br>base/GeckoApp.java:1531:        registerEventListener(“DOMFullScreen:Start”);<br>base/GeckoApp.java:1532:        registerEventListener(“DOMFullScreen:Stop”);<br>base/GeckoApp.java:1533:        registerEventListener(“ToggleChrome:Hide”);<br>base/GeckoApp.java:1534:        registerEventListener(“ToggleChrome:Show”);<br>base/GeckoApp.java:1535:        registerEventListener(“ToggleChrome:Focus”);<br>base/GeckoApp.java:1536:        registerEventListener(“Permissions:Data”);<br>base/GeckoApp.java:1537:        registerEventListener(“Session:StatePurged”);<br>base/GeckoApp.java:1538:        registerEventListener(“Bookmark:Insert”);<br>base/GeckoApp.java:1539:        registerEventListener(“Accessibility:Event”);<br>base/GeckoApp.java:1540:        registerEventListener(“Accessibility:Ready”);<br>base/GeckoApp.java:1541:        registerEventListener(“Shortcut:Remove”);<br>base/GeckoApp.java:1542:        registerEventListener(“Share:Text”);<br>base/GeckoApp.java:1543:        registerEventListener(“Share:Image”);<br>base/GeckoApp.java:1544:        registerEventListener(“Image:SetAs”);<br>base/GeckoApp.java:1545:        registerEventListener(“Sanitize:ClearHistory”);<br>base/GeckoApp.java:1546:        registerEventListener(“Update:Check”);<br>base/GeckoApp.java:1547:        registerEventListener(“Update:Download”);<br>base/GeckoApp.java:1548:        registerEventListener(“Update:Install”);<br>base/GeckoApp.java:1549:        registerEventListener(“PrivateBrowsing:Data”);<br>base/GeckoApp.java:1550:        registerEventListener(“Contact:Add”);<br>base/GeckoApp.java:1551:        registerEventListener(“Intent:Open”);<br>base/GeckoApp.java:1552:        registerEventListener(“Intent:GetHandlers”);<br>base/GeckoApp.java:1553:        registerEventListener(“Locale:Set”);<br>base/GeckoApp.java:1554:        registerEventListener(“NativeApp:IsDebuggable”);<br>base/GeckoApp.java:1555:        registerEventListener(“SystemUI:Visibility”);</p><h3 id="click"><a href="#click" class="headerlink" title="click"></a>click</h3><p>chrome/content/browser.js:1709:    Services.obs.addObserver(this, “PageActions:C<br>licked”, false);<br>chrome/content/browser.js:1710:    Services.obs.addObserver(this, “PageActions:L<br>ongClicked”, false);</p><h3 id="components-HelperAppDialog-js"><a href="#components-HelperAppDialog-js" class="headerlink" title="components/HelperAppDialog.js"></a>components/HelperAppDialog.js</h3><h3 id="HelperApps"><a href="#HelperApps" class="headerlink" title="HelperApps"></a>HelperApps</h3><p>mobile/android/chrome/content/HelperApps.js<br><a href="https://hg.mozilla.org/integration/fx-team/rev/dd3dd64aa432" target="_blank" rel="noopener">https://hg.mozilla.org/integration/fx-team/rev/dd3dd64aa432</a><br>  getAppsForUri</p><h3 id="PrefsHelper"><a href="#PrefsHelper" class="headerlink" title="PrefsHelper"></a>PrefsHelper</h3><h2 id="内存管理-GC-CC"><a href="#内存管理-GC-CC" class="headerlink" title="内存管理/GC/CC"></a>内存管理/GC/CC</h2><p><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Language_Bindings/Components.utils.forceGC" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Language_Bindings/Components.utils.forceGC</a><br><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Language_Bindings/Components.utils.schedulePreciseGC" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Language_Bindings/Components.utils.schedulePreciseGC</a><br><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Interfacing_with_the_XPCOM_cycle_collector" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Interfacing_with_the_XPCOM_cycle_collector</a></p><p>触发 CC:<br>var domWindowUtils = window.QueryInterface(Components.interfaces.nsIInterfaceRequestor)<br>                     .getInterface(Components.interfaces.nsIDOMWindowUtils);<br>domWindowUtils.cycleCollect()</p><p>触发 JS GC:<br>异步：<br>Components.utils.schedulePreciseGC(function(){})<br>同步：<br>Components.utils.forceGC()</p>]]></content>
      
      
      
        <tags>
            
            <tag> XUL </tag>
            
            <tag> XULRunner </tag>
            
            <tag> Firefox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack-note</title>
      <link href="2017/01/10/webpack-note/"/>
      <url>2017/01/10/webpack-note/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-webpack？"><a href="#什么是-webpack？" class="headerlink" title="什么是 webpack？"></a>什么是 webpack？</h1><p>webpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。<br>我们可以直接使用 require(XXX) 的形式来引入各模块，即使它们可能需要经过编译（比如JSX和sass），但我们无须在上面花费太多心思，因为 webpack 有着各种健全的加载器（loader）在默默处理这些事情，这块我们后续会提到。<br>你可以不打算将其用在你的项目上，但没有理由不去掌握它，因为以近期 Github 上各大主流的（React相关）项目来说，它们仓库上所展示的示例已经是基于 webpack 来开发的，比如 React-Boostrap 和 Redux。<br>webpack的官网是 <a href="http://webpack.github.io/" target="_blank" rel="noopener">http://webpack.github.io/</a> ，文档地址是 <a href="http://webpack.github.io/docs/" target="_blank" rel="noopener">http://webpack.github.io/docs/</a> ，想对其进行更详细了解的可以点进去瞧一瞧。</p><h1 id="webpack-的优势"><a href="#webpack-的优势" class="headerlink" title="webpack 的优势"></a>webpack 的优势</h1><p>其优势主要可以归类为如下几个：</p><ol><li>webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。</li><li>能被模块化的不仅仅是 JS 了。</li><li>开发便捷，能替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等。</li><li>扩展性强，插件机制完善，特别是支持 React 热插拔（见 react-hot-loader ）的功能让人眼前一亮。<br>我们谈谈第一点。以 AMD/CMD 模式来说，鉴于模块是异步加载的，所以我们常规需要使用 define 函数来帮我们搞回调：</li></ol><pre><code class="javascript">define([&#39;package/lib&#39;], function(lib){    function foo(){        lib.log(&#39;hello world!&#39;);    }     return {        foo: foo    };});</code></pre><p>另外为了可以兼容 commonJS 的写法，我们也可以将 define 这么写：</p><pre><code class="javascript">define(function (require, exports, module){    var someModule = require(&quot;someModule&quot;);    var anotherModule = require(&quot;anotherModule&quot;);        someModule.doTehAwesome();    anotherModule.doMoarAwesome();    exports.asplode = function (){        someModule.doTehAwesome();        anotherModule.doMoarAwesome();    };});</code></pre><p>然而对 webpack 来说，我们可以直接在上面书写 commonJS 形式的语法，无须任何 define （毕竟最终模块都打包在一起，webpack 也会最终自动加上自己的加载器）：</p><pre><code>var someModule = require(&quot;someModule&quot;);    var anotherModule = require(&quot;anotherModule&quot;);        someModule.doTehAwesome();    anotherModule.doMoarAwesome();    exports.asplode = function (){        someModule.doTehAwesome();        anotherModule.doMoarAwesome(); };</code></pre><p>这样撸码自然更简单，跟回调神马的说 byebye~<br>不过即使你保留了之前 define 的写法也是可以滴，毕竟 webpack 的兼容性相当出色，方便你旧项目的模块直接迁移过来。</p><h1 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h1><p>一. 安装<br>我们常规直接使用 npm 的形式来安装：</p><pre><code class="ruby">$ npm install webpack -g</code></pre><p>当然如果常规项目还是把依赖写入 package.json 包去更人性化：</p><pre><code class="ruby">$ npm init$ npm install webpack --save-dev</code></pre><p>二. 配置<br>每个项目下都必须配置有一个 webpack.config.js ，它的作用如同常规的 gulpfile.js/Gruntfile.js ，就是一个配置项，告诉 webpack 它需要做什么。<br>我们看看下方的示例：</p><pre><code class="javascript">var webpack = require(&#39;webpack&#39;);var commonsPlugin = new webpack.optimize.CommonsChunkPlugin(&#39;common.js&#39;);module.exports = {    //插件项    plugins: [commonsPlugin],    //页面入口文件配置    entry: {        index : &#39;./src/js/page/index.js&#39;    },    //入口文件输出配置    output: {        path: &#39;dist/js/page&#39;,        filename: &#39;[name].js&#39;    },    module: {        //加载器配置        loaders: [            { test: /\.css$/, loader: &#39;style-loader!css-loader&#39; },            { test: /\.js$/, loader: &#39;jsx-loader?harmony&#39; },            { test: /\.scss$/, loader: &#39;style!css!sass?sourceMap&#39;},            { test: /\.(png|jpg)$/, loader: &#39;url-loader?limit=8192&#39;}        ]    },    //其它解决方案配置    resolve: {        root: &#39;E:/github/flux-example/src&#39;, //绝对路径        extensions: [&#39;&#39;, &#39;.js&#39;, &#39;.json&#39;, &#39;.scss&#39;],        alias: {            AppStore : &#39;js/stores/AppStores.js&#39;,            ActionType : &#39;js/actions/ActionType.js&#39;,            AppAction : &#39;js/actions/AppAction.js&#39;        }    }};</code></pre><p>⑴ plugins 是插件项，这里我们使用了一个 CommonsChunkPlugin 的插件，它用于提取多个入口文件的公共脚本部分，然后生成一个 common.js 来方便多页面之间进行复用。<br>⑵ entry 是页面入口文件配置，output 是对应输出项配置（即入口文件最终要生成什么名字的文件、存放到哪里），其语法大致为：</p><pre><code class="javascript">{    entry: {        page1: &quot;./page1&quot;,        //支持数组形式，将加载数组中的所有模块，但以最后一个模块作为输出        page2: [&quot;./entry1&quot;, &quot;./entry2&quot;]    },    output: {        path: &quot;dist/js/page&quot;,        filename: &quot;[name].bundle.js&quot;    }}</code></pre><p>该段代码最终会生成一个 page1.bundle.js 和 page2.bundle.js，并存放到 ./dist/js/page 文件夹下。<br>⑶ module.loaders 是最关键的一块配置。它告知 webpack 每一种文件都需要使用什么加载器来处理：</p><pre><code class="javascript">module: {        //加载器配置        loaders: [            //.css 文件使用 style-loader 和 css-loader 来处理            { test: /\.css$/, loader: &#39;style-loader!css-loader&#39; },            //.js 文件使用 jsx-loader 来编译处理            { test: /\.js$/, loader: &#39;jsx-loader?harmony&#39; },            //.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理            { test: /\.scss$/, loader: &#39;style!css!sass?sourceMap&#39;},            //图片文件使用 url-loader 来处理，小于8kb的直接转为base64            { test: /\.(png|jpg)$/, loader: &#39;url-loader?limit=8192&#39;}        ]    }</code></pre><p>如上，”-loader”其实是可以省略不写的，多个loader之间用“!”连接起来。<br>注意所有的加载器都需要通过 npm 来加载，并建议查阅它们对应的 readme 来看看如何使用。<br>拿最后一个 url-loader 来说，它会将样式中引用到的图片转为模块来处理，使用该加载器需要先进行安装：<br>npm install url-loader -save-dev<br>配置信息的参数“?limit=8192”表示将所有小于8kb的图片都转为base64形式（其实应该说超过8kb的才使用 url-loader 来映射到文件，否则转为data url形式）。<br>⑷ 最后是 resolve 配置，这块很好理解，直接写注释了：</p><pre><code class="javascript">resolve: {        //查找module的话从这里开始查找        root: &#39;E:/github/flux-example/src&#39;, //绝对路径        //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名        extensions: [&#39;&#39;, &#39;.js&#39;, &#39;.json&#39;, &#39;.scss&#39;],        //模块别名定义，方便后续直接引用别名，无须多写长长的地址        alias: {            AppStore : &#39;js/stores/AppStores.js&#39;,//后续直接 require(&#39;AppStore&#39;) 即可            ActionType : &#39;js/actions/ActionType.js&#39;,            AppAction : &#39;js/actions/AppAction.js&#39;        }    }</code></pre><p>关于 webpack.config.js 更详尽的配置可以参考这里。<br>运行 webpack<br>webpack 的执行也很简单，直接执行<br>$ webpack –display-error-details<br>即可，后面的参数“–display-error-details”是推荐加上的，方便出错时能查阅更详尽的信息（比如 webpack 寻找模块的过程），从而更好定位到问题。<br>其他主要的参数有：</p><pre><code class="ruby">$ webpack --config XXX.js   //使用另一份配置文件（比如webpack.config2.js）来打包$ webpack --watch   //监听变动并自动打包$ webpack -p    //压缩混淆脚本，这个非常非常重要！$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了</code></pre><p>其中的 -p 是很重要的参数，曾经一个未压缩的 700kb 的文件，压缩后直接降到 180kb（主要是样式这块一句就独占一行脚本，导致未压缩脚本变得很大）。<br>模块引入<br>上面唠嗑了那么多配置和执行方法，下面开始说说寻常页面和脚本怎么使用呗。<br>一. HTML<br>直接在页面引入 webpack 最终生成的页面脚本即可，不用再写什么 data-main 或 seajs.use 了：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;script src=&quot;dist/js/page/common.js&quot;&gt;&lt;/script&gt;  &lt;script src=&quot;dist/js/page/index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>可以看到我们连样式都不用引入，毕竟脚本执行时会动态生成<strong>&lt;style&gt;</strong>并标签打到head里。</p><p>二. JS<br>各脚本模块可以直接使用 commonJS 来书写，并可以直接引入未经编译的模块，比如 JSX、sass、coffee等（只要你在 webpack.config.js 里配置好了对应的加载器）。<br>我们再看看编译前的页面入口文件（index.js）：</p><pre><code class="javascript">require(&#39;../../css/reset.scss&#39;); //加载初始化样式require(&#39;../../css/allComponent.scss&#39;); //加载组件样式var React = require(&#39;react&#39;);var AppWrap = require(&#39;../component/AppWrap&#39;); //加载组件var createRedux = require(&#39;redux&#39;).createRedux;var Provider = require(&#39;redux/react&#39;).Provider;var stores = require(&#39;AppStore&#39;);var redux = createRedux(stores);var App = React.createClass({    render: function() {        return (            &lt;Provider redux={redux}&gt;                {function() { return &lt;AppWrap /&gt;; }}            &lt;/Provider&gt;        );    }});React.render(    &lt;App /&gt;, document.body);</code></pre><p>一切就是这么简单么么哒~ 后续各种有的没的，webpack 都会帮你进行处理。<br>其他<br>至此我们已经基本上手了 webpack 的使用，下面是补充一些有用的技巧。<br>一. shimming<br>在 AMD/CMD 中，我们需要对不符合规范的模块（比如一些直接返回全局变量的插件）进行 shim 处理，这时候我们需要使用 exports-loader 来帮忙：<br>{ test: require.resolve(“./src/js/tool/swipe.js”),  loader: “exports?swipe”}<br>之后在脚本中需要引用该模块的时候，这么简单地来使用就可以了：<br>require(‘./tool/swipe.js’);<br>swipe();<br>二. 自定义公共模块提取<br>在文章开始我们使用了 CommonsChunkPlugin 插件来提取多个页面之间的公共模块，并将该模块打包为 common.js 。<br>但有时候我们希望能更加个性化一些，我们可以这样配置：</p><pre><code class="javascript">var CommonsChunkPlugin = require(&quot;webpack/lib/optimize/CommonsChunkPlugin&quot;);module.exports = {    entry: {        p1: &quot;./page1&quot;,        p2: &quot;./page2&quot;,        p3: &quot;./page3&quot;,        ap1: &quot;./admin/page1&quot;,        ap2: &quot;./admin/page2&quot;    },    output: {        filename: &quot;[name].js&quot;    },    plugins: [        new CommonsChunkPlugin(&quot;admin-commons.js&quot;, [&quot;ap1&quot;, &quot;ap2&quot;]),        new CommonsChunkPlugin(&quot;commons.js&quot;, [&quot;p1&quot;, &quot;p2&quot;, &quot;admin-commons.js&quot;])    ]};// &lt;script&gt;s required:// page1.html: commons.js, p1.js// page2.html: commons.js, p2.js// page3.html: p3.js// admin-page1.html: commons.js, admin-commons.js, ap1.js// admin-page2.html: commons.js, admin-commons.js, ap2.js</code></pre><p>三. 独立打包样式文件<br>有时候可能希望项目的样式能不要被打包到脚本中，而是独立出来作为.css，然后在页面中以<strong>&lt;link&gt;</strong>标签引入。这时候我们需要 extract-text-webpack-plugin 来帮忙：</p><pre><code class="javascript">var webpack = require(&#39;webpack&#39;);    var commonsPlugin = new webpack.optimize.CommonsChunkPlugin(&#39;common.js&#39;);    var ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);    module.exports = {        plugins: [commonsPlugin, new ExtractTextPlugin(&quot;[name].css&quot;)],        entry: {        //...省略其它配置</code></pre><p>最终 webpack 执行后会乖乖地把样式文件提取出来：</p><p>四. 使用CDN/远程文件<br>有时候我们希望某些模块走CDN并以&lt;script&gt;的形式挂载到页面上来加载，但又希望能在 webpack 的模块中使用上。<br>这时候我们可以在配置文件里使用 externals 属性来帮忙：</p><pre><code class="javascript">{    externals: {        // require(&quot;jquery&quot;) 是引用自外部模块的        // 对应全局变量 jQuery        &quot;jquery&quot;: &quot;jQuery&quot;    }}</code></pre><p>需要留意的是，得确保 CDN 文件必须在 webpack 打包文件引入之前先引入。<br>我们倒也可以使用 script.js 在脚本中来加载我们的模块：</p><pre><code>var $script = require(&quot;scriptjs&quot;);$script(&quot;//ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js&quot;, function() {  $(&#39;body&#39;).html(&#39;It works!&#39;)});</code></pre><p>五. 与 grunt/gulp 配合<br>以 gulp 为示例，我们可以这样混搭：</p><pre><code class="javascript">gulp.task(&quot;webpack&quot;, function(callback) {    // run webpack    webpack({        // configuration    }, function(err, stats) {        if(err) throw new gutil.PluginError(&quot;webpack&quot;, err);        gutil.log(&quot;[webpack]&quot;, stats.toString({            // output options        }));        callback();    });});</code></pre><p>当然我们只需要把配置写到 webpack({ … }) 中去即可，无须再写 webpack.config.js 了。<br>更多参照信息请参阅：<a href="http://webpack.github.io/docs/usage-with-grunt.html" target="_blank" rel="noopener">grunt配置</a> / <a href="http://webpack.github.io/docs/usage-with-gulp.html" target="_blank" rel="noopener">gulp配置</a> 。<br>六. React 相关<br>⑴ 推荐使用 npm install react 的形式来安装并引用 React 模块，而不是直接使用编译后的 react.js，这样最终编译出来的 React 部分的脚本会减少 10-20 kb左右的大小。<br>⑵ <a href="https://github.com/gaearon/react-hot-loader" target="_blank" rel="noopener">react-hot-loader</a> 是一款非常好用的 React 热插拔的加载插件，通过它可以实现修改-运行同步的效果，配合 <a href="http://webpack.github.io/docs/webpack-dev-server.html" target="_blank" rel="noopener">webpack-dev-server</a> 使用更佳！<br>基于 webpack 的入门指引就到这里，希望本文能对你有所帮助，你也可以参考下述的文章来入门：<br><a href="http://www.w2bc.com/article/101955" target="_blank" rel="noopener">webpack入门指谜</a><br><a href="https://github.com/petehunt/webpack-howto" target="_blank" rel="noopener">webpack-howto</a><br>共勉~<br>原文：<br><a href="http://www.w2bc.com/Article/50764" target="_blank" rel="noopener">http://www.w2bc.com/Article/50764</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>electron-note</title>
      <link href="2016/11/30/electron-note/"/>
      <url>2016/11/30/electron-note/</url>
      
        <content type="html"><![CDATA[<h1 id="electron框架笔记"><a href="#electron框架笔记" class="headerlink" title="electron框架笔记"></a>electron框架笔记</h1><ol><li><p>Electron支持的平台</p><ul><li>OS X</li><li>Windows</li><li>Linux</li></ul></li><li><p>标准的electron app包含的结构<br>window 或是 linux 中<br>electron/resource/app<br>|_package.json<br>|_main.js<br>|_index.html</p></li><li><p>electron 程序打包<br>一般使用asar进行打包，electron中包含两种API<br>Node.js和Chromium提供的Web API</p></li><li><p>使用Native Node模块</p><ul><li>electron-rebuild</li><li>使用npm</li><li>使用node-gyp</li></ul></li><li><p>测试主进程<br>window下面的DevTools只能测试渲染进程，为了测试朱经常也可以使用–debug或–debug-brk分支，node-inspector也可以使用</p></li><li><p>electron 简述<br>electron可以让你使用javascript来创建桌面应用，可以将其理解为Node.js的一个变体，它提供了丰富的运行时访问Native的API接口。<br>但是electron并不是一个GUI库，相反的，electron使用web页面作为它的GUI，所以可以将它看做是一个小的Chromium浏览器。<br>在Electron中运行package.json和main脚本的进程成为主进程，可以在主进程中通过创建Web页面来显示GUI。<br>electron使用Chromium的多进程机制来渲染页面，每个页面拥有一个自己的进程，该进程成为渲染进程。<br>在electron中用户可以通过Node.js的API跨过网页运行的沙箱去访问更为底层的系统应用。<br>主进程通过使用BrowserWindow实例创建页面，每个BrowserWindow都是在自己的渲染进程中运行。<br>当一个BrowserWindow实例被销毁的时候对应的渲染进程也被销毁了。<br>主进程管理着所有的网页和它们对应的渲染进程，每个渲染进程只关心自己的网页。<br>渲染进程若是想访问GUI操作，需要向主进程发出请求。<br>在electron中主进程和渲染进程之间有几种交互方式：ipcRenderer和ipcMain来发送messages。</p></li><li><p>一个简单完整的electron app<br>package.json文件的格式和Node的模块是一样的，main.js是app启动脚本，将会运行在主进程中。<br>如果main没有出现在package.json中，electron将会尝试装载index.js<br>main.js需要创建window界面并处理系统事件运行electron程序：<br>可以先用npm装上electron-prebuilt，进入app的root目录。<br>执行 <strong>electron .</strong>。</p></li><li><p>桌面环境的整合<br>关于Notification通知：<br>HTML5的API只能是在渲染进程中使用，Windows，Linux和OS X中都支持通知机制。<br>其他的功能看具体的桌面环境进行相应的配置</p></li><li><p>在线和离线事件监测<br>electron主进程中并不能利用HTML5中的navigator对象进行事件探测，但是可以利用electron中的交互工具将事件监测结果反馈给主进程。<br>使用ipcMain和ipcRender进行事件信息的传递</p></li><li><p>electron中API概要<br>electron支持所有的Node.js的内建模块，也支持第三方的node模块，包括native模块。<br>electron同时提供了额外的native内建模块可以用于开发原生的桌面应用。<br>一些模块只能在主进程中使用，一些模块只能是在渲染进程中使用，而有一些是通用的模块。<br>规则为：如果模块是GUI或是和底层系统相关的就是只能在主进程中使用。<br>主进程就是main.js而渲染进程是在index.html中运行。     </p></li><li><p>进程对象<br>进程process对象和一般的node区别在于：<br>process.type 进程的类型可以是browser或是renderer<br>process.version[‘electron’] electron的版本<br>process.version[‘chome’] Chromium的版本<br>process.resourcesPath Javascript脚本文件的路径<br>process.mas 构建Mac应用商店时值为true，其他的为undefined。</p></li><li><p>事件<br>当electron装载内部初始化脚本的时候，页面和主脚本文件就开始装载<br>此时会触发事件。</p></li><li><p>electron支持的Chromium命令行开关<br>–client-certificate=path<br>–ignore-connections-limit=domains<br>–disable-http-cache<br>–remote-debugging-port=port<br>–js-flags=flags<br>–proxy-server=address:port<br>–proxy-bypass-list=hosts<br>–proxy-pac-url=url<br>–no-proxy-server<br>–host-rules=rules<br>–host-resolver-rules=runles<br>…</p></li><li><p>环境变量<br>export ELECTRON_ENABLE_LOGGING=true<br>ELECTRON_RUN_AS_NODE<br>ELECTRON_ENABLE_LOGGING</p></li><li><p>定址DOM元素<br>File对象：<br>DOM的File接口通过HTML5的API提供了用户操作native文件的方法。<br>electron增加了path属性接口可以直接访问文件的真实路径<br>标签：<br>webview标签在electron app中植入额外的内容，和iframe不同的是webview运行在一个独立的进程中，它并不具有和你的页面相同的权限，所有app和它的交互都是异步进行的，这使得app在使用植入内容的时候更加安全。<br>window.open函数：<br>当调用window.open的时候会在页面中新创建一个窗口，默认情况下创建的BrowserWindow将会继承父类窗口的options。</p></li><li><p>主进程的模块<br>1)app模块：<br>负责控制应用程序的生命周期如<br>const app = require(‘electron’).app;<br>app.on(‘window-all-closed’, function(){<br>app.quit();<br>});<br>app对象可以发出以下事件：<br>will-finish-launching<br>当程序完成基本的启动，类似于ready事件。启动crash事件监听或是自动更新。大多数情况下，需要在ready事件中处理更多的事情。<br>ready<br>electron完成初始化<br>window-all-closed<br>当所有的窗口都已经关闭的时候触发，只有在当程序将要推退出的时候触发。当用户调用app.quit()的时候，electron会关闭所有的窗口并<br>发出will-quit事件，此时便不会发出window-all-clised事件。<br>before-quit<br>当程序开始关闭窗口的时候发出,调用event.prevertDefault()将会阻止默认的行为。<br>will-quit<br>当窗口都已经关闭，程序即将退出的时候发出该事件。<br>quit<br>程序退出<br>…<br>2)autoUpdater模块<br>该模块提供了Squirrel自动更新框架一个接口<br>3)BrowserWindow模块<br>可以用于创建一个新的浏览器窗口<br>4)contentTracing模块<br>用来收集Chromium内容模块产生的跟踪信息。<br>5)dialog模块<br>用来显示原生系统对话框，比如打开文件对话框<br>6)globalShortcut模块<br>用来注册和注销全局的键盘快捷方式。<br>7)ipcMain模块<br>该模块是EventEmitter的一个实例对象，在主进程中使用，可以发送同步或是异步的message和渲染进程 进行交互。<br>8)Menu模块<br>用来创建一个原生的菜单，比如上下文菜单。<br>9)MenuItem模块<br>用来往菜单中添加菜单子项。<br>10)powerMonitor模块<br>用来显示电池电量变化，只能是在主进程中使用，而且只能是在ready事件已经发出的情况下。<br>11)powerSaveBlocker模块<br>用来阻止系统进入省电模式，休眠模式。<br>12)protocol模块<br>用来注册一个定制的协议或是声明使用一个已经存在的协议<br>13)session模块<br>用来创建新的Session对象，保存本地对象等操作。<br>14)webContents模块<br>这是一个EventEmitter，负责渲染和控制一个网页，是一个BrowserWindow的属性。<br>15)Tray模块<br>一个Tray代表着一个操作系统通知区域的一个icon，通常情况下是和一个上下文菜单绑定的。</p></li><li><p>渲染进程的模块<br>1)desktopCapturer模块<br>用来获取可用的资源，可以用getUserMedia来获取。<br>2)ipcRenderer对象<br>是一个EventEmitter对象的实例，提供了一些方法可以用来和主进程之间进行message交互。<br>3)remote模块<br>提供了一个简单的跨进程之间通信的方法。GUI相关的模块只能是在主进程中使用像是dialog和menu等，如果想要在渲染进程中使用就需要使用ipc机制向主进程申请。remote模块有点像是java中的RMI<br>4)webFrame模块<br>用来定制当前网页的渲染。</p></li><li><p>两个进程共同的模块<br>1)clipboard模块<br>提供了执行复制和粘贴操作的方法。<br>2)crashReporter模块<br>发送程序的奔溃报告。<br>3)nativeImage模块<br>在electron中获取图片可以通过文件的路径或是使用nativeImage对象。<br>4)screen模块<br>这是一个EventEmitter，保存了关于屏幕的所有相关信息，像是大小，显示，指针位置等等。直到ready事件触发之后才能使用。<br>5)shell模块<br>同了和桌面整合相关的函数。</p></li><li><p>开发electron相关知识<br>1)代码格式<br>可以通过运行npm run lint来显示利用cpplint或是eslint获取到的代码风格。<br>javascript中：<br>文件不要使用空行结尾<br>文件必须包含-而不是下划线_<br>const和let的使用<br>function中=&gt;返回值的声明<br>字符串的模板使用，不在使用+，注意$的使用<br>API的名称中更倾向于使用setter和getter而不是JQuery中<br>的直接.text之类的用法。<br>2)源码目录结构<br>Electron<br>├── atom - C++ 源码.<br>| ├── app - 系统程序入口.<br>| ├── browser - 包含了主窗口，UI和所有主进程相关的东西<br>| |<br>| | ├── ui - 为不同的平台实现不用的UI界面.<br>| | | ├── cocoa - Cocoa指定源码.<br>| | | ├── gtk - GTK+ 指定源码.<br>| | | └── win - Windows GUI指定源码.<br>| | ├── api - 主进程API的实现.<br>| | ├── net - 网络相关代码.<br>| | ├── mac - Mac指定Objective-C源代码.<br>| | └── resources - icon，平台相关的文件等等.<br>| ├── renderer - 运行在渲染进程的代码.<br>| | └── api - 渲染进程中API的实现代码.<br>| └── common - 主进程和渲染进程共同使用的代码,包括一些函数工具，以及整合node的信息到Chromium的message loop中。<br>| └── api - 通用的API实现，以及electron内建模块的实现<br>|<br>├── chromium_src - 从Chromium中拷贝的源代码.<br>├── default_app - electron默认显示的页面<br>|<br>├── docs - 文档文件.<br>├── lib - JavaScript的源代码.<br>| ├── browser - Javascript主进程初始化代码.<br>| | └── api - Javascript API实现代码.<br>| ├── common - JavaScript通用的代码<br>| | └── api - Javascript通用API实现代码.<br>| └── renderer - Javascript渲染进程初始化代码.<br>| └── api - Javascript渲染进程API实现代码.<br>├── spec - 自动化测试.<br>├── atom.gyp - electron的构建规则.<br>└── common.gypi - 其他的设置和像是node组件或是breakpad组件的构建规则.</p><p>其他的文件夹：<br>script - 构建，打包，测试相关的脚本文件<br>tools - gyp文件的帮助脚本，不能被用户直接调用的.<br>vendor - 第三方依赖库源码.<br>node_modules - 构建的时候需要使用的第三方node模块.<br>out - ninja输出的临时文件目录.<br>dist - 在创建distribution的时候生成的临时目录.<br>external_binaries - 下载的第三方不支持gyp的二进制框架.</p></li><li><p>构建系统<br>1)electron利用gyp来生成项目，利用ninja来构建项目。项目的配置信息是在.gyp或是.gypi文件中。<br>gyp文件包含electron项目的构建规则：<br>atom.gyp定义了electron本身如何构建<br>common.gyp调整Node的构建配置以适应Chromium<br>vendor/brightray/brightray.gyp定义了brightray如何创建包含了链接Chromium的默认配置<br>vendor/brightray/brightray.gypi包含了通用的构建配置<br>2)组件的构建<br>由于Chromium是一个大工程，链接的时候需要很长的事件，所以Chromium引进了组件构建：将每个组件作为一个独立的共享库，使得链接的时候文件大小和执行速度得到提升。<br>在electron中如果是Debug构建的话，二进制文件会链接到Chromium的共享库版本以提升链接速度。如果是Release构建的话，二进制文件会链接到静态共享库中以获得最佳文件大小和执行效率。<br>3)项目的两个阶段生成方式<br>Release和Debug构建，可以链接不同的库。electron使用的是R和D作为对应的标示。<br><a href="http://www.2cto.com/kf/201604/499352.html" target="_blank" rel="noopener">‘electron笔记原地址’</a>    </p></li></ol><h1 id="调试electron"><a href="#调试electron" class="headerlink" title="调试electron"></a>调试electron</h1><p>原文<br><a href="http://floatincode.net/post/debugging-electron-application-with-visual-studio-code" target="_blank" rel="noopener">http://floatincode.net/post/debugging-electron-application-with-visual-studio-code</a></p><p>首先需要配置visual studio code的launch.json文件</p><p>如原文所示需要配置一个Attach对象</p><pre><code>{  &quot;version&quot;: &quot;0.2.0&quot;,  &quot;configurations&quot;: [    {      &quot;name&quot;: &quot;启动扩展&quot;,      &quot;type&quot;: &quot;extensionHost&quot;,      &quot;request&quot;: &quot;launch&quot;,      &quot;runtimeExecutable&quot;: &quot;${execPath}&quot;,      &quot;args&quot;: [        &quot;--extensionDevelopmentPath=${workspaceRoot}&quot;      ],      &quot;sourceMaps&quot;: true,      &quot;outFiles&quot;: [        &quot;${workspaceRoot}/out/**/*.js&quot;      ],      &quot;preLaunchTask&quot;: &quot;npm&quot;    },    // 下面是重点    {      &quot;name&quot;: &quot;Attach&quot;,      &quot;type&quot;: &quot;node&quot;,      &quot;request&quot;: &quot;attach&quot;,      &quot;port&quot;: 56654,      &quot;sourceMaps&quot;: false,      &quot;outDir&quot;: null,      &quot;localRoot&quot;: &quot;${workspaceRoot}&quot;,      &quot;remoteRoot&quot;: null,      &quot;address&quot;: &quot;localhost&quot;    }  ]}</code></pre><p>然后在运行electron path/to/app –debug=port</p><p>本项目根为hulianketang,在此目录下输入cmd命令<br>electron ./src –debug=56654</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>how-to-debug-gruntfile-task</title>
      <link href="2016/11/18/how-to-debug-gruntfile-task/"/>
      <url>2016/11/18/how-to-debug-gruntfile-task/</url>
      
        <content type="html"><![CDATA[<h1 id="Node-Debug"><a href="#Node-Debug" class="headerlink" title="Node Debug"></a>Node Debug</h1><p>关于node的调试有多种方式<br>第一种：node 内建调试<br>如执行命令</p><pre><code>node debug *.js</code></pre><p>*(星号)表示文件路径/文件名</p><p>help commands：<br>Commands:<br>    run (r),<br>    cont (c),    继续执行<br>    next (n),    n - step next<br>    step (s),    s - step in<br>    out (o),     o - step out<br>    backtrace (bt) ,  显示当前执行框架的回溯<br>    setBreakpoint (sb),<br>      setBreakpoint() or sb() 在当前行设置断点<br>      setBreakpoint(1) or sb(1) 在指定行设置断点<br>      setBreakpoint(‘fn()’) or sb(…) 在函数第一句设置断点<br>      setBreakpoint (‘script.js’,1) or sb(..)  在 script.js 的第一行设置断点<br>    clearBreakpoint (cb),   清除断点<br>    watch,              watch(“my_expressin”) 开始监视一个表达式<br>    unwatch,            watch(“my_expressin”) 移除一个监视器<br>    watchers,           显示活动监视器<br>    repl,               在所调试的脚本的上下文中打开调试器的 repl 执行代码<br>    restart,            重新运行脚本<br>    kill,               终止脚本<br>    list,               list(5) 显示脚本源代码的5行上下文 前五后五<br>    scripts,            列出所有已加载的脚本<br>    breakOnException,<br>    breakpoints,<br>    version，           显示v8版本<br>    pause,              暂停执行代码（类似开发者工具中的暂停按钮）<br>    高级使用<br>    V8 调试器可以从两种方式启用和访问：以 –debug 命令行标志启动 Node；或者向已存在的 Node 进程发送 SIGUSR1 信号<br>    一旦一个进程进入了调试模式，它便可被 Node 调试器连接。调试器可以通过 pid 或 URI 来连接，语法是<br>    node debug -p <pid> - 通过 pid 连接进程<br>    node debug <URI> - 通过类似 localhost:5858 的 URI 连接进程</p><p>第二种：各大工具类<br>如eclipse，visualstudio都有辅助工具插件类。相关的资料请自行网上查找</p><p>第三种：基于chrome的调试器<br>强烈推荐<br>需要安装 <strong>node-inspector</strong></p><pre><code>npm install -g node-inspector</code></pre><p>node-inspector是通过websocket方式来转向debug输入输出的。<br>因此，我们在调试前要先启动node-inspector来监听Nodejs的debug调试端口<br>默认情况下node-inspector的端口是8080，可以通过参数<strong>–web-port=[port]</strong>来设置端口。<br>在启动<strong>node-inpspector</strong>之后，我们可以通过<strong>–debug</strong>或<strong>–debug-brk</strong>来启动nodejs程序。<br>通过在浏览器输入http://[ip address]:8080/debug?port=5858<br>步骤：</p><ol><li>-&gt; 打开目录 输入cmd 进入控制台dos<br> 输入<pre><code> node --debug-brk=56666 example.js</code></pre> 表示监听 通过56666端口监听 example.js<br>2 -&gt; 同1操作一样<br> 命令换成<pre><code> node-inspector //默认情况为5858端口</code></pre> 采用新的端口监听 对应56666端口<br> 用这个命令<pre><code> node-inspector -web-port 56666</code></pre><h1 id="Gruntfile-Debug"><a href="#Gruntfile-Debug" class="headerlink" title="Gruntfile Debug"></a>Gruntfile Debug</h1></li></ol><p>在gruntfile.js所在目录打开一个控制台窗口</p><pre><code>node-inspector</code></pre><p>再打开一个控制台窗口</p><pre><code>node-debug grunt ftp:JHZT</code></pre><p>ftp:JHZT是grunt 的一个<strong>task</strong>任务</p><p>在chrome输入<br><a href="http://127.0.0.1:8080/?port=5858" target="_blank" rel="noopener">http://127.0.0.1:8080/?port=5858</a> 会进入调试模式<br>需要注意的：为了便于调试，最好在Gruntfile.js文件中需要调试地方加入 <strong>debugger;</strong> 关键字</p>]]></content>
      
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> grunt </tag>
            
            <tag> gruntfile </tag>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>how-to-use-counter</title>
      <link href="2016/11/14/how-to-use-counter/"/>
      <url>2016/11/14/how-to-use-counter/</url>
      
        <content type="html"><![CDATA[<h1 id="css计数器的三角关系"><a href="#css计数器的三角关系" class="headerlink" title="css计数器的三角关系"></a>css计数器的三角关系</h1><p>计数器 &lt;-&gt; 伪元素 &lt;-&gt; content属性<br>计数器的2个属性和1个方法</p><ol><li>counter-reset</li><li>counter-increment</li><li>counter()/counters()</li></ol><ul><li><p>counter-reset是计数器重置，计数器命名，设置默认值<br>如:</p><ul><li>.xxx{ counter-reset:counter-test; }<br>计数器名称是’counter-test’,默认值为0</li><li>.xxx{ counter-reset:counter-test 2;}<br>计数器名称是’counter-test’,设置默认值为2</li></ul></li><li><p>counter-increment<br>计数器增加默认值为1，可以设置为任意整数(负数亦可)<br>如：</p><ul><li>.counter1 { counter:apple; counter-increment:apple; }<br>.counter1:before { content:counter(apple) }<br>apple默认值为0,应用了样式counter1的元素第一个显示为1，如果还有第二个应用了<br>那么apple会增加1</li><li>.counter2 { counter:apple; counter-increment:apple 2; }<br>这里设置增量为2，即一次增加2</li></ul></li><li><p>counter()/counters()这个是方法</p><ul><li><p>counter()</p><ul><li>counter(name) name就是counter-reset的名称</li><li>counter(name,style) style支持的关键字是<strong>list-style-type</strong>的值<br>list-style-type<ul><li>disc</li><li>circle</li><li>square</li><li>decimal</li><li>lower-roman</li><li>upper-roman</li><li>lower-alpha </li><li>upper-alpha </li><li>none </li><li>armenian </li><li>cjk-ideographic </li><li>georgian </li><li>lower-greek </li><li>hebrew </li><li>hiragana </li><li>hiragana-iroha </li><li>katakana </li><li>katakana-iroha </li><li>lower-latin </li><li>upper-latin</li></ul></li></ul></li><li><p>counters() 主要用于counter的嵌套<br>css:</p><pre><code class="javascript">  .reset { padding-left: 20px; counter-reset: wangxiaoer; line-height: 1.6; color: #666; }  .counter:before { content: counters(wangxiaoer, &#39;-&#39;) &#39;. &#39;; counter-increment: wangxiaoer; font-family: arial black; }</code></pre><p>html:</p><pre><code class="javascript">  &lt;div class=&quot;reset&quot;&gt;    &lt;div class=&quot;counter&quot;&gt;我是王小二      &lt;div class=&quot;reset&quot;&gt;          &lt;div class=&quot;counter&quot;&gt;我是王小二的大儿子&lt;/div&gt;          &lt;div class=&quot;counter&quot;&gt;我是王小二的二儿子              &lt;div class=&quot;reset&quot;&gt;                  &lt;div class=&quot;counter&quot;&gt;我是王小二的二儿子的大孙子&lt;/div&gt;                  &lt;div class=&quot;counter&quot;&gt;我是王小二的二儿子的二孙子&lt;/div&gt;                  &lt;div class=&quot;counter&quot;&gt;我是王小二的二儿子的小孙子&lt;/div&gt;              &lt;/div&gt;          &lt;/div&gt;          &lt;div class=&quot;counter&quot;&gt;我是王小二的三儿子&lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;counter&quot;&gt;我是王小三&lt;/div&gt;    &lt;div class=&quot;counter&quot;&gt;我是王小四      &lt;div class=&quot;reset&quot;&gt;          &lt;div class=&quot;counter&quot;&gt;我是王小四的大儿子&lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;</code></pre><h1 id="CSS计数器与display-none"><a href="#CSS计数器与display-none" class="headerlink" title="CSS计数器与display:none"></a>CSS计数器与display:none</h1><p>一个元素，如果设置了counter-increment, 但是其display的属性值是none或者含有hidden属性（针对支持浏览器），则此计数值是不会增加的。<br>而visibility:hidden以及其他声明不会有此现象。</p></li></ul></li></ul><h1 id="CSS计数器实际应用"><a href="#CSS计数器实际应用" class="headerlink" title="CSS计数器实际应用"></a>CSS计数器实际应用</h1><p> ol ul等列表计数<br> html5幻灯片页面数量计数等</p><p><a href="http://www.zhangxinxu.com/wordpress/2014/08/css-counters-automatic-number-content/" target="_blank" rel="noopener">参照整理</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Lists_and_Counters/Using_CSS_counters" target="_blank" rel="noopener">Using Css counters</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/counter-reset" target="_blank" rel="noopener">counter-set</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/counter-increment" target="_blank" rel="noopener">counter-increment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> counter </tag>
            
            <tag> 计数器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NextT-vendors-to-lib</title>
      <link href="2016/11/14/NextT-vendors-to-lib/"/>
      <url>2016/11/14/NextT-vendors-to-lib/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-NextT-加载空白问题"><a href="#hexo-NextT-加载空白问题" class="headerlink" title="hexo NextT 加载空白问题"></a>hexo NextT 加载空白问题</h1><p><a href="https://github.com/iissnan/hexo-theme-next/issues/1214" target="_blank" rel="noopener">Detail: https://github.com/iissnan/hexo-theme-next/issues/1214</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> NextT </tag>
            
            <tag> Theme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>window-postmessage</title>
      <link href="2016/11/09/window-postmessage/"/>
      <url>2016/11/09/window-postmessage/</url>
      
        <content type="html"><![CDATA[<h1 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage"></a>window.postMessage</h1><p>跨文档通信 API（Cross-document messaging）。</p><p>这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。</p><p>举例来说，父窗口aaa.com向子窗口bbb.com发消息，调用postMessage方法就可以了。</p><pre><code class="javascript">  var top = window.open(&#39;http://bbb.com&#39;, &#39;title&#39;);  top.postMessage(&#39;Hello World!&#39;, &#39;http://bbb.com&#39;);</code></pre><p>postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即“协议 + 域名 + 端口”。<br>也可以设为*，表示不限制域名，向所有窗口发送。</p><p>子窗口向父窗口发送消息的写法类似。</p><pre><code class="javascript">  window.opener.postMessage(&#39;Nice to see you&#39;, &#39;http://aaa.com&#39;); </code></pre><p>父窗口和子窗口都可以通过message事件，监听对方的消息。</p><pre><code class="javascript">  window.addEventListener(&#39;message&#39;, function(e) {    console.log(e.data);  },false);</code></pre><p><strong>message</strong>事件的事件对象<strong>event</strong>，提供以下三个属性</p><ul><li>event.source：发送消息的窗口</li><li>event.origin: 消息发向的网址</li><li>event.data: 消息内容</li></ul><p>下面的例子是，子窗口通过event.source属性引用父窗口，然后发送消息。</p><pre><code class="javascript">  window.addEventListener(&#39;message&#39;, receiveMessage);  function receiveMessage(event) {    event.source.postMessage(&#39;Nice to see you!&#39;, &#39;*&#39;);  }</code></pre><p>上面代码有几个地方需要注意。<br>首先，receiveMessage函数里面没有过滤信息的来源，任意网址发来的信息都会被处理。<br>其次，postMessage方法中指定的目标窗口的网址是一个星号，表示该信息可以向任意网址发送。<br>通常来说，这两种做法是不推荐的，因为不够安全，可能会被恶意利用。</p><p><strong>event.origin</strong>属性可以过滤不是发给本窗口的消息。</p><pre><code class="javascript">  window.addEventListener(&#39;message&#39;, receiveMessage);  function receiveMessage(event) {    if (event.origin !== &#39;http://aaa.com&#39;) return;    if (event.data === &#39;Hello World&#39;) {        event.source.postMessage(&#39;Hello&#39;, event.origin);    } else {      console.log(event.data);    }  }</code></pre><h1 id="postmessage读取LocalStorage"><a href="#postmessage读取LocalStorage" class="headerlink" title="postmessage读取LocalStorage"></a>postmessage读取LocalStorage</h1><p>下面是一个例子，主窗口写入iframe子窗口的localStorage。</p><pre><code class="javascript">  window.onmessage = function(e) {    if (e.origin !== &#39;http://bbb.com&#39;) {      return;    }    var payload = JSON.parse(e.data);    localStorage.setItem(payload.key, JSON.stringify(payload.data));  };</code></pre><p>上面代码中，子窗口将父窗口发来的消息，写入自己的LocalStorage。</p><p>父窗口发送消息的代码如下。</p><pre><code class="javascript">  var win = document.getElementsByTagName(&#39;iframe&#39;)[0].contentWindow;  var obj = { name: &#39;Jack&#39; };  win.postMessage(JSON.stringify({key: &#39;storage&#39;, data: obj}), &#39;http://bbb.com&#39;)</code></pre><p>加强版的子窗口接收消息的代码如下。</p><pre><code class="javascript">  window.onmessage = function(e) {    if (e.origin !== &#39;http://bbb.com&#39;) return;    var payload = JSON.parse(e.data);    switch (payload.method) {      case &#39;set&#39;:        localStorage.setItem(payload.key, JSON.stringify(payload.data));        break;      case &#39;get&#39;:        var parent = window.parent;        var data = localStorage.getItem(payload.key);        parent.postMessage(data, &#39;http://aaa.com&#39;);        break;      case &#39;remove&#39;:        localStorage.removeItem(payload.key);        break;    }  };</code></pre><p>加强版的父窗口发送消息代码如下。</p><pre><code class="javascript">  var win = document.getElementsByTagName(&#39;iframe&#39;)[0].contentWindow;  var obj = { name: &#39;Jack&#39; };  // 存入对象  win.postMessage(JSON.stringify({key: &#39;storage&#39;, method: &#39;set&#39;, data: obj}), &#39;http://bbb.com&#39;);  // 读取对象  win.postMessage(JSON.stringify({key: &#39;storage&#39;, method: &quot;get&quot;}), &quot;*&quot;);  window.onmessage = function(e) {    if (e.origin != &#39;http://aaa.com&#39;) return;    // &quot;Jack&quot;    console.log(JSON.parse(e.data).name);  };</code></pre><p>本文摘抄自 <a href="http://javascript.ruanyifeng.com/bom/same-origin.html" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/bom/same-origin.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> postmessage </tag>
            
            <tag> message </tag>
            
            <tag> h5API </tag>
            
            <tag> web通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsonp</title>
      <link href="2016/11/09/jsonp/"/>
      <url>2016/11/09/jsonp/</url>
      
        <content type="html"><![CDATA[<h1 id="jsonp介绍"><a href="#jsonp介绍" class="headerlink" title="jsonp介绍"></a>jsonp介绍</h1><p>JSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。<br>它的基本思想是，网页通过添加一个&lt;script&gt;元素，向服务器请求JSON数据，这种做法不受同源政策限制。<br>服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。</p><p>首先，网页动态插入&lt;script&gt;元素，由它向跨源网址发出请求。</p><p>客户端代码（浏览器发送的请求）</p><pre><code class="javascript">  function createScriptTag(src) {    var script = document.createElement(&#39;script&#39;);    script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);    script.src = src;    document.body.appendChild(script);  }  window.onload = function () {    createScriptTag(&#39;http://example.com?callback=foo&#39;);  }  function foo(data) {    console.log(&#39;return server data: &#39; + data);  };</code></pre><p>上面代码通过动态添加&lt;script&gt;元素，向服务器example.com发出请求。<br>注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的</p><p>服务器返回的代码如下<br>java：</p><pre><code class="javascript">  boolean jsonP = false;  String cb = request.getParameter(&quot;callback&quot;);  if (cb != null) {      jsonP = true;      response.setContentType(&quot;text/javascript&quot;);  } else {      response.setContentType(&quot;application/x-json&quot;);  }  Writer out = response.getWriter();  if (jsonP) {      out.write(cb + &quot;(&quot;);  }  out.print(dataBlock.toJsonString());  if (jsonP) {      out.write(&quot;);&quot;);  } </code></pre><p>php:</p><pre><code class="javascript">  $callback = $_REQUEST[&#39;callback&#39;];  // Create the output object.  $output = array(&#39;a&#39; =&gt; &#39;Apple&#39;, &#39;b&#39; =&gt; &#39;Banana&#39;);  //start output  if ($callback) {      header(&#39;Content-Type: text/javascript&#39;);      echo $callback . &#39;(&#39; . json_encode($output) . &#39;);&#39;;  } else {      header(&#39;Content-Type: application/x-json&#39;);      echo json_encode($output);  }</code></pre><p>asp.net:</p><pre><code class="javascript">String jsonString = &quot;{success: true}&quot;;String cb = Request.Params.Get(&quot;callback&quot;);String responseString = &quot;&quot;;if (!String.IsNullOrEmpty(cb)) {    responseString = cb + &quot;(&quot; + jsonString + &quot;)&quot;;} else {    responseString = jsonString;}Response.Write(responseString);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ajax </tag>
            
            <tag> cros </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript_note</title>
      <link href="2016/10/14/typescript-note/"/>
      <url>2016/10/14/typescript-note/</url>
      
        <content type="html"><![CDATA[<p>typescript 入门</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="tsc-命令行编译器"><a href="#tsc-命令行编译器" class="headerlink" title="tsc 命令行编译器"></a>tsc 命令行编译器</h3><ul><li><p>windows上的两个版本</p><p>一个是官方网站上下载的.msi安装包，一个是通过npm install -g typescript安装的版本。</p></li><li><p>多文件编译及合并</p><p>ts文件之间可以声明静态依赖关系，只要在文件头部给出引用的文件：<br>///<reference path='../core/UndoManager.ts'/><br>tsc可以自动寻找和编译依赖的文件，所以编译时可以只传入一个“根”ts文件，只要从这个文件出发能找到所有需要的文件。<br>要小心的是，如果这个引用声明中有任何语法错误，例如引号未闭合、少了结尾的’/‘等，编译器会悄悄的忽略这一行，从而产生难以理解的编译错误（也许是个bug）。<br>如果文件找不到，则编译器能给出正确的提示。<br>虽然一些js文件可以不加修改地作为ts文件编译，但是如果扩展名不改为.ts，则编译器会报错（也许是个bug）。</p></li><li><p>监视文件修改（参考[21]）</p><p>-watch 或 -w <file></p><p>注意只有npm版本支持此选项。如果windows安装了两个版本，则要从path环境变量中把msi版本的tsc排除掉。</p><p>当使用此选项时，tsc将不会退出。所以它只应该在调试的时候使用。</p><p>另一个办法是利用grunt的监视功能。参考”用grunt编译“。</p></li><li><p>sourcemap</p><p>–sourcemap选项<br>生成ts和js代码之间的映射关系，这样调试器、console.*、异常就能够定位到ts文件了。<br>参考：<a href="http://net.tutsplus.com/tutorials/tools-and-tips/source-maps-101/" target="_blank" rel="noopener">http://net.tutsplus.com/tutorials/tools-and-tips/source-maps-101/</a></p><p>chrome 的 dev tool 要打开 “enable source map” 选项。 Firefox 的 dev tool 要打开 “show original source” 选项。</p></li><li><p>declaration</p><p>–declaration 用于生成相应的环境声明文件。</p></li></ul><h3 id="tsc-工程文件-tsconfig-json-22"><a href="#tsc-工程文件-tsconfig-json-22" class="headerlink" title="tsc 工程文件 - tsconfig.json [22]"></a>tsc 工程文件 - tsconfig.json [22]</h3><p>例子[22]：</p><pre><code>{    &quot;compilerOptions&quot;: {        &quot;module&quot;: &quot;commonjs&quot;,        &quot;noImplicitAny&quot;: true,        &quot;removeComments&quot;: true,        &quot;preserveConstEnums&quot;: true,        &quot;out&quot;: &quot;../../built/local/tsc.js&quot;,        &quot;sourceMap&quot;: true,    },    &quot;files&quot;: [        &quot;core.ts&quot;,        &quot;sys.ts&quot;,    ]}</code></pre><h3 id="用grunt编译"><a href="#用grunt编译" class="headerlink" title="用grunt编译"></a>用grunt编译</h3><ul><li><p>grunt</p><p>npm install -g grunt-cli</p></li><li><p>package</p><p>在工程根目录下创建 package.json：</p><pre><code>{  &quot;name&quot;: &quot;projectName&quot;,  &quot;version&quot;: &quot;0.1.0&quot;,  &quot;devDependencies&quot;: {    &quot;grunt&quot;: &quot;~0.4.1&quot;,    &quot;grunt-exec&quot;: &quot;~0.4.0&quot;,    &quot;grunt-contrib-watch&quot;: &quot;~0.3.1&quot;  }}</code></pre><p>grunt-exec 用于执行系统命令，我们用它来执行tsc。<br>尽管有一些grunt插件专门用于编译ts（grunt-typescript和grunt-type），但似乎并没有特别的优势，你也可以尝试。</p></li><li><p>Gruntfile.js<br>module.exports = function(grunt) {<br>grunt.loadNpmTasks(‘grunt-exec’);<br>grunt.loadNpmTasks(‘grunt-contrib-watch’);<br>grunt.initConfig({<br>exec: {<br>  ts: {</p><pre><code>command: &#39;tsc --sourcemap --target ES5 --out src/jsgen/main.ts.js src/main/main.ts&#39;,stdout: true,stderr: true</code></pre><p>  }<br>},<br>watch: {<br>  files: ‘src/<em>*/</em>.ts’,<br>  tasks: [‘exec:ts’]<br>},<br>});<br>}</p></li></ul><p>只编译的话，执行<br>grunt exec<br>要监视文件修改，自动编译的话，执行<br>grunt watch</p><p>参考：<br>  <a href="http://stackoverflow.com/questions/12725544/how-to-use-the-typescript-compiler-in-the-watch-output-files-mode-tsc-w-on" target="_blank" rel="noopener">http://stackoverflow.com/questions/12725544/how-to-use-the-typescript-compiler-in-the-watch-output-files-mode-tsc-w-on</a></p><h3 id="atom-typescript-23"><a href="#atom-typescript-23" class="headerlink" title="atom typescript [23]"></a>atom typescript [23]</h3><p>这是 atom 编辑器的一个扩展，可以支持 TS 的自动完成、跳转、重构等。以下简称ATS。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>apm install atom-typescript</p><p>其它推荐的扩展（<a href="https://atom.io/packages/）：" target="_blank" rel="noopener">https://atom.io/packages/）：</a><br>line-ending-converter<br>linter-htmlhint<br>atom-beautify<br>jsdoc: Control-Shift-d to add comment templates<br>save-session</p><h4 id="命令-快捷键"><a href="#命令-快捷键" class="headerlink" title="命令/快捷键"></a>命令/快捷键</h4><p>跳转到声明：f12<br>查找引用：shift+f12<br>重命名符号：f2<br>格式化代码：ctrl+alt+l。如果有选中，则只格式化选中部分。<br>Symbols View: ctrl+r<br>引用文件：输入 “ref” + tab</p><h4 id="工程配置"><a href="#工程配置" class="headerlink" title="工程配置"></a>工程配置</h4><p>使用 tsconfig.json，ats 相关的选项有（部分）：</p><pre><code>{    &quot;compileOnSave&quot;: false,    &quot;formatCodeOptions&quot;: {        &quot;indentSize&quot;: 2,        &quot;tabSize&quot;: 3,        &quot;newLineCharacter&quot;: &quot;\r\n&quot;,        &quot;convertTabsToSpaces&quot;: true    }}</code></pre><h3 id="VS-2012"><a href="#VS-2012" class="headerlink" title="VS 2012"></a>VS 2012</h3><p>目前（0.8.3）仅当作代码编辑器就好，编译和调试还不好用。<br>使用命令行编译，用浏览器调试。</p><ul><li>设置编译目标为ES5<br>如果代码里使用了ES5特性，则应该这样做，否则编辑器会提示语法错误。<br>现在(0.8.3)不能在GUI中设置，要修改vs工程文件，将<br><TypeScriptTarget>ES3</TypeScriptTarget><br>都改为<br><TypeScriptTarget>ES5</TypeScriptTarget></li></ul><h3 id="sublime-text2-sublime-typescript-插件"><a href="#sublime-text2-sublime-typescript-插件" class="headerlink" title="sublime text2 + sublime-typescript 插件"></a>sublime text2 + sublime-typescript 插件</h3><p>插件主页：<br>  <a href="https://github.com/raph-amiard/sublime-typescript" target="_blank" rel="noopener">https://github.com/raph-amiard/sublime-typescript</a><br>在sublime的插件目录（linux下是 ~/.config/sublime-text-2/Packages）中运行<br>  git clone <a href="https://github.com/raph-amiard/sublime-typescript" target="_blank" rel="noopener">https://github.com/raph-amiard/sublime-typescript</a><br>然后重启sublime。<br>如果状态栏上一直显示“Loading typescript plugin”，而 ~/.config/sublime-text-2/Packages/sublime-typescript/lib/typescript/ts.zip<br>的大小一直很小（下载完后应是4MB左右），这说明下载ts源码出问题了。打开<br>~/.config/sublime-text-2/Packages/sublime-typescript/core/install.py<br>找到形如 TYPESCRIPT_SOURCE_LINK = …<br>的行，将后面的url下载下来，应该是个zip，解压到<br>~/.config/sublime-text-2/Packages/sublime-typescript/lib/typescript/<br>下面，应该有<br>~/.config/sublime-text-2/Packages/sublime-typescript/lib/typescript/bin<br>等目录。<br>然后重启sublime。打开控制台（view菜单），这时应该没有错误了。</p><h3 id="浏览器中调试"><a href="#浏览器中调试" class="headerlink" title="浏览器中调试"></a>浏览器中调试</h3><p>编译时tsc需要使用–sourcemap选项，这样会生成.map文件。<br>用chrome调试ts代码需要保证开发工具设置中“enable source map”选项选中了（默认未选中）。<br>参考：<a href="http://stackoverflow.com/questions/13569192/typescript-source-map-files-dont-work-with-chrome" target="_blank" rel="noopener">http://stackoverflow.com/questions/13569192/typescript-source-map-files-dont-work-with-chrome</a><br>  <a href="http://www.aaron-powell.com/web/typescript-source-maps" target="_blank" rel="noopener">http://www.aaron-powell.com/web/typescript-source-maps</a></p><p>firefox(22)和IE(10)目前尚未支持 sourcemap，所以只能调试生成的js文件。<br>  firefox的进度：<a href="https://wiki.mozilla.org/DevTools/Features/SourceMap" target="_blank" rel="noopener">https://wiki.mozilla.org/DevTools/Features/SourceMap</a></p><h3 id="浏览器中即时编译"><a href="#浏览器中即时编译" class="headerlink" title="浏览器中即时编译"></a>浏览器中即时编译</h3><p>  TypeScript Compile automatically transforms your TypeScript code into JavaScript on the fly<br>  <a href="https://github.com/niutech/typescript-compile" target="_blank" rel="noopener">https://github.com/niutech/typescript-compile</a></p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>  TypeScript Language Specification.pdf<br>  Known breaking changes between 0.8 and 0.9 | <a href="https://typescript.codeplex.com/wikipage?title=Known%20breaking%20changes%20between%200.8%20and%200.9" target="_blank" rel="noopener">https://typescript.codeplex.com/wikipage?title=Known%20breaking%20changes%20between%200.8%20and%200.9</a></p><h3 id="类型指定和简单类型"><a href="#类型指定和简单类型" class="headerlink" title="类型指定和简单类型"></a>类型指定和简单类型</h3><p>对于一般变量、函数参数、对象属性，可在变量名后面加冒号（:）并跟上类型表达式；<br>对于一般函数、类和接口的方法的返回值，则是在参数表之后加上 ‘：’ 并跟上类型表达式。</p><p>例如：<br>  var a:number = 2;<br>  function vote(candidate: string)：string { … }<br>  var reports: string[] = [];</p><p>类型表达式有内置的、自定义的、推导的。内置类型包括 any, number, string，bool（这是0.8的，0.9改为boolean）, void这几个也是保留字。<br>其中any的含义是“任何类型”，void仅用于函数返回类型。<br>自定义类型包括：函数类型、对象类型（也就是接口类型）等，后面逐一描述。<br>一般对象的类型是Object，一般函数的类型是Function，这两个都是接口。<br>推导类型主要是数组类型，语法是 typename[]，与java类似。</p><p>另一种指定类型的方式是让编译器通过初始化表达式进行类型推断，例如<br>  var i=0; //i具有类型number<br>  var a=null; //var a:any<br>  var b=undefined; //var a:any<br>  var c={x:0, y:null}; //var c:{x:number; y:any;}<br>  function squr(i:number) { return i*i; } // 返回类型可省略，因为从return语句的类型可以推断出来</p><p>如果变量没有被指定类型，则其类型视为any。除了any类型，对其它类型的使用在编译时都要受到类型检查，这与强类型语言类似。</p><p>null和undefined虽然也是类型，但不能用于类型指定，只能作为字面量使用。<br>值null兼容于任何类型，除了void和undefined类型，也就是说这是合法的：<br>  var b:bool = null;<br>值undefined兼容于任何类型，包括void。</p><h3 id="环境声明-（Ambient-declare）"><a href="#环境声明-（Ambient-declare）" class="headerlink" title="环境声明 （Ambient declare）"></a>环境声明 （Ambient declare）</h3><p>使用 declare 关键字：<br>  declare var document; //浏览器document对象<br>  declare var $; //jqurey对象<br>环境声明可用于声明不是由ts实现的结构，例如js类库、浏览器内置对象等。<br>由于使用未声明变量在ts中是编译错误，所以这是必要的。</p><ul><li><p>接口的环境声明<br>与一般的接口声明没有区别。declare修饰符是可选的。<br>但是只声明接口，客户代码无法使用new操作符。</p></li><li><p>类的环境声明<br>如果希望使用 new SomeClass(…)，而SomeClass是js实现的，那么需要用类的环境声明，接口是不够的，例如：</p></li></ul><p>module m{<br>declare export class {<br>  field1:type1;<br>  constructor(…);<br>  func();<br>}<br>}</p><p>也就是说，方法体用”;”代替，属性不要初始化。declare是可选的。如果类不在模块中，模块声明和export是不需要的（如果有，则是语法错误）。</p><ul><li><p>常用js库的环境声明文件<br><a href="https://github.com/borisyankov/DefinitelyTyped" target="_blank" rel="noopener">https://github.com/borisyankov/DefinitelyTyped</a><br><a href="https://github.com/Diullei/tsd" target="_blank" rel="noopener">https://github.com/Diullei/tsd</a></p><p>安装tsd：<br>npm install -g tsd<br>进入希望放置d.ts文件的目录，安装想要的库：<br>tsd install qunit</p></li></ul><h3 id="函数类型表达式"><a href="#函数类型表达式" class="headerlink" title="函数类型表达式"></a>函数类型表达式</h3><ul><li><p>一般语法<br>函数类型表达式的一般形式是：<br>(param:paremType,param2:paremType2…) =&gt; returnType<br>TODO：返回类型可以省略吗？<br>例如：</p><p>function vote(candidate: string, callback: (result: string) =&gt; any) {<br>// …<br>}</p></li></ul><p>参数callback的类型就是一个函数类型 (result: string) =&gt; any</p><ul><li>注意<br>与函数相关的语法结构有3种：<br>（1）函数类型表达式。就是上面讲的。<br>（2）函数声明。给出函数签名，但没有函数体。<br>（3）函数定义。给出函数签名和函数体。<br>函数类型和函数声明、函数实现的语法上的区别，主要在于返回类型的声明上，前者用箭头，后者用冒号。<br>为什么有这样的区别？因为类型指定表达式中已经有了冒号，所以函数类型表达式要避免在同一层次上使用冒号。<br>在对象类型/接口（详见对象类型/接口）中，可以看到这样的函数声明：<br>funcName(param:paremType,param2:paremType2…):returnType</li></ul><h3 id="对象类型表达式（匿名接口）"><a href="#对象类型表达式（匿名接口）" class="headerlink" title="对象类型表达式（匿名接口）"></a>对象类型表达式（匿名接口）</h3><p>一般形式是：<br>  {<br>    fieldName:fieldType;<br>    fieldName2:fieldType2;<br>    method1(paramName:paramType…):returnType;<br>    method2：(paramName:paramType…)=&gt;returnType;<br>    …<br>  }</p><p>注意字段之间是分号分割的，而不是像对象字面量的属性那样用逗号分隔，这是两者的关键区别。<br>对象类型中的字段可以被声明为可选的，只需在fieldName后加上问号。<br>如果字段的类型是函数（称为方法），则采用“字段名、参数表、冒号、返回类型”的形式，如同method1那样;<br>或者采用“字段名、冒号、函数类型表达式”的形式，如method2；这两种形式是等效的。<br>注意，方法前不要加function关键字。<br>对象类型中的字段可以被声明为可选的，只需在fieldName后加上问号。</p><p>例子：<br>  var MakePoint: () =&gt; {<br>    x: number; y: number;<br>  };<br>意思是，变量MakePoint的类型是个函数，该返回值的类型是个对象，该对象有x、y两个number类型的字段。</p><p>如果对象本身还是个函数，则可以声明一个匿名函数字段，也就是<br>{<br>  (param:paremType,…):returnType;<br>  …<br>}<br>如果对象类型只有匿名函数字段，则等效于一个函数类型声明。</p><p>ts允许对象类型加入多个同名函数字段，只要它们有不同的参数表，也就是说支持函数重载。</p><p>如果一个对象提供了比一个对象类型更多的字段，并不会被认为类型不符合。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>如果给对象类型命名以便复用，就是接口，语法如下：<br>  interface IterfaceName {fieldName:fieldType; fieldName2:fieldType2;… }<br>interface也是关键字。<br>然后可以将IterfaceName用作类型表达式。</p><ul><li>例子<br>例1：<br>interface Friend {<br>  name: string;<br>  favoriteColor?: string;<br>}<br>function add(friend: Friend) {<br>  var name = friend.name;<br>}<br>add({ name: “Fred” }); // Ok<br>add({ favoriteColor: “blue” }); // Error, name required<br>add({ name: “Jill”, favoriteColor: “green” }); // Ok</li></ul><p>例2：<br>  interface JQuery {<br>    text(content: string);<br>  }<br>  interface JQueryStatic {<br>    get(url: string, callback: (data: string) =&gt; any);<br>    (query: string): JQuery;<br>    (ready: () =&gt; any): any;<br>  }<br>  declare var $: JQueryStatic;<br>  $.get(“<a href="http://mysite.org/divContent&quot;" target="_blank" rel="noopener">http://mysite.org/divContent&quot;</a>,<br>    function (data: string) {<br>      $(“div”).text(data);<br>    }<br>  );</p><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><ul><li><p>返回类型推断<br>function mul(a: number, b: number) {<br>  return a * b;<br>}<br>ts推断mul的返回类型是number。</p></li><li><p>实参的形参类型推断<br>如果$.get被声明为类型：<br>(url:string, (data:string)=&gt;any)=&gt;any<br>则<br>$.get(“<a href="http://mysite.org/divContent&quot;" target="_blank" rel="noopener">http://mysite.org/divContent&quot;</a>,<br>function (data) {<br>  $(“div”).text(data); // TypeScript infers data is a string<br>}<br>);</p></li><li><p>Contextually Typed Expressions<br>根据被赋值的变量的类型推断赋值表达式中的类型。<br>var f: (s: string) =&gt; string;<br>f = function(s) { return s.toLowerCase(); } //s inferred as string</p></li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul><li>语法<br>class ClassName {<br>modifer filed1 = value1;<br>constructor(param:type) {…}<br>modifer method1(param:type):returnType { … }<br>}<br>其中 class 是关键字。</li></ul><p>字段可以给出初始值，类型可以从初始值推断。与接口一样，字段定义以分号结尾。</p><p>修饰符modifer是public或private，省略时默认为public。但这只在编译时检查。</p><p>constructor 也是关键字，表示构造器。如果没有声明构造器，则会有一个无参数构造器。</p><p>方法定义与接口类似，但因为有了函数体，不再需要分号结尾。</p><p>注意，方法和构造器前不要加function关键字。</p><p>在方法内部，访问字段或其它方法仍然需要用this关键字，这与js相同。</p><p>上述代码翻译为js时，会创建一个名为ClassName的伪类，方法都会定义于ClassName.prototype上。</p><p>修饰符modifer还可以是static，这时字段成为（伪）类本身的属性，要通过ClassName.filed访问。</p><p>类中的方法也支持重载，但是各个重载版本必须共用一个函数体，详见“重载”。</p><ul><li><p>在构造器中定义字段<br>这是一种方便语法。在构造器形式参数前加上访问修饰符，则会在类中定义同名字段，<br>并自动将该参数赋值给该字段，例如：<br>constructor(public param:type) {…}</p></li><li><p>类类型<br>如果变量的类型是一个（伪）类或者是构造函数，则可用如下类型表达式：<br>new(param:type…) =&gt; ClassOrInterfaceName<br>new关键字表明，这是个需要通过new语法调用的函数，并返回某个类或接口的对象。</p></li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>语法与java类似，采用extends关键字：</p><p>  class CheckingAccount extends BankAccount {<br>    constructor(balance: number) {<br>      super(balance);<br>    }<br>    writeCheck(debit: number) {<br>      this.balance -= debit;<br>    }<br>  }</p><p>调用父类构造器的方法是super(…)。TODO:如果没有显式调用，编译器是否会自动调用super()？<br>调用父类属性的方法是super.identifier。<br>在编译器生成的js代码中，子（伪）类的prototype会链接（chain）到父（伪）类的prototype上。</p><ul><li><p>实现接口<br>类也可以用implements关键字指明它实现了哪些接口，与Java的语法相同。<br>不过，类不必显式的声明它实现了什么接口，在需要该接口的场合，直接使用该类的实例也是正确的。</p></li><li><p>接口之间的继承<br>接口可以继承接口，用extends关键字，与Java相同。</p></li></ul><h3 id="强制类型转换（type-assertion）"><a href="#强制类型转换（type-assertion）" class="headerlink" title="强制类型转换（type assertion）"></a>强制类型转换（type assertion）</h3><p>语法：<br><type> expression<br>也就是将Java/C#中的圆括号改为尖括号。</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>对应js的模块模式。</p><ul><li>内部模块</li></ul><p>语法：<br>module M { //模块名M<br>  var var1 = value1; //模块私有变量<br>  function func1(…) {…}; //模块私有函数<br>  class C1 {…} //模块私有类<br>  export var var2 = value2; //导出变量<br>  export function func2(…) {…}; //导出函数<br>  export class C1 {…} //导出类<br>}</p><p>这样创建了一个名为M的模块对象（如果是在全局作用域，则M是个全局对象）<br>导出的结构都可以用M.name访问。</p><p>导出类型可以访问非导出类型，但是不能出现在导出的API中，例如public成员不能是非导出类型。<br>不过当前的tsc（0.8.3）似乎也不接受类的private成员有非导出类型，尽管局部变量使用非导出类型是没问题的。</p><p>module 和 export 都是关键字。</p><p>如果不在模块内部而使用了export关键字，编译器会报错“Cannot compile dynamic modules when emitting into single file”，这可能是个bug。</p><p>例子：<br>module M {<br>var s = “hello”;<br>export function f() {<br>return s;<br>}<br>}<br>M.f();<br>M.s; // Error, s is not exported</p><p>生成的js代码是：</p><p>var M;<br>(function(M) {<br>var s = “hello”;<br>function f() {<br>return s;<br>}<br>M.f = f;<br>})(M||(M={}));</p><ul><li>外部模块<br>这是为了产生用于CMD、AMD等系统的模块。<br>语法上，没有module M {} 构造，但是有顶层的 export 和 import 指令。</li></ul><h3 id="箭头函数表达式（arrow-function-expressions）"><a href="#箭头函数表达式（arrow-function-expressions）" class="headerlink" title="箭头函数表达式（arrow function expressions）"></a>箭头函数表达式（arrow function expressions）</h3><p>这也是计划中的ES6特性。<br>(param,…) =&gt; {…}<br>或者<br>param =&gt; {…}</p><p>括号和函数体中的return关键字有时是可选的。</p><p>例子：<br>(x) =&gt; { return Math.sin(x); }<br>(x) =&gt; Math.sin(x)<br>x =&gt; { return Math.sin(x); }<br>x =&gt; Math.sin(x)</p><p>以上都是等效的。</p><p>箭头函数表达式并不仅仅是传统函数表达式的简化写法。语义上的区别是，前者重用了上下文的this值，而后者的this值可以是其它值。</p><h2 id="高级语法"><a href="#高级语法" class="headerlink" title="高级语法"></a>高级语法</h2><h3 id="参考文献-1"><a href="#参考文献-1" class="headerlink" title="参考文献"></a>参考文献</h3><p>  TypeScript Language Specification.pdf</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ul><li><p>全局模块<br>ts总是有一个全局模块，对应于js的全局作用域。</p></li><li><p>成员和类型<br>ts把语法构造分为两类：成员（members）和类型（types）。<br>成员包括：变量、函数、模块、构造器（即伪类）；<br>类型包括：模块、类、接口。</p></li></ul><p>可见，成员都是js原有的东西，类型则是ts新增的概念。<br>其中模块、类同时对成员和类型有贡献。</p><ul><li>声明空间<br>声明空间分为成员声明空间和类型声明空间两种，互相不会冲突。也就是说，可以同时声明同名的成员和类型。例如这是合法的：<br>module M<br>{<br>interface X { }<br>var X;<br>}<br>但如果X是个类，则出现语法错误，因为class同时对成员和类型有贡献。</li></ul><p>模块同时有成员声明空间和类型声明空间；其它大多数构造只有成员声明空间。</p><ul><li><p>模块和接口的合并<br>对于内部模块，同一模块可以被定义多次，可以分散到多个文件中，只要全名相同，则这些模块定义被合并。<br>接口也是这样。<br>多个同名内部模块内的局部成员的名字是不会冲突的，但导出的名字可能会冲突。</p></li><li><p>静态成员和非静态成员在不同的声明空间中<br>这是合法的：<br>class C<br>{<br>x: number;<br>static x: string;<br>}</p></li><li><p>嵌套的模块<br>模块可以嵌套。<br>内层模块中的名字会隐藏外部模块中相同的名字。</p></li></ul><h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>类、接口、模块、匿名对象类型都产生了对象类型。</p><p>仅有类的成员可以声明为私有的，其它都是公有的。</p><p>内部成员完全相同的两个类也是不兼容的。不过这只在编译时检查。</p><p>模块不能被声明为实现了某个接口。不过仍有可能对模块进行编译时类型检查，参考：<br>  <a href="http://stackoverflow.com/questions/16072471/why-cant-typescript-modules-implement-or-adhere-to-an-interface-can-i-get-arou" target="_blank" rel="noopener">http://stackoverflow.com/questions/16072471/why-cant-typescript-modules-implement-or-adhere-to-an-interface-can-i-get-arou</a></p><ul><li>ts的内置接口<br>ts的内置接口包括 Object、Function、Number、String、Bool 接口 – 不要和同名的js伪类混淆。<br>所有的对象都被认为实现了 Object 接口；函数和构造器被认为实现了 Function 接口；<br>基本类型number、string、bool被认为实现了Number、String、Bool 接口。</li></ul><h3 id="函数的进一步讨论"><a href="#函数的进一步讨论" class="headerlink" title="函数的进一步讨论"></a>函数的进一步讨论</h3><ul><li>重载<br>实现重载函数的例子是：</li></ul><p>function attr(name: string): string;<br>function attr(name: string, value: string): Accessor;<br>function attr(map: any): Accessor;<br>function attr(nameOrMap: any, value: string): any {<br>  if (nameOrMap &amp;&amp; typeof nameOrMap === “object”) {<br>  // handle map case<br>  }<br>  else {<br>  // handle string case<br>  }<br>}</p><p>也就是在函数体前声明多个函数签名，用分号隔开，最后跟上实际的函数实现。<br>不过，因为只能共用一个函数体，所以必须检查参数的实际类型。</p><p>以上实现的attr函数具有以下类型：<br>{<br>  (name: string): string;<br>  (name: string, value: string): Accessor;<br>  (map: any): Accessor;<br>}</p><ul><li><p>可选参数和默认值<br>ES5函数支持可选参数和默认值，ts中一样可以用；还可以在参数后加上问号表示可选参数。<br>例如：<br>redo(step?=1) { }<br>或者<br>redo(step=1) { }<br>以上是等效的。也可以只给出可选参数但不给出默认值：<br>redo(step?) { }</p></li><li><p>变长参数表（Rest Parameters）<br>参考：<br><a href="http://stackoverflow.com/questions/12739149/typescript-type-signatures-for-functions-with-variable-argument-counts" target="_blank" rel="noopener">http://stackoverflow.com/questions/12739149/typescript-type-signatures-for-functions-with-variable-argument-counts</a></p></li></ul><p>语法：<br>function func(…args: type[]) {<br>  …<br>}</p><p>例如 （<a href="http://stackoverflow.com/questions/12697275/open-ended-function-arguments-with-typescript）：" target="_blank" rel="noopener">http://stackoverflow.com/questions/12697275/open-ended-function-arguments-with-typescript）：</a><br>function sum(…numbers: number[]) {<br>    var aggregateNumber = 0;<br>    for (var i = 0; i &lt; numbers.length; i++)<br>        aggregateNumber += numbers[i];<br>    return aggregateNumber;<br>}</p><p>This will then type check correctly with</p><p>console.log(sum(1, 5, 10, 15, 20));</p><ul><li>变长参数表函数的重载<br>通常希望变长参数表也能接受数组作为参数，这就需要一个重载的版本。但是以下做法是语法错误：<br>  addProperties(…propNames: string[]);<br>  addProperties(propNames: string[]) {<br>  //…<br>  ｝<br>两个参数表交换位置、propNames: string[] 改为 propNames: any[]也都是语法错误。<br>只有这样是允许的：<br>  addProperties(…propNames: string[]);<br>  addProperties(propNames) {<br>  //…<br>  ｝<br>但是能否正常工作则不清楚。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="http://www.typescriptlang.org/" target="_blank" rel="noopener">TypeScript 官方网站</a></p><p>[2] <a href="http://www.typescriptlang.org/Content/TypeScript%20Language%20Specification.pdf" target="_blank" rel="noopener">TypeScript 语言规范（英）</a></p><p>[3] <a href="http://www.typescriptlang.org/Handbook" target="_blank" rel="noopener">TypeScript 手册（英）</a></p><p>[4] <a href="https://github.com/Microsoft/TypeScript" target="_blank" rel="noopener">TypeScript 源码库（github）</a></p><p>[5] <a href="http://www.codebelt.com/category/typescript/" target="_blank" rel="noopener">TypeScript - codeBelt（一些 typescript 教程（英））</a></p><p>[6] <a href="http://blog.csdn.net/he_8134/article/details/10954049" target="_blank" rel="noopener">TypeScript —— Web前端开发的救赎</a></p><p>[7] <a href="http://www.csdn.net/article/2012-10-11/2810645-Thoughts-on-TypeScript" target="_blank" rel="noopener">JavaScript 大师 Nicholas C. Zakas 谈 TypeScript</a></p><p>[21] <a href="http://stackoverflow.com/questions/12725544/how-to-use-the-typescript-compiler-in-the-watch-output-files-mode-tsc-w-on" target="_blank" rel="noopener">how to use the typescript compiler in the watch output files</a></p><p>[22] <a href="https://github.com/Microsoft/TypeScript/wiki/tsconfig.json" target="_blank" rel="noopener">tsconfig.json</a></p><p>[23] <a href="https://github.com/TypeStrong/atom-typescript" target="_blank" rel="noopener">atom-typescript</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jsxShapeCreate</title>
      <link href="2016/09/28/jsxShapesCreate/"/>
      <url>2016/09/28/jsxShapesCreate/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="形状create-constructor-JSXGraph元素篇"><a href="#形状create-constructor-JSXGraph元素篇" class="headerlink" title="形状create constructor JSXGraph元素篇"></a>形状create constructor JSXGraph元素篇</h1><h2 id="Angle-角度-JXG-GeometryElement-gt-JXG-Curve-gt-Sector-gt-angle"><a href="#Angle-角度-JXG-GeometryElement-gt-JXG-Curve-gt-Sector-gt-angle" class="headerlink" title="Angle 角度  JXG.GeometryElement -&gt; JXG.Curve -&gt; Sector -&gt; angle"></a>Angle 角度  JXG.GeometryElement -&gt; JXG.Curve -&gt; Sector -&gt; angle</h2><p>  Defined in  sector.js<br>  Extends Sector<br>  JXG.Board#create  type:angle</p><ul><li><p>param array<br>p1—-JXG.Point<br>p2—-JXG.Point<br>p3—-JXG.Point<br>以p2为角点 p1到p3的角度 逆时针</p></li><li><p>example</p><pre><code class="javascript">// Create an angle out of three free points 创建一个三个自由点的角度var p1 = board.create(&#39;point&#39;, [5.0, 3.0]),p2 = board.create(&#39;point&#39;, [1.0, 0.5]),p3 = board.create(&#39;point&#39;, [1.5, 5.0]),a = board.create(&#39;angle&#39;, [p1, p2, p3]);</code></pre><p>这是创建一个角度的代码<br>A/B/C三点 A/C为控制角大小的点 B为实际的角度点</p><pre><code class="javascript">// Create an angle out of three free points 从两条线和两个方向创建一个角度var p1 = board.create(&#39;point&#39;, [-1, 4]),p2 = board.create(&#39;point&#39;, [4, 1]),q1 = board.create(&#39;point&#39;, [-2, -3]),q2 = board.create(&#39;point&#39;, [4,3]),li1 = board.create(&#39;line&#39;, [p1,p2], {strokeColor:&#39;black&#39;, lastArrow:true}),li2 = board.create(&#39;line&#39;, [q1,q2], {lastArrow:true}),a1 = board.create(&#39;angle&#39;, [li1, li2, [5.5, 0], [4, 3]], { radius:1 }),a2 = board.create(&#39;angle&#39;, [li1, li2, 1, -1], { radius:2 });</code></pre><p>这是两条直线与点的夹角</p><pre><code class="javascript">var p1, p2, p3, c, a, s;p1 = board.create(&#39;point&#39;,[0,0]);p2 = board.create(&#39;point&#39;,[5,0]);p3 = board.create(&#39;point&#39;,[0,5]);c1 = board.create(&#39;circle&#39;,[p1, p2]);a = board.create(&#39;angle&#39;,[p2, p1, p3], {radius:3});a.setAngle(function() {    return Math.PI / 3;});board.update();</code></pre><pre><code class="javascript">var p1, p2, p3, c, a, s;p1 = board.create(&#39;point&#39;,[0,0]);p2 = board.create(&#39;point&#39;,[5,0]);p3 = board.create(&#39;point&#39;,[0,5]);c1 = board.create(&#39;circle&#39;,[p1, p2]);a = board.create(&#39;angle&#39;,[p2, p1, p3], {radius:3});s = board.create(&#39;slider&#39;,[[-2,1], [2,1], [0, Math.PI*0.5, 2*Math.PI]]);a.setAngle(function() {    return s.Value();});board.update();</code></pre></li><li><p>Attributes：</p><ul><li>orthoSensitivity<br>default:1.0</li><li>orthoType<br>option value:sector/sectordot/square/none   default:square</li><li>radius<br>扇形半径 default:0.5</li><li>type<br>default:’sector’</li><li>其他<br>借用其他元素的属性：Sector、JXG.Curve、JXG.GeometryElement</li></ul></li><li><p>Fields</p><ul><li>dot<br>预测一个直角</li><li>point</li><li>pointsquare</li></ul></li><li><p>Methods</p><ul><li>free()<br>释放一个由setAngle设置的角，转换为一个自由点<br>return （a object which） pointer to the angle element 返回一个指向这个角的对象</li><li>setAngle(val)<br>设定一个角度以弧度为规定值。如果角的第三点，这是唯一可能的，即anglepoint是一个自由的点。</li></ul></li><li><p>Events<br>借用其他元素的事件：JXG.GeometryElement</p></li></ul><h2 id="Arc-弧-JXG-GeometryElement-gt-JXG-Curve-gt-Curve-gt-Arc"><a href="#Arc-弧-JXG-GeometryElement-gt-JXG-Curve-gt-Curve-gt-Arc" class="headerlink" title="Arc 弧 JXG.GeometryElement -&gt; JXG.Curve -&gt; Curve -&gt; Arc"></a>Arc 弧 JXG.GeometryElement -&gt; JXG.Curve -&gt; Curve -&gt; Arc</h2><p>  Defined in arc.js<br>  Extends Curve</p><ul><li><p>param array<br>p1—-JXG.Point<br>p2—-JXG.Point<br>p3—-JXG.Point<br>以p1位弧心 从p2到p3的弧度 逆时针</p></li><li><p>example</p><pre><code class="javascript">// Create an arc out of three free pointsvar p1 = board.create(&#39;point&#39;, [2.0, 2.0]);var p2 = board.create(&#39;point&#39;, [1.0, 0.5]);var p3 = board.create(&#39;point&#39;, [3.5, 1.0]);var a = board.create(&#39;arc&#39;, [p1, p2, p3]);</code></pre><p>p1为弧度的中心点 p2到p3逆时针旋转  </p></li><li><p>Attributes<br>借用其他元素的属性：Curve</p></li><li><p>Fields</p><ul><li>anglepoint<br>这个点定义弧的度</li><li>center<br>弧的中心点</li><li>radiuspoint<br>这个点定义弧的半径</li><li>其他<br>借用其他元素的属性：JXG.Curve、JXG.GeometryElement</li></ul></li><li><p>Methods</p><ul><li>getRadius()<br>获取半径</li><li>hasPointSector(x,y)<br>检查x，y这个点是否在定义的弧扇形内 x，y为屏幕坐标系</li><li>Radius()<br>确定弧的当前半径</li><li>value<br>返回 弧长 </li><li>其他<br>借用其他元素的方法：JXG.Curve、JXG.GeometryElement</li></ul></li><li><p>事件<br>借用其他元素的事件：JXG.GeometryElement</p></li></ul><h2 id="Arraw-箭头-JXG-JXG-GeometryElement-gt-JXG-Line-gt-Arraw"><a href="#Arraw-箭头-JXG-JXG-GeometryElement-gt-JXG-Line-gt-Arraw" class="headerlink" title="Arraw 箭头 JXG.JXG.GeometryElement -&gt; JXG.Line -&gt; Arraw"></a>Arraw 箭头 JXG.JXG.GeometryElement -&gt; JXG.Line -&gt; Arraw</h2><p>  Defined in line.js<br>  Extends JXG.line</p><ul><li><p>param array<br>point1—JXG.Point|array<br>point2—JXG.Point|array<br>或者<br>a——–number<br>b——–number<br>c——–number<br>a<em>x + b</em>y + c*z = 0 </p></li><li><p>example</p><pre><code class="javascript">// Create an arrow providing two points.var p1 = board.create(&#39;point&#39;, [4.5, 2.0]);var p2 = board.create(&#39;point&#39;, [1.0, 1.0]);var l1 = board.create(&#39;arrow&#39;, [p1, p2]);</code></pre><p>两点确定一条有方向的线  JXG.GeometryElement -&gt; JXG.line -&gt; Line -&gt; parallel -&gt; Arrowparallel</p></li><li><p>Attributes：<br>借用其他元素的属性：JXG.GeometryElement</p></li><li><p>Fields<br>借用其他元素的字段：JXG.Line</p></li><li><p>Methods<br>借用其他元素的方法：JXG.Line、JXG.GeometryElement </p></li><li><p>Events<br>借用其他元素的事件：JXG.GeometryElement </p></li></ul><h2 id="Arrowparallel-平行箭头-JXG-GeometryElement-gt-JXG-Line-gt-Line-gt-Parallel-gt-Arrowparallel"><a href="#Arrowparallel-平行箭头-JXG-GeometryElement-gt-JXG-Line-gt-Line-gt-Parallel-gt-Arrowparallel" class="headerlink" title="Arrowparallel 平行箭头 JXG.GeometryElement -&gt; JXG.Line -&gt; Line -&gt; Parallel -&gt; Arrowparallel"></a>Arrowparallel 平行箭头 JXG.GeometryElement -&gt; JXG.Line -&gt; Line -&gt; Parallel -&gt; Arrowparallel</h2><p>  Defined in composition.js<br>  Extends Parallel<br>  这个元素没有构造器，需要通过 JXG.Board#create -&gt; type:’Arrowparallel’创建</p><ul><li><p>param array<br>l—-JXG.Line<br>p—-JXG.Point</p><p>所构建的箭包含P和具有相同的斜率为l</p></li><li><p>example</p><pre><code class="javascript">// Create a parallelvar p1 = board.create(&#39;point&#39;, [0.0, 2.0]);var p2 = board.create(&#39;point&#39;, [2.0, 1.0]);var l1 = board.create(&#39;line&#39;, [p1, p2]);var p3 = board.create(&#39;point&#39;, [3.0, 3.0]);var pl1 = board.create(&#39;arrowparallel&#39;, [l1, p3]);</code></pre></li><li><p>Attributes：<br>借用其他元素的属性：Parallel、Line、JXG.GeometryElement</p></li><li><p>Fields<br>借用其他元素的字段：JXG.Line、JXG.GeometryElement</p></li><li><p>Methods<br>借用其他元素的方法：JXG.Line、JXG.GeometryElement</p></li><li><p>Events<br>借用其他元素的事件：JXG.GeometryElement </p></li></ul><h2 id="Axis-轴-JXG-GeometryElement-gt-JXG-Line-gt-Axis"><a href="#Axis-轴-JXG-GeometryElement-gt-JXG-Line-gt-Axis" class="headerlink" title="Axis 轴 JXG.GeometryElement -&gt; JXG.Line -&gt; Axis"></a>Axis 轴 JXG.GeometryElement -&gt; JXG.Line -&gt; Axis</h2><p>  Defined in line.js<br>  Extends JXG.Line<br>  通过JXG.Board#Create type：’axis’ </p><ul><li><p>param array<br>point1—-JXG.Line|array<br>point2—-JXG.Line|array<br>或者<br>a—-number<br>b—-number<br>c—-number<br>a<em>x+b</em>y+c*c=0</p></li><li><p>example</p><pre><code class="javascript">// Create an axis providing two coord pairs.var l1 = board.create(&#39;axis&#39;, [[0.0, 1.0], [1.0, 1.3]]);</code></pre></li><li><p>Attributes</p><ul><li>label<br>轴的标签</li><li>point1<br>轴的第一个点</li><li>point2<br>轴的第二个点</li><li>ticks<br>轴的记号</li><li>其他<br>借用其他元素的属性：JXG.GeometryElement</li></ul></li><li><p>Fields</p><ul><li>defaultTicks<br>附在轴上的记号</li><li>其他<br>借用其他元素的字段：JXG.Line</li></ul></li><li><p>Methods<br>借用其他元素的方法：JXG.Line</p></li><li><p>Events<br>借用其他元素的事件：JXG.GeometryElement</p></li></ul><h2 id="Bisector-二等分物（数-二等分线）-JXG-GeometryElement-gt-JXG-Line-gt-Bisector"><a href="#Bisector-二等分物（数-二等分线）-JXG-GeometryElement-gt-JXG-Line-gt-Bisector" class="headerlink" title="Bisector 二等分物（数 二等分线） JXG.GeometryElement -&gt; JXG.Line -&gt; Bisector"></a>Bisector 二等分物（数 二等分线） JXG.GeometryElement -&gt; JXG.Line -&gt; Bisector</h2><p>  Defined in composition.js<br>  Extends JXG.Line<br>  这个元素没有构造函数 通过JXG.Board#create type：’bisector’创建</p><ul><li><p>example</p><pre><code class="javascript">var p1 = board.create(&#39;point&#39;, [6.0, 4.0]);var p2 = board.create(&#39;point&#39;, [3.0, 2.0]);var p3 = board.create(&#39;point&#39;, [1.0, 7.0]);var bi1 = board.create(&#39;bisector&#39;, [p1, p2, p3]);</code></pre></li><li><p>Attributes</p><ul><li>point<br>平分线的辅助点</li><li>其他<br>借用其他元素的属性：JXG.GeometryElement</li></ul></li><li><p>Fields<br>借用其他元素的属性：JXG.Line</p></li><li><p>Methods<br>借用其他元素的属性：JXG.Line、JXG.GeometryElement</p></li><li><p>Events<br>借用其他元素的事件：JXG.GeometryElement</p></li></ul><h2 id="Bisectorlines-等分线-JXG-Composition-gt-Bisector"><a href="#Bisectorlines-等分线-JXG-Composition-gt-Bisector" class="headerlink" title="Bisectorlines 等分线 JXG.Composition -&gt; Bisector"></a>Bisectorlines 等分线 JXG.Composition -&gt; Bisector</h2><p>  Defined in composition.js<br>  Extends JXG.Composition</p><ul><li><p>param array<br>l1—-JXG.line<br>l2—-JXG.line<br>throws: 如果不能由踢狗对象（两条线）构造会抛出一个异常</p></li><li><p>example</p><pre><code class="javascript">var p1 = board.create(&#39;point&#39;, [6.0, 4.0]);var p2 = board.create(&#39;point&#39;, [3.0, 2.0]);var p3 = board.create(&#39;point&#39;, [1.0, 7.0]);var p4 = board.create(&#39;point&#39;, [3.0, 0.0]);var l1 = board.create(&#39;line&#39;, [p1, p2]);var l2 = board.create(&#39;line&#39;, [p3, p4]);var bi1 = board.create(&#39;bisectorlines&#39;, [l1, l2]);</code></pre></li><li><p>Attributes</p><ul><li>line1<br>第一条线</li><li>line2<br>第二条线</li><li>其他<br>借用其他元素的属性：JXG.Composition </li></ul></li><li><p>Fields</p></li><li><p>Methods</p></li><li><p>Events<br>借用其他元素：JXG.Composition</p></li></ul><h2 id="button-按钮-JXG-GeometryElement-JXG-CoordsElement-gt-JXG-Text-gt-Text-gt-Button"><a href="#button-按钮-JXG-GeometryElement-JXG-CoordsElement-gt-JXG-Text-gt-Text-gt-Button" class="headerlink" title="button 按钮 JXG.GeometryElement,JXG.CoordsElement -&gt; JXG.Text -&gt; Text -&gt; Button"></a>button 按钮 JXG.GeometryElement,JXG.CoordsElement -&gt; JXG.Text -&gt; Text -&gt; Button</h2><p>  Defined button.js<br>  Extends Text<br>  无直接构造器 需要通过JXG.Board#create type:’button’创建</p><ul><li><p>param array<br> x——–number | function<br> y——–number | function<br> label—-label<br> handle—function<br> ps:<br> X和Y是文本框的左下角的坐标。文本的位置是固定的，<br> X和Y是数字。如果X或Y是函数，则该位置是可变的。<br> label 按钮里的内容 string<br> handler optional 按钮按下的时候回调</p></li><li><p>example</p><pre><code class="javascript">var p = board.create(&#39;point&#39;, [0.5, 0.5], {id: &#39;p1&#39;});// Create a button element at position [1,2].var button1 = board.create(&#39;button&#39;, [1, 2, &#39;Change Y with JavaScript&#39;, function() {    p.moveTo([p.X(), p.Y() + 0.5], 100);}], {});// Create a button element at position [1,4].var button2 = board.create(&#39;button&#39;, [1, 4, &#39;Change Y with JessieCode&#39;,    &quot;$(&#39;p1&#39;).Y = $(&#39;p1&#39;).Y() - 0.5;&quot;], {});</code></pre></li><li><p>Attributes</p><ul><li>disabled<br>HTML Button ‘disabled’  default:false</li><li>其他<br>借用其他元素的属性：JXG.Text、JXG.GeometryElement、JXG.CoordsElement</li></ul></li><li><p>Fields<br>借用其他元素的字段：JXG.GeometryElement</p></li><li><p>Methods<br>借用其他元素的方法：JXG.Text、JXG.Text、JXG.CoordsElement</p></li><li><p>Events<br>借用其他元素的事件：JXG.GeometryElement</p></li></ul><h2 id="Checkbox-多选框-JXG-GeometryElement-JXG-CoordsElement-gt-JXG-Text-gt-Text-gt-Checkbox"><a href="#Checkbox-多选框-JXG-GeometryElement-JXG-CoordsElement-gt-JXG-Text-gt-Text-gt-Checkbox" class="headerlink" title="Checkbox 多选框 JXG.GeometryElement,JXG.CoordsElement -&gt; JXG.Text -&gt; Text -&gt; Checkbox"></a>Checkbox 多选框 JXG.GeometryElement,JXG.CoordsElement -&gt; JXG.Text -&gt; Text -&gt; Checkbox</h2><p>  Defined in checkbox.js<br>  Extends Text<br>  通过JXG.Board#create type:’checkbox’创建</p><ul><li><p>param<br>x———文本的左下角 x y 若为函数则位置可变<br>y———文本的左下角<br>label—–文本显示</p></li><li><p>example</p><pre><code class="javascript">// Create a checkbox element at position [0,3].var checkbox = board.create(&#39;checkbox&#39;, [0, 3, &#39;Change Y&#39;], {});var p = board.create(&#39;point&#39;, [  function(){ return 0.5;}, // X-coordinate  function() {      y = 0.5;      if (checkbox.Value()) {          y += 0.5;      }      return y;  }]);</code></pre><pre><code class="javascript">var checkbox = board.create(&#39;checkbox&#39;, [0, 4, &#39;Click me&#39;]),         p = board.create(&#39;point&#39;, [1, 1]);JXG.addEvent(checkbox.rendNodeCheckbox, &#39;change&#39;, function() {  if (this.Value()) {      p.moveTo([4, 1]);  } else {      p.moveTo([1, 1]);  }}, checkbox);</code></pre></li><li><p>Attributes</p><ul><li>disabled<br>HTML Button ‘disabled’  default:false</li><li>其他<br>借用其他元素的属性：JXG.Text、JXG.GeometryElement、JXG.CoordsElement</li></ul></li><li><p>Fields<br>借用其他元素的字段：JXG.GeometryElement、JXG.CoordsElement</p></li><li><p>Methods<br>借用其他元素的方法：JXG.Text、JXG.Text、JXG.CoordsElement</p></li><li><p>Events<br>借用其他元素的事件：JXG.GeometryElement</p></li></ul><h2 id="Circle-圆-JXG-GeometryElement-gt-JXG-circle-gt-Circle"><a href="#Circle-圆-JXG-GeometryElement-gt-JXG-circle-gt-Circle" class="headerlink" title="Circle 圆   JXG.GeometryElement -&gt; JXG.circle -&gt; Circle"></a>Circle 圆   JXG.GeometryElement -&gt; JXG.circle -&gt; Circle</h2><pre><code>Defined in circle.jsExtends JXG.circleJXG.Board#create type:&#39;circle&#39;* paramcenter----JXG.Point 圆心radius----number|JXG.Point|JXG.Line|JXG.Circle 半径：可为点或线或圆* example```javascript// Create a circle providing two pointsvar p1 = board.create(&#39;point&#39;, [2.0, 2.0]),    p2 = board.create(&#39;point&#39;, [2.0, 0.0]),    c1 = board.create(&#39;circle&#39;, [p1, p2]);// Create another circle using the above circlevar p3 = board.create(&#39;point&#39;, [3.0, 2.0]),    c2 = board.create(&#39;circle&#39;, [p3, c1]);``````javascript// Create a circle providing two pointsvar p1 = board.create(&#39;point&#39;, [2.0, 2.0]),    c1 = board.create(&#39;circle&#39;, [p1, 3]);// Create another circle using the above circlevar c2 = board.create(&#39;circle&#39;, [function() { return [p1.X(), p1.Y() + 1];}, function() { return c1.Radius(); }]);```* Attributes  - center  中心点  - hasInnerPoints  如果为true 鼠标移动到点内会触发hasPoint  - label  圆心的标签  - point  中心点 与center 有什么不同？  - 其他  借用其他元素的属性：JXG.GeometryElement* Fields借用其他元素的字段：JXG.Circle* Methods借用其他元素的方法：JXG.Circle、JXG.GeometryElement* Events借用其他元素的事件：JXG.GeometryElement</code></pre><h2 id="Circumcenter-外心（数学三角形中垂线交点）-JXG-GeometryElement-JXG-CoordsElement-gt-JXG-Point-gt-Circumcenter"><a href="#Circumcenter-外心（数学三角形中垂线交点）-JXG-GeometryElement-JXG-CoordsElement-gt-JXG-Point-gt-Circumcenter" class="headerlink" title="Circumcenter 外心（数学三角形中垂线交点） JXG.GeometryElement,JXG.CoordsElement -&gt; JXG.Point -&gt; Circumcenter"></a>Circumcenter 外心（数学三角形中垂线交点） JXG.GeometryElement,JXG.CoordsElement -&gt; JXG.Point -&gt; Circumcenter</h2><p>  Defined in composition.js<br>  Extends JXG.point<br>  JXG.Board#create type:’circumcenter’</p><ul><li><p>param<br>p1—-JXG.Point<br>p2—-JXG.Point<br>p3—-JXG.Point</p></li><li><p>example</p><pre><code class="javascript">var p1 = board.create(&#39;point&#39;, [0.0, 2.0]);var p2 = board.create(&#39;point&#39;, [2.0, 1.0]);var p3 = board.create(&#39;point&#39;, [3.0, 3.0]);var cc1 = board.create(&#39;circumcenter&#39;, [p1, p2, p3]);</code></pre></li><li><p>Attributes<br>借用其他元素的属性：JXG.GeometryElement</p></li><li><p>Fields<br>借用其他元素的字段：JXG.GeometryElement</p></li><li><p>Methods<br>借用其他元素的方法：JXG.point、JXG.GeometryElement、JXG.CoordsElement</p></li><li><p>Events<br>借用其他元素的事件：JXG.GeometryElement</p></li></ul><h2 id="Circumcircle-外接圆-JXG-GeometryElement-gt-JXG-Circle-gt-circumcircle"><a href="#Circumcircle-外接圆-JXG-GeometryElement-gt-JXG-Circle-gt-circumcircle" class="headerlink" title="Circumcircle 外接圆 JXG.GeometryElement -&gt; JXG.Circle -&gt; circumcircle"></a>Circumcircle 外接圆 JXG.GeometryElement -&gt; JXG.Circle -&gt; circumcircle</h2><p>  Defined in composition.js<br>  Extends JXG.Circle</p><ul><li><p>param<br>p1—-JXG.Point  圆上的三点<br>p2—-JXG.Point<br>p3—-JXG.Point</p></li><li><p>example</p><pre><code class="javascript">var p1 = board.create(&#39;point&#39;, [0.0, 2.0]);var p2 = board.create(&#39;point&#39;, [2.0, 1.0]);var p3 = board.create(&#39;point&#39;, [3.0, 3.0]);var cc1 = board.create(&#39;circumcircle&#39;, [p1, p2, p3]);</code></pre></li><li><p>Attributes</p><ul><li>center<br>圆心</li><li>其他<br>借用其他元素的属性：JXG.GeometryElement</li></ul></li><li><p>Fields<br>借用其他元素的字段：JXG.Circle、JXG.GeometryElement</p></li><li><p>Methods<br>借用其他元素的方法：JXG.Circle、JXG.GeometryElement</p></li><li><p>Events<br>借用其他元素的事件：JXG.GeometryElement</p></li></ul><h2 id="CircumcircleArc-外接圆弧-JXG-GeometryElement-gt-JXG-Curve-gt-Curve-gt-Arc-gt-circumcircleArc"><a href="#CircumcircleArc-外接圆弧-JXG-GeometryElement-gt-JXG-Curve-gt-Curve-gt-Arc-gt-circumcircleArc" class="headerlink" title="CircumcircleArc 外接圆弧 JXG.GeometryElement -&gt; JXG.Curve -&gt; Curve -&gt; Arc -&gt; circumcircleArc"></a>CircumcircleArc 外接圆弧 JXG.GeometryElement -&gt; JXG.Curve -&gt; Curve -&gt; Arc -&gt; circumcircleArc</h2><p>  Defined in arc.js<br>  Extends Arc<br>  JXG.Board#create type:’circumcirclearc’ </p><ul><li><p>param<br>p1—-JXG.Point  圆上的三点<br>p2—-JXG.Point<br>p3—-JXG.Point</p></li><li><p>example</p><pre><code class="javascript">var p1 = board.create(&#39;point&#39;, [0.0, 2.0]);var p2 = board.create(&#39;point&#39;, [2.0, 1.0]);var p3 = board.create(&#39;point&#39;, [3.0, 3.0]);var cc1 = board.create(&#39;circumcircle&#39;, [p1, p2, p3]);</code></pre><p>弧从p1-&gt;p2-&gt;p3</p></li><li><p>Attributes</p><ul><li>center<br>圆心</li><li>其他<br>借用其他元素的属性：JXG.GeometryElement</li></ul></li><li><p>Fields<br>借用其他元素的字段：JXG.Circle、JXG.GeometryElement</p></li><li><p>Methods<br>借用其他元素的方法：JXG.Arc、JXG.Curve、JXG.GeometryElement</p></li><li><p>Events<br>借用其他元素的事件：JXG.GeometryElement  </p></li></ul><h2 id="Conic-圆锥曲线-JXG-GeometryElement-gt-JXG-Curve-gt-Conic"><a href="#Conic-圆锥曲线-JXG-GeometryElement-gt-JXG-Curve-gt-Conic" class="headerlink" title="Conic 圆锥曲线  JXG.GeometryElement -&gt; JXG.Curve -&gt; Conic"></a>Conic 圆锥曲线  JXG.GeometryElement -&gt; JXG.Curve -&gt; Conic</h2><p>  Defined in conic.js<br>  Extends JXG.Curve<br>  JXG.Borad#create type:’conic’</p><ul><li><p>param<br>a—-JXG.Point|array<br>b—-JXG.Point|array<br>c—-JXG.Point|array<br>d—-JXG.Point|array<br>e—-JXG.Point|array<br>或者<br>a00—-number<br>a11—-number<br>a22—-number<br>a01—-number<br>a12—-number<br>a22—-number</p></li><li><p>example</p><pre><code class="javascript">// Create a conic section through the points A, B, C, D, and E.var A = board.create(&#39;point&#39;, [1,5]);var B = board.create(&#39;point&#39;, [1,2]);var C = board.create(&#39;point&#39;, [2,0]);var D = board.create(&#39;point&#39;, [0,0]);var E = board.create(&#39;point&#39;, [-1,5]);var conic = board.create(&#39;conic&#39;,[A,B,C,D,E]);</code></pre></li><li><p>Attributes</p><ul><li>foci<br>??? 焦点</li><li>其他<br>借用其他元素的属性：JXG.GeometryElement</li></ul></li><li><p>Fields<br>借用其他元素的字段：JXG.Curve、JXG.GeometryElement</p></li><li><p>Methods<br>借用其他元素的方法：JXG.Curve、JXG.GeometryElement</p></li><li><p>Events<br>借用其他元素的事件：JXG.GeometryElement  </p></li></ul><h2 id="Curve-曲线-JXG-GeometryElement-gt-JXG-Curve-gt-Curve"><a href="#Curve-曲线-JXG-GeometryElement-gt-JXG-Curve-gt-Curve" class="headerlink" title="Curve 曲线 JXG.GeometryElement -&gt; JXG.Curve -&gt; Curve"></a>Curve 曲线 JXG.GeometryElement -&gt; JXG.Curve -&gt; Curve</h2><p>  Defined in Curve.js<br>  Extends JXG.Curve<br>  JXG.Board#create type:’curve’</p><ul><li>param<br>Parametric Curve 参数曲线<br>x—-function|number<br>y—-function|number<br>a—-function|number optional<br>b—-function|number optional<br>或<br>Data plots 数据图<br>x—-array<br>y—-array|function|number<br>或<br>Polar Curve  极坐标曲线<br>r——–function<br>offset—function|array|number<br>a——–function|number default:-10<br>b——–function|number default:10 </li></ul><ul><li><p>example</p><pre><code class="javascript">// Parametric curve// Create a curve of the form (t-sin(t), 1-cos(t), i.e.// the cycloid curve.var graph = board.create(&#39;curve&#39;,                   [function(t){ return t-Math.sin(t);},                    function(t){ return 1-Math.cos(t);},                    0, 2*Math.PI]                );</code></pre><pre><code class="javascript">// Data plots// Connect a set of points given by coordinates with dashed line segments.// The x- and y-coordinates of the points are given in two separate// arrays.var x = [0,1,2,3,4,5,6,7,8,9];var y = [9.2,1.3,7.2,-1.2,4.0,5.3,0.2,6.5,1.1,0.0];var graph = board.create(&#39;curve&#39;, [x,y], {dash:2});</code></pre><pre><code class="javascript">// Polar plot// Create a curve with the equation r(phi)= a*(1+phi), i.e.// a cardioid.var a = board.create(&#39;slider&#39;,[[0,2],[2,2],[0,1,2]]);var graph = board.create(&#39;curve&#39;,                   [function(phi){ return a.Value()*(1-Math.cos(phi));},                    [1,0],                    0, 2*Math.PI]                );</code></pre><pre><code class="javascript">// Draggable Bezier curvevar col, p, c;col = &#39;blue&#39;;p = [];p.push(board.create(&#39;point&#39;,[-2, -1 ], {size: 5, strokeColor:col, fillColor:col}));p.push(board.create(&#39;point&#39;,[1, 2.5 ], {size: 5, strokeColor:col, fillColor:col}));p.push(board.create(&#39;point&#39;,[-1, -2.5 ], {size: 5, strokeColor:col, fillColor:col}));p.push(board.create(&#39;point&#39;,[2, -2], {size: 5, strokeColor:col, fillColor:col}));c = board.create(&#39;curve&#39;, JXG.Math.Numerics.bezier(p),          {strokeColor:&#39;red&#39;, name:&quot;curve&quot;, strokeWidth:5, fixed: false}); // Draggable curvec.addParents(p);</code></pre></li><li><p>Attributes</p><ul><li>curveType<br>在JXG.Curve#generateTerm中设置，在JXG.Curve#updateCurve中使用值：string<ul><li>none</li><li>plot:Data plot</li><li>parameter:无法区分是功能函数还是参数曲线</li><li>functiongraph：图形函数</li><li>polar：极线</li><li>implicit：(not yet)<br>只有parameter和plot 可以直接设置，Polar只能通过JXG.GeometryElement#setAttribute</li></ul></li><li>doAdvancedPlot<br>如果为true，使用二分递归法 default:true</li><li>doAdvancedPlotOld<br>如果为true，使用Gillam and Hohenwarter算法 default：false</li><li>handDrawing<br>曲线的数据点相连不是用直线而是Bezier曲线 default:false</li><li>numberPointsHigh<br>用于通过up events绘制曲线触发以防Curve#doAdvancedPlot为false default：1600</li><li>numberPointsLow<br>用于通过move events绘制曲线触发以防Curve#doAdvancedPlot为false default：400</li><li>RDPsmoothing<br>采用Ramer Douglas Peuker平滑 default:false</li><li>其他<br>借用其他元素的属性：JXG.GeometryElement</li></ul></li><li><p>Fields<br>借用其他元素的字段：JXG.Curve、JXG.GeometryElement</p></li><li><p>Methods<br>JXG.Curve、JXG.GeometryElement</p></li><li><p>Events<br>借用其他元素的事件：JXG.GeometryElement</p></li></ul><h2 id="Ellipse-椭圆-JXG-GeometryElement-gt-JXG-Curve-gt-Conic-gt-Ellipse"><a href="#Ellipse-椭圆-JXG-GeometryElement-gt-JXG-Curve-gt-Conic-gt-Ellipse" class="headerlink" title="Ellipse 椭圆  JXG.GeometryElement -&gt; JXG.Curve -&gt; Conic -&gt; Ellipse"></a>Ellipse 椭圆  JXG.GeometryElement -&gt; JXG.Curve -&gt; Conic -&gt; Ellipse</h2><p>  Defined in conic.js<br>  Extends Conic<br>  JXG.Board#create type:’ellipse’</p><ul><li><p>param<br>point1—-JXG.Point|array<br>point2—-JXG.Point|array<br>point3—-JXG.Point|array<br>或者<br>point1—-JXG.Point|array<br>point2—-JXG.Point|array<br>number—-function |number 主轴的长度  可以参数第四和第五定义曲线长度默认值是-PI到PI</p></li><li><p>example</p><pre><code class="javascript">// Create an Ellipse by three pointsvar A = board.create(&#39;point&#39;, [-1,4]);var B = board.create(&#39;point&#39;, [-1,-4]);var C = board.create(&#39;point&#39;, [1,1]);var el = board.create(&#39;ellipse&#39;,[A,B,C]);  </code></pre><p>A B为椭圆焦点 C为椭圆上一点</p></li><li><p>Attributes<br>借用其他元素的属性：JXG.GeometryElement</p></li><li><p>Fields<br>借用其他元素的字段：JXG.Curve</p></li><li><p>Methods<br>借用其他元素的方法：JXG.Curve、JXG.GeometryElement</p></li><li><p>Events<br>借用其他元素的事件：JXG.GeometryElement</p></li></ul><h2 id="Functiongraph-图形函数"><a href="#Functiongraph-图形函数" class="headerlink" title="Functiongraph 图形函数"></a>Functiongraph 图形函数</h2><h2 id="Glider-（滑翔机）点-JXG-GeometryElement-JXG-CoordsElement-gt-JXG-Point-gt-Glider"><a href="#Glider-（滑翔机）点-JXG-GeometryElement-JXG-CoordsElement-gt-JXG-Point-gt-Glider" class="headerlink" title="Glider （滑翔机）点 JXG.GeometryElement,JXG.CoordsElement -&gt; JXG.Point -&gt; Glider"></a>Glider （滑翔机）点 JXG.GeometryElement,JXG.CoordsElement -&gt; JXG.Point -&gt; Glider</h2><p>  Defined in point.js<br>  Extends JXG.Point<br>  JXG.Board#Create type:’glider’</p><ul><li><p>param<br>z————–number optional<br>x————–number optional<br>y————–number optional<br>GliderObject—JXG.GeometryElement</p></li><li><p>example</p><pre><code class="JavaScript">// Create a glider with user defined coordinates. If the coordinates are not on// the circle (like in this case) the point will be projected onto the circle.var p1 = board.create(&#39;point&#39;, [2.0, 2.0]);var c1 = board.create(&#39;circle&#39;, [p1, 2.0]);var p2 = board.create(&#39;glider&#39;, [2.0, 1.5, c1]);</code></pre><pre><code class="JavaScript">// Create a glider with default coordinates (1,0,0). Same premises as above.var p1 = board.create(&#39;point&#39;, [2.0, 2.0]);var c1 = board.create(&#39;circle&#39;, [p1, 2.0]);var p2 = board.create(&#39;glider&#39;, [c1]);</code></pre></li><li><p>Attributes<br>借用其他元素的属性：JXG.GeometryElement</p></li><li><p>Fields</p><ul><li>sliderObject<br>通过 JXG.Point#makeGlider 设置</li><li>其他<br>借用其他元素的字段：JXG.GeometryElement、JXG.CoordsElement</li></ul></li><li><p>Methods</p><ul><li>startAnimation(direction,stepCount)<br>animate the point<br>direction is animated +1 or -1—-number<br>stepCount steps               —-number</li><li>stopAnimation()<br>Stop animation</li><li>其他<br>借用其他元素的方法：JXG.Point、JXG.GeometryElement、JXG.CoordsElement</li></ul></li><li><p>Events<br>借用其他元素的方法：JXG.GeometryElement</p><h2 id="Grid-网格-JXG-GeometryElement-gt-JXG-Curve-gt-Grid"><a href="#Grid-网格-JXG-GeometryElement-gt-JXG-Curve-gt-Grid" class="headerlink" title="Grid 网格 JXG.GeometryElement -&gt; JXG.Curve -&gt; Grid"></a>Grid 网格 JXG.GeometryElement -&gt; JXG.Curve -&gt; Grid</h2><p>Defined in composition.js<br>Extends JXG.Curve<br>JXG.Board#Create type:’grid’</p><pre><code class="javascript">grid = board.create(&#39;gird&#39;,[])</code></pre></li></ul><h2 id="Group-svg-g元素-JXG-Group-gt-Group"><a href="#Group-svg-g元素-JXG-Group-gt-Group" class="headerlink" title="Group svg g元素 JXG.Group -&gt; Group"></a>Group svg g元素 JXG.Group -&gt; Group</h2><p>  Defined in composition.js<br>  Extends JXG.Curve<br>  JXG.Board#create type:’group’</p><ul><li><p>param<br>board——–JXG.Board 在board上的点<br>parents——array     点的组合<br>Attributes—object    视觉特性（未使用的）</p></li><li><p>example</p><pre><code class="javascript">// Create some free points. e.g. A, B, C, D// Create a groupvar p, col, g;col = &#39;blue&#39;;p = [];p.push(board.create(&#39;point&#39;,[-2, -1 ], {size: 5, strokeColor:col, fillColor:col}));p.push(board.create(&#39;point&#39;,[2, -1 ], {size: 5, strokeColor:col, fillColor:col}));p.push(board.create(&#39;point&#39;,[2, 1 ], {size: 5, strokeColor:col, fillColor:col}));p.push(board.create(&#39;point&#39;,[-2, 1], {size: 5, strokeColor:col, fillColor:col}));g = board.create(&#39;group&#39;, p);</code></pre><pre><code class="javascript">// Create some free points. e.g. A, B, C, D// Create a group// If the points define a polygon and the polygon has the attribute hasInnerPoints:true,// the polygon can be dragged around.// hasInnerPoints 鼠标移上去 haspoint==true 表示可以拖动这个元素var p, col, pol, g;col = &#39;blue&#39;;p = [];p.push(board.create(&#39;point&#39;,[-2, -1 ], {size: 5, strokeColor:col, fillColor:col}));p.push(board.create(&#39;point&#39;,[2, -1 ], {size: 5, strokeColor:col, fillColor:col}));p.push(board.create(&#39;point&#39;,[2, 1 ], {size: 5, strokeColor:col, fillColor:col}));p.push(board.create(&#39;point&#39;,[-2, 1], {size: 5, strokeColor:col, fillColor:col}));pol = board.create(&#39;polygon&#39;, p, {hasInnerPoints: true});g = board.create(&#39;group&#39;, p);</code></pre><pre><code class="javascript">// Allow rotations:// Define a center of rotation and declare points of the group as &quot;rotation points&quot;.var p, col, pol, g;col = &#39;blue&#39;;p = [];p.push(board.create(&#39;point&#39;,[-2, -1 ], {size: 5, strokeColor:col, fillColor:col}));p.push(board.create(&#39;point&#39;,[2, -1 ], {size: 5, strokeColor:&#39;red&#39;, fillColor:&#39;red&#39;}));p.push(board.create(&#39;point&#39;,[2, 1 ], {size: 5, strokeColor:&#39;red&#39;, fillColor:&#39;red&#39;}));p.push(board.create(&#39;point&#39;,[-2, 1], {size: 5, strokeColor:col, fillColor:col}));pol = board.create(&#39;polygon&#39;, p, {hasInnerPoints: true});g = board.create(&#39;group&#39;, p);g.setRotationCenter(p[0]);g.setRotationPoints([p[1], p[2]]);</code></pre><pre><code class="javascript">// Allow rotations:// As rotation center, arbitrary points, coordinate arrays,// or functions returning coordinate arrays can be given.// Another possibility is to use the predefined string &#39;centroid&#39;.// The methods to define the rotation points can be chained.var p, col, pol, g;col = &#39;blue&#39;;p = [];p.push(board.create(&#39;point&#39;,[-2, -1 ], {size: 5, strokeColor:col, fillColor:col}));p.push(board.create(&#39;point&#39;,[2, -1 ], {size: 5, strokeColor:&#39;red&#39;, fillColor:&#39;red&#39;}));p.push(board.create(&#39;point&#39;,[2, 1 ], {size: 5, strokeColor:&#39;red&#39;, fillColor:&#39;red&#39;}));p.push(board.create(&#39;point&#39;,[-2, 1], {size: 5, strokeColor:col, fillColor:col}));pol = board.create(&#39;polygon&#39;, p, {hasInnerPoints: true});g = board.create(&#39;group&#39;, p).setRotationCenter(&#39;centroid&#39;).setRotationPoints([p[1], p[2]]);</code></pre><pre><code class="javascript">// Allow scaling:// As for rotation one can declare points of the group to trigger a scaling operation.// For this, one has to define a scaleCenter, in analogy to rotations.// Here, the yellow  point enables scaling, the red point a rotation.var p, col, pol, g;col = &#39;blue&#39;;p = [];p.push(board.create(&#39;point&#39;,[-2, -1 ], {size: 5, strokeColor:col, fillColor:col}));p.push(board.create(&#39;point&#39;,[2, -1 ], {size: 5, strokeColor:&#39;yellow&#39;, fillColor:&#39;yellow&#39;}));p.push(board.create(&#39;point&#39;,[2, 1 ], {size: 5, strokeColor:&#39;red&#39;, fillColor:&#39;red&#39;}));p.push(board.create(&#39;point&#39;,[-2, 1], {size: 5, strokeColor:col, fillColor:col}));pol = board.create(&#39;polygon&#39;, p, {hasInnerPoints: true});g = board.create(&#39;group&#39;, p).setRotationCenter(&#39;centroid&#39;).setRotationPoints([p[2]]);g.setScaleCenter(p[0]).setScalePoints(p[1]);</code></pre><pre><code class="javascript">// Allow Translations:// By default, every point of a group triggers a translation.// There may be situations, when this is not wanted.// In this example, E triggers nothing, but itself is rotation center// and is translated, if other points are moved around.var p, q, col, pol, g;col = &#39;blue&#39;;p = [];p.push(board.create(&#39;point&#39;,[-2, -1 ], {size: 5, strokeColor:col, fillColor:col}));p.push(board.create(&#39;point&#39;,[2, -1 ], {size: 5, strokeColor:&#39;yellow&#39;, fillColor:&#39;yellow&#39;}));p.push(board.create(&#39;point&#39;,[2, 1 ], {size: 5, strokeColor:&#39;red&#39;, fillColor:&#39;red&#39;}));p.push(board.create(&#39;point&#39;,[-2, 1], {size: 5, strokeColor:col, fillColor:col}));q = board.create(&#39;point&#39;,[0, 0], {size: 5, strokeColor:col, fillColor:col});pol = board.create(&#39;polygon&#39;, p, {hasInnerPoints: true});g = board.create(&#39;group&#39;, p.concat(q)).setRotationCenter(&#39;centroid&#39;).setRotationPoints([p[2]]);g.setScaleCenter(p[0]).setScalePoints(p[1]);g.removeTranslationPoint(q);</code></pre></li><li><p>Attributes</p></li><li><p>Fields</p></li><li><p>Methods<br>借用其他元素：JXG.Group</p></li></ul><h2 id="Hatch"><a href="#Hatch" class="headerlink" title="Hatch"></a>Hatch</h2><h2 id="Hyperbola-双曲线-JXG-GeometryElement-gt-JXG-Curve-gt-Conic-gt-Hyperbola"><a href="#Hyperbola-双曲线-JXG-GeometryElement-gt-JXG-Curve-gt-Conic-gt-Hyperbola" class="headerlink" title="Hyperbola 双曲线 JXG.GeometryElement -&gt; JXG.Curve -&gt; Conic -&gt; Hyperbola"></a>Hyperbola 双曲线 JXG.GeometryElement -&gt; JXG.Curve -&gt; Conic -&gt; Hyperbola</h2><p>  Define in conic.js<br>  Extends Conic<br>  JXG.Board#create type:’hypebola’</p><ul><li><p>param<br>point1—-JXG.Point|array<br>point2—-JXG.Point|array<br>point3—-JXG.Point|array<br>或<br>point1—-JXG.Point|array<br>point1—-JXG.Point|array<br>number—-function |number</p></li><li><p>example</p><pre><code class="javascript">// Create an Hyperbola by three pointsvar A = board.create(&#39;point&#39;, [-1,4]);var B = board.create(&#39;point&#39;, [-1,-4]);var C = board.create(&#39;point&#39;, [1,1]);var el = board.create(&#39;hyperbola&#39;,[A,B,C]);</code></pre></li></ul><h2 id="Image-图片-JXG-GeometryElement-gt-JXG-Image-gt-Image"><a href="#Image-图片-JXG-GeometryElement-gt-JXG-Image-gt-Image" class="headerlink" title="Image 图片 JXG.GeometryElement -&gt; JXG.Image -&gt; Image"></a>Image 图片 JXG.GeometryElement -&gt; JXG.Image -&gt; Image</h2><p>  Define in JXG.Image<br>  Extends JXG.Image<br>  JXG.Board#create type:’image’</p><ul><li>param<br>url—-string|function<br>coords-array<br>size—array</li><li>example<pre><code class="javascript">var im = board.create(&#39;image&#39;, [&#39;http://jsxgraph.uni-bayreuth.de/jsxgraph/distrib/images/uccellino.jpg&#39;, [-3,-2], [3,3]]);</code></pre></li><li>Attributes <ul><li>attractor<br>List of attractor elements. If the distance of the image is less than attractorDistance the image is made to glider of this element.<br>default:empty</li><li>rotate<br>旋转角度 default:0</li><li>snapSizeX<br>Defines together with Image#snapSizeY the grid the image snaps on to. The image will only snap on integer multiples to snapSizeX in x and snapSizeY in y direction. If this value is equal to or less than 0, it will use the grid displayed by the major ticks of the default ticks of the default x axes of the board.  </li><li>snapSizeY</li><li>其他<br>借用其他元素的属性：JXG.GeometryElement</li></ul></li><li>Fields<br>借用其他元素的字段：JXG.GeometryElement</li><li>Methods<br>借用其他元素的方法：JXG.Image、JXG.GeometryElement、JXG.CoordsElement</li><li>Events<br>借用其他元素的事件：JXG.CoordsElement  </li></ul><h2 id="Incenter-内心，内切圆心-JXG-GeometryElement-JXG-CoordsElement-gt-JXG-Point-gt-Incenter"><a href="#Incenter-内心，内切圆心-JXG-GeometryElement-JXG-CoordsElement-gt-JXG-Point-gt-Incenter" class="headerlink" title="Incenter 内心，内切圆心 JXG.GeometryElement,JXG.CoordsElement -&gt; JXG.Point -&gt; Incenter"></a>Incenter 内心，内切圆心 JXG.GeometryElement,JXG.CoordsElement -&gt; JXG.Point -&gt; Incenter</h2><p>  Defined in composition.js<br>  Extends JXG.Point<br>  JXG.Board#create type:’incenter’</p><ul><li><p>param<br>p1—-JXG.Point<br>p2—-JXG.Point<br>p3—-JXG.Point</p></li><li><p>example</p><pre><code class="javascript">var p1 = board.create(&#39;point&#39;, [0.0, 2.0]);var p2 = board.create(&#39;point&#39;, [2.0, 1.0]);var p3 = board.create(&#39;point&#39;, [3.0, 3.0]);var ic1 = board.create(&#39;incenter&#39;, [p1, p2, p3]);</code></pre></li><li><p>Attributes<br>借用其他元素的属性：JXG.GeometryElement</p></li><li><p>Fields<br>JXG.GeometryElement、JXG.CoordsElement</p></li><li><p>Methods<br>JXG.Point、JXG.GeometryElement</p></li><li><p>Events<br>JXG.GeometryElement</p></li></ul><h2 id="Incircle-内切圆-JXG-GeometryElement-gt-JXG-Circle-gt-Incircle"><a href="#Incircle-内切圆-JXG-GeometryElement-gt-JXG-Circle-gt-Incircle" class="headerlink" title="Incircle 内切圆 JXG.GeometryElement -&gt; JXG.Circle -&gt; Incircle"></a>Incircle 内切圆 JXG.GeometryElement -&gt; JXG.Circle -&gt; Incircle</h2><p>  Defined in composition.js<br>  Extends JXG.Circle<br>  JXG.Board#create type:’Incircle’</p><ul><li><p>param<br>p1—-JXG.Point<br>p2—-JXG.Point<br>p3—-JXG.Point</p><ul><li>example<pre><code class="javascript">var p1 = board.create(&#39;point&#39;, [0.0, 2.0]);var p2 = board.create(&#39;point&#39;, [2.0, 1.0]);var p3 = board.create(&#39;point&#39;, [3.0, 3.0]);</code></pre></li></ul><p>var ic1 = board.create(‘incircle’, [p1, p2, p3]);</p><pre><code>* Attributes借用其他元素的属性：JXG.GeometryElement* FieldsJXG.GeometryElement、JXG.Circle* MethodsJXG.Circle、JXG.GeometryElement* EventsJXG.GeometryElement</code></pre></li></ul><h2 id="Inqueually-线性不等式表示区域-JXG-GeometryElement-gt-JXG-Curve-gt-Inequality"><a href="#Inqueually-线性不等式表示区域-JXG-GeometryElement-gt-JXG-Curve-gt-Inequality" class="headerlink" title="Inqueually 线性不等式表示区域 JXG.GeometryElement -&gt; JXG.Curve -&gt; Inequality"></a>Inqueually 线性不等式表示区域 JXG.GeometryElement -&gt; JXG.Curve -&gt; Inequality</h2><p>  Defined in composition.js<br>  Extends JXG.Curve<br>  JXG.Board#create type:’inequality’</p><ul><li><p>param<br>l—-JXG.Line</p></li><li><p>example </p><pre><code class="javascript">var p = board.create(&#39;point&#39;, [1, 3]),  q = board.create(&#39;point&#39;, [-2, -4]),  l = board.create(&#39;line&#39;, [p, q]),  ineq = board.create(&#39;inequality&#39;, [l]);  ineq = board.create(&#39;inequality&#39;, [l]);</code></pre><pre><code class="javascript">// Plot the inequality //     y &gt;= 2/3 x + 1 // or //     0 &gt;= -3y + 2x +1var l = board.create(&#39;line&#39;, [1, 2, -3]),ineq = board.create(&#39;inequality&#39;, [l], {inverse:true});</code></pre></li><li><p>Attributes</p><ul><li>inverse<br>显示区域 默认为false 显示线的下方区</li></ul></li></ul><h2 id="Input-input标签-提供输入-JXG-GeometryElement-JXG-CoordsElement-gt-JXG-Text-gt-Text-gt-Input"><a href="#Input-input标签-提供输入-JXG-GeometryElement-JXG-CoordsElement-gt-JXG-Text-gt-Text-gt-Input" class="headerlink" title="Input input标签(提供输入) JXG.GeometryElement,JXG.CoordsElement -&gt; JXG.Text -&gt;Text -&gt;Input"></a>Input input标签(提供输入) JXG.GeometryElement,JXG.CoordsElement -&gt; JXG.Text -&gt;Text -&gt;Input</h2><p>  Defined in input.js<br>  Extends Text<br>  JXG.Board#create type:’input’</p><ul><li><p>param<br>x—-number|function<br>y—-number|function<br>value—-string<br>label—-string</p></li><li><p>example</p><pre><code class="javascript">// Create an input element at position [1,4].var input = board.create(&#39;input&#39;, [0, 1, &#39;sin(x)*x&#39;, &#39;f(x)=&#39;], {});var f = board.jc.snippet(input.Value(), true, &#39;x&#39;, false);var graph = board.create(&#39;functiongraph&#39;,[f,     function() {       var c = new JXG.Coords(JXG.COORDS_BY_SCREEN,[0,0],board);       return c.usrCoords[1];     },     function() {       var c = new JXG.Coords(JXG.COORDS_BY_SCREEN,[board.canvasWidth,0],board);       return c.usrCoords[1];     }   ]);board.create(&#39;text&#39;, [1, 3, updateGraph()]);var updateGraph = function() {  graph.Y = board.jc.snippet(input.Value(), true, &#39;x&#39;, false);  graph.updateCurve();  board.update();}  </code></pre></li></ul><h2 id="Integral-给定时间间隔的曲线积分-JXG-GeometryElement-gt-JXG-Curve-gt-Integral"><a href="#Integral-给定时间间隔的曲线积分-JXG-GeometryElement-gt-JXG-Curve-gt-Integral" class="headerlink" title="Integral 给定时间间隔的曲线积分 JXG.GeometryElement -&gt; JXG.Curve -&gt; Integral"></a>Integral 给定时间间隔的曲线积分 JXG.GeometryElement -&gt; JXG.Curve -&gt; Integral</h2><h2 id="Intersection-交叉-JXG-GeometryElement-JXG-CoordsElement-gt-JXG-Point-gt-Intersection"><a href="#Intersection-交叉-JXG-GeometryElement-JXG-CoordsElement-gt-JXG-Point-gt-Intersection" class="headerlink" title="Intersection 交叉 JXG.GeometryElement,JXG.CoordsElement -&gt; JXG.Point -&gt; Intersection"></a>Intersection 交叉 JXG.GeometryElement,JXG.CoordsElement -&gt; JXG.Point -&gt; Intersection</h2><p>  Defined in point.js<br>  Extends JXG.Point<br>  JXG.Board#create type:’Intersection’</p><ul><li><p>param<br>el1—-JXG.Line<br>el2—-JXG.Line<br>i——number  i==0 用正的平方根 i==1 用负的平方根</p></li><li><p>example</p><pre><code class="javascript">// Create an intersection point of circle and linevar p1 = board.create(&#39;point&#39;, [2.0, 2.0]);var c1 = board.create(&#39;circle&#39;, [p1, 2.0]);var p2 = board.create(&#39;point&#39;, [2.0, 2.0]);var p3 = board.create(&#39;point&#39;, [3.0, 2.0]);var l1 = board.create(&#39;line&#39;, [p2, p3]);var i = board.create(&#39;intersection&#39;, [c1, l1, 0]);</code></pre></li></ul><h2 id="Line-线-JXG-GeometryElement-gt-JXG-Line-gt-Line"><a href="#Line-线-JXG-GeometryElement-gt-JXG-Line-gt-Line" class="headerlink" title="Line 线 JXG.GeometryElement -&gt; JXG.Line -&gt; Line"></a>Line 线 JXG.GeometryElement -&gt; JXG.Line -&gt; Line</h2><p>  Defined in line.js<br>  Extends JXG.Line<br>  JXG.Borad#create type:’line’</p><ul><li><p>param<br>point1—–JXG.Point|array|function<br>point2—–JXG.Point|array|function<br>or<br>c—-number|function<br>a—-number|function<br>b—-number|function  ax+by+c=0<br>or<br>f—-function</p></li><li><p>example</p><pre><code class="javascript">// Create a line using point and coordinates/// The second point will be fixed and invisible.var p1 = board.create(&#39;point&#39;, [4.5, 2.0]);var l1 = board.create(&#39;line&#39;, [p1, [1.0, 1.0]]);</code></pre><pre><code class="javascript">// Create a line using three coordinatesvar l1 = board.create(&#39;line&#39;, [1.0, -2.0, 3.0]);</code></pre></li><li><p>Attributes</p><ul><li>firstArrow<br>起点箭头</li><li>label<br>线的标签</li><li>lastArrow<br>结束点箭头</li><li>point1<br>线的第一个点</li><li>point2<br>线的第二个点</li><li>snapSizeX<br>Defines together with JXG.Point#snapSizeY the grid the point snaps on to<br>线段的x JXG.Point#snapSizeX</li><li>snapSizeY<br>Defines together with JXG.Point#snapSizeY the grid the point snaps on to<br>线段的y JXG.Point#snapSizeY</li><li>snapToGrid<br>If set to true, the point will snap to a grid defined by JXG.Point#snapSizeX and JXG.Point#snapSizeY.<br>如果设置为true,通过1和2 点将捕获一个网格</li><li>straightFirst<br>If true, line stretches infinitely in direction of its first point.<br>如果设置为true 通过第一个点无限延长 射线</li><li>straightLast<br>与第一个点相反</li><li>ticks<br>线的记号</li><li>touchFirstPoint<br>If set to true and Line#firstArrow is set to true,<br>the arrow head will just touch the circle line of the start point of the line.</li><li>touchLastPoint<br>If set to true and Line#lastArrow is set to true,<br>the arrow head will just touch the circle line of the start point of the line.</li><li>其他<br>JXG.Line</li></ul></li><li><p>Fields<br>JXG.Line<br>JXG.GeometryElement</p></li><li><p>Methods<br>JXG.Line、JXG.GeometryElement</p></li><li><p>Events<br>JXG.GeometryElement</p></li></ul><h2 id="Locus-轨迹-JXG-GeometryElement-gt-JXG-Curve-gt-Locus"><a href="#Locus-轨迹-JXG-GeometryElement-gt-JXG-Curve-gt-Locus" class="headerlink" title="Locus 轨迹 JXG.GeometryElement -&gt; JXG.Curve -&gt; Locus"></a>Locus 轨迹 JXG.GeometryElement -&gt; JXG.Curve -&gt; Locus</h2><h2 id="MajorArc-大弧-JXG-GeometryElement-gt-JXG-Curve-gt-Curve-gt-MajorArc"><a href="#MajorArc-大弧-JXG-GeometryElement-gt-JXG-Curve-gt-Curve-gt-MajorArc" class="headerlink" title="MajorArc 大弧 JXG.GeometryElement -&gt; JXG.Curve -&gt; Curve-&gt; MajorArc"></a>MajorArc 大弧 JXG.GeometryElement -&gt; JXG.Curve -&gt; Curve-&gt; MajorArc</h2><p>  Defined in arc.js<br>  Extends Curve<br>  JXG.Borad#create type:’majorarc’</p><ul><li><p>param<br>p1—-JXG.Point<br>p2—-JXG.Point<br>p3—-JXG.Point</p></li><li><p>example</p><pre><code class="javascript">// Create an arc out of three free pointsvar p1 = board.create(&#39;point&#39;, [2.0, 2.0]);var p2 = board.create(&#39;point&#39;, [1.0, 0.5]);var p3 = board.create(&#39;point&#39;, [3.5, 1.0]);var a = board.create(&#39;majorarc&#39;, [p1, p2, p3]);  </code></pre></li></ul><h2 id="MajorSector-大扇区-JXG-GeometryElement-gt-JXG-Curve-gt-Curve-gt-MajorSector"><a href="#MajorSector-大扇区-JXG-GeometryElement-gt-JXG-Curve-gt-Curve-gt-MajorSector" class="headerlink" title="MajorSector 大扇区 JXG.GeometryElement -&gt; JXG.Curve -&gt; Curve -&gt; MajorSector"></a>MajorSector 大扇区 JXG.GeometryElement -&gt; JXG.Curve -&gt; Curve -&gt; MajorSector</h2><p>  Defined in sector.js<br>  Extends Curve<br>  JXG.Borad#create type:’majorsector’</p><ul><li><p>param<br>p1—-JXG.Point<br>p2—-JXG.Point<br>p3—-JXG.Point</p></li><li><p>example</p><pre><code class="javascript">// Create an arc out of three free pointsvar p1 = board.create(&#39;point&#39;, [2.0, 2.0]);var p2 = board.create(&#39;point&#39;, [1.0, 0.5]);var p3 = board.create(&#39;point&#39;, [3.5, 1.0]);var a = board.create(&#39;majorsector&#39;, [p1, p2, p3]);</code></pre></li></ul><h2 id="Midpoint-中点-JXG-GeometryElement-gt-JXG-Point-gt-Midpoint"><a href="#Midpoint-中点-JXG-GeometryElement-gt-JXG-Point-gt-Midpoint" class="headerlink" title="Midpoint 中点 JXG.GeometryElement -&gt; JXG.Point -&gt; Midpoint"></a>Midpoint 中点 JXG.GeometryElement -&gt; JXG.Point -&gt; Midpoint</h2><p>  Defined in composition.js<br>  Extends JXG.Point<br>  JXG.Board#create type:’midpoint’</p><ul><li><p>param<br>p1—-JXG.Point<br>p2—-JXG.Point<br>or<br>l—–JXG.Line</p></li><li><p>example</p><pre><code class="javascript">// Create base elements: 2 points and 1 linevar p1 = board.create(&#39;point&#39;, [0.0, 2.0]);var p2 = board.create(&#39;point&#39;, [2.0, 1.0]);var l1 = board.create(&#39;segment&#39;, [[0.0, 3.0], [3.0, 3.0]]);var mp1 = board.create(&#39;midpoint&#39;, [p1, p2]);var mp2 = board.create(&#39;midpoint&#39;, [l1]);</code></pre></li></ul><h2 id="MinorArc-小狐-JXG-GeometryElement-gt-JXG-Curve-gt-Curve-gt-MinorArc"><a href="#MinorArc-小狐-JXG-GeometryElement-gt-JXG-Curve-gt-Curve-gt-MinorArc" class="headerlink" title="MinorArc 小狐 JXG.GeometryElement -&gt; JXG.Curve -&gt; Curve-&gt; MinorArc"></a>MinorArc 小狐 JXG.GeometryElement -&gt; JXG.Curve -&gt; Curve-&gt; MinorArc</h2><h2 id="MinorSector-小扇区-JXG-GeometryElement-gt-JXG-Curve-gt-Curve-gt-MinorSector"><a href="#MinorSector-小扇区-JXG-GeometryElement-gt-JXG-Curve-gt-Curve-gt-MinorSector" class="headerlink" title="MinorSector 小扇区 JXG.GeometryElement -&gt; JXG.Curve -&gt; Curve -&gt; MinorSector"></a>MinorSector 小扇区 JXG.GeometryElement -&gt; JXG.Curve -&gt; Curve -&gt; MinorSector</h2><h2 id="Mirrorpoint-镜像点-JXG-GeometryElement-JXG-CoordsElement-gt-JXG-Point-gt-Mirrorpoint"><a href="#Mirrorpoint-镜像点-JXG-GeometryElement-JXG-CoordsElement-gt-JXG-Point-gt-Mirrorpoint" class="headerlink" title="Mirrorpoint 镜像点 JXG.GeometryElement,JXG.CoordsElement -&gt; JXG.Point -&gt; Mirrorpoint"></a>Mirrorpoint 镜像点 JXG.GeometryElement,JXG.CoordsElement -&gt; JXG.Point -&gt; Mirrorpoint</h2><ul><li><p>example</p><pre><code class="javascript">var p1 = board.create(&#39;point&#39;, [3.0, 3.0]);var p2 = board.create(&#39;point&#39;, [6.0, 1.0]);var mp1 = board.create(&#39;mirrorpoint&#39;, [p1, p2]);</code></pre><h2 id="NonReflexAngle-无反射性角-JXG-GeometryElement-gt-JXG-Curve-gt-Sector-gt-Angle-gt-NonReflexAngle"><a href="#NonReflexAngle-无反射性角-JXG-GeometryElement-gt-JXG-Curve-gt-Sector-gt-Angle-gt-NonReflexAngle" class="headerlink" title="NonReflexAngle 无反射性角 JXG.GeometryElement -&gt; JXG.Curve -&gt; Sector -&gt; Angle -&gt; NonReflexAngle"></a>NonReflexAngle 无反射性角 JXG.GeometryElement -&gt; JXG.Curve -&gt; Sector -&gt; Angle -&gt; NonReflexAngle</h2></li><li><p>example</p><pre><code class="javascript">// Create a non-reflex angle out of three free pointsvar p1 = board.create(&#39;point&#39;, [5.0, 3.0]),  p2 = board.create(&#39;point&#39;, [1.0, 0.5]),  p3 = board.create(&#39;point&#39;, [1.5, 5.0]),  a = board.create(&#39;nonreflexangle&#39;, [p1, p2, p3], {radius: 2});</code></pre><h2 id="Normal-数-法线-JXG-GeometryElement-gt-JXG-Line-gt-Normal"><a href="#Normal-数-法线-JXG-GeometryElement-gt-JXG-Line-gt-Normal" class="headerlink" title="Normal (数)法线 JXG.GeometryElement -&gt; JXG.Line -&gt; Normal"></a>Normal (数)法线 JXG.GeometryElement -&gt; JXG.Line -&gt; Normal</h2></li><li><p>param<br>o—-JXG.Line|JXG.Circle|JXG.Curve|JXG.Turtle<br>p—-JXG.Point</p></li><li><p>example</p><pre><code class="javascript">// Create a normal to a circle.var p1 = board.create(&#39;point&#39;, [2.0, 2.0]);var p2 = board.create(&#39;point&#39;, [3.0, 2.0]);var c1 = board.create(&#39;circle&#39;, [p1, p2]);var norm1 = board.create(&#39;normal&#39;, [c1, p2]);</code></pre><h2 id="Orthogonalprojection-正交投影-JXG-CoordsElement-JXG-GeometryElement-gt-JXG-Point-gt-Orthogonalprojection"><a href="#Orthogonalprojection-正交投影-JXG-CoordsElement-JXG-GeometryElement-gt-JXG-Point-gt-Orthogonalprojection" class="headerlink" title="Orthogonalprojection 正交投影 JXG.CoordsElement,JXG.GeometryElement -&gt; JXG.Point -&gt; Orthogonalprojection"></a>Orthogonalprojection 正交投影 JXG.CoordsElement,JXG.GeometryElement -&gt; JXG.Point -&gt; Orthogonalprojection</h2><p>Defined in composition.js<br>Extends JXG.Point<br>JXG.Board#create type:’orthogonalprojection’<br>点到线的垂点</p></li><li><p>param<br>p—-JXG.Point<br>l—-JXG.line</p></li><li><p>example</p><pre><code class="javascript">var p1 = board.create(&#39;point&#39;, [0.0, 4.0]);var p2 = board.create(&#39;point&#39;, [6.0, 1.0]);var l1 = board.create(&#39;line&#39;, [p1, p2]);var p3 = board.create(&#39;point&#39;, [3.0, 3.0]);var pp1 = board.create(&#39;orthogonalprojection&#39;, [p3, l1]);</code></pre></li></ul><h2 id="OtherIntersection-其他的交叉-JXG-CoordsElement-JXG-CoordsElement-gt-JXG-Point-gt-OtherIntersection"><a href="#OtherIntersection-其他的交叉-JXG-CoordsElement-JXG-CoordsElement-gt-JXG-Point-gt-OtherIntersection" class="headerlink" title="OtherIntersection 其他的交叉 JXG.CoordsElement,JXG.CoordsElement -&gt; JXG.Point -&gt; OtherIntersection"></a>OtherIntersection 其他的交叉 JXG.CoordsElement,JXG.CoordsElement -&gt; JXG.Point -&gt; OtherIntersection</h2><ul><li><p>example</p><pre><code class="javascript">// Create an intersection point of circle and line // 和原图有区别？？？？var p1 = board.create(&#39;point&#39;, [2.0, 2.0]);var c1 = board.create(&#39;circle&#39;, [p1, 2.0]);var p2 = board.create(&#39;point&#39;, [2.0, 2.0]);var p3 = board.create(&#39;point&#39;, [2.0, 2.0]);var l1 = board.create(&#39;line&#39;, [p2, p3]);var i = board.create(&#39;intersection&#39;, [c1, l1, 0]);var j = board.create(&#39;otherintersection&#39;, [c1, l1, i]);</code></pre></li></ul><h2 id="Parabola-抛物线-JXG-GeometryElement-gt-JXG-Curve-gt-Conic-gt-Parabola"><a href="#Parabola-抛物线-JXG-GeometryElement-gt-JXG-Curve-gt-Conic-gt-Parabola" class="headerlink" title="Parabola 抛物线 JXG.GeometryElement -&gt; JXG.Curve -&gt; Conic -&gt; Parabola"></a>Parabola 抛物线 JXG.GeometryElement -&gt; JXG.Curve -&gt; Conic -&gt; Parabola</h2><ul><li><p>param<br>point—-JXG.Point|array<br>Line—–JXG.line</p></li><li><p>example</p><pre><code class="javascript">// Create a parabola by a point C and a line l.var A = board.create(&#39;point&#39;, [-1,4]);var B = board.create(&#39;point&#39;, [-1,-4]);var l = board.create(&#39;line&#39;, [A,B]);var C = board.create(&#39;point&#39;, [1,1]);var el = board.create(&#39;parabola&#39;,[C,l]);</code></pre><h2 id="Parallel-平行线-JXG-GeometryElement-gt-JXG-Line-gt-Line-gt-Parallel"><a href="#Parallel-平行线-JXG-GeometryElement-gt-JXG-Line-gt-Line-gt-Parallel" class="headerlink" title="Parallel 平行线 JXG.GeometryElement -&gt; JXG.Line -&gt; Line -&gt; Parallel"></a>Parallel 平行线 JXG.GeometryElement -&gt; JXG.Line -&gt; Line -&gt; Parallel</h2></li><li><p>param<br>l—-JXG.Line<br>p—-JXG.Point</p></li><li><p>example</p><pre><code class="javascript">// Create a parallelvar p1 = board.create(&#39;point&#39;, [0.0, 2.0]);var p2 = board.create(&#39;point&#39;, [2.0, 1.0]);var l1 = board.create(&#39;line&#39;, [p1, p2]);var p3 = board.create(&#39;point&#39;, [3.0, 3.0]);var pl1 = board.create(&#39;parallel&#39;, [l1, p3]);</code></pre></li></ul><h2 id="Parallelpoint-平行点-JXG-GeometryElement-JXG-CoordsElement-gt-JXG-Point-gt-Parallelpoint"><a href="#Parallelpoint-平行点-JXG-GeometryElement-JXG-CoordsElement-gt-JXG-Point-gt-Parallelpoint" class="headerlink" title="Parallelpoint 平行点 JXG.GeometryElement,JXG.CoordsElement -&gt; JXG.Point -&gt; Parallelpoint"></a>Parallelpoint 平行点 JXG.GeometryElement,JXG.CoordsElement -&gt; JXG.Point -&gt; Parallelpoint</h2><ul><li><p>param<br>p1—-JXG.Point<br>p2—-JXG.Point<br>p3—-JXG.Point</p></li><li><p>example<br>l—-JXG.Line<br>p—-JXG.Point</p></li><li><p>example</p><pre><code class="javascript">var p1 = board.create(&#39;point&#39;, [0.0, 2.0]);var p2 = board.create(&#39;point&#39;, [2.0, 1.0]);var p3 = board.create(&#39;point&#39;, [3.0, 3.0]);var pp1 = board.create(&#39;parallelpoint&#39;, [p1, p2, p3]);</code></pre></li></ul><h2 id="Perpendicular-垂直线-JXG-GeometryElement-gt-JXG-Line-gt-Segment-gt-Perpendicular"><a href="#Perpendicular-垂直线-JXG-GeometryElement-gt-JXG-Line-gt-Segment-gt-Perpendicular" class="headerlink" title="Perpendicular 垂直线 JXG.GeometryElement -&gt; JXG.Line -&gt; Segment -&gt; Perpendicular"></a>Perpendicular 垂直线 JXG.GeometryElement -&gt; JXG.Line -&gt; Segment -&gt; Perpendicular</h2><p>  Defined in composition.js<br>  Extends Segment<br>  JXG.Borad#create type:’perpendicular’</p><ul><li><p>param<br>l—-JXG.Line<br>p—-JXG.Point</p></li><li><p>example</p><pre><code class="javascript">// Create a perpendicularvar p1 = board.create(&#39;point&#39;, [0.0, 2.0]);var p2 = board.create(&#39;point&#39;, [2.0, 1.0]);var l1 = board.create(&#39;line&#39;, [p1, p2]);var p3 = board.create(&#39;point&#39;, [3.0, 3.0]);var perp1 = board.create(&#39;perpendicular&#39;, [l1, p3]);</code></pre></li></ul><h2 id="PerpendicularPoint-垂直点-JXG-CoordsElement-JXG-GeometryElement-gt-JXG-Point-gt-PerpendicularPoint"><a href="#PerpendicularPoint-垂直点-JXG-CoordsElement-JXG-GeometryElement-gt-JXG-Point-gt-PerpendicularPoint" class="headerlink" title="PerpendicularPoint 垂直点 JXG.CoordsElement,JXG.GeometryElement -&gt; JXG.Point -&gt; PerpendicularPoint"></a>PerpendicularPoint 垂直点 JXG.CoordsElement,JXG.GeometryElement -&gt; JXG.Point -&gt; PerpendicularPoint</h2><ul><li><p>param<br>p—-JXG.Line<br>l—-JXG.Point</p></li><li><p>example</p><pre><code class="javascript">var p1 = board.create(&#39;point&#39;, [0.0, 4.0]);var p2 = board.create(&#39;point&#39;, [6.0, 1.0]);var l1 = board.create(&#39;line&#39;, [p1, p2]);var p3 = board.create(&#39;point&#39;, [3.0, 3.0]);var pp1 = board.create(&#39;perpendicularpoint&#39;, [p3, l1]);</code></pre></li></ul><h2 id="PerpendicularSegment-垂线段-JXG-GeometryElement-gt-JXG-Line-gt-Segment-gt-PerpendicularSegment"><a href="#PerpendicularSegment-垂线段-JXG-GeometryElement-gt-JXG-Line-gt-Segment-gt-PerpendicularSegment" class="headerlink" title="PerpendicularSegment 垂线段 JXG.GeometryElement -&gt; JXG.Line -&gt; Segment -&gt; PerpendicularSegment"></a>PerpendicularSegment 垂线段 JXG.GeometryElement -&gt; JXG.Line -&gt; Segment -&gt; PerpendicularSegment</h2><ul><li><p>param<br>l—-JXG.Line<br>p—-JXG.Point</p></li><li><p>example</p><pre><code class="javascript">// Create a perpendicularvar p1 = board.create(&#39;point&#39;, [0.0, 2.0]);var p2 = board.create(&#39;point&#39;, [2.0, 1.0]);var l1 = board.create(&#39;line&#39;, [p1, p2]);var p3 = board.create(&#39;point&#39;, [3.0, 3.0]);var perp1 = board.create(&#39;perpendicularsegment&#39;, [l1, p3]);</code></pre></li></ul><h2 id="Point-点-JXG-CoordsElement-JXG-GeometryElement-gt-JXG-Point-gt-Point"><a href="#Point-点-JXG-CoordsElement-JXG-GeometryElement-gt-JXG-Point-gt-Point" class="headerlink" title="Point 点 JXG.CoordsElement,JXG.GeometryElement -&gt; JXG.Point -&gt; Point"></a>Point 点 JXG.CoordsElement,JXG.GeometryElement -&gt; JXG.Point -&gt; Point</h2><p>  Defined in point.js<br>  Extends JXG.Point<br>  JXG.Board#create type:’point’</p><ul><li><p>param<br>z—-number|string|function optional<br>x—-number|string|function<br>y—-number|string|function</p></li><li><p>example</p><pre><code class="javascript">// Create a free point using affine euclidean coordinatesvar p1 = board.create(&#39;point&#39;, [3.5, 2.0]);</code></pre><pre><code class="javascript">// Create a constrained point using anonymous functionvar p2 = board.create(&#39;point&#39;, [3.5, function () { return p1.X(); }]);</code></pre><pre><code class="javascript">// Create a point using transformationsvar trans = board.create(&#39;transform&#39;, [2, 0.5], {type:&#39;scale&#39;});var p3 = board.create(&#39;point&#39;, [p2, trans]);</code></pre></li><li><p>Attributes</p><ul><li>attractorDistance<br>If the distance of the point to one of its attractors is less than this number the point will be a glider on this attracting element.<br>If set to zero nothing happens<br>default:0</li><li>attractors<br>List of attractor elements.<br>If the distance of the point is less than attractorDistance the point is made to glider of this element<br>default:empty</li><li>attractorUnit<br>Unit for attractorDistance and snatchDistance, used for magnetized points and for snapToPoints<br>Value ‘screen’ and ‘user’<br>default:’user’</li><li>face<br>点的样式 There are different point styles which differ in appearance<br>Value：cross、circle、square、plus、diamond、triangleUp、triangleDown、triangleLeft、triangleRight</li><li>ignoreSnapToPoints<br>List of elements which are ignored by snapToPoints<br>default:empty  array</li><li>infoboxDigits<ul><li>‘auto’<br>done automatically by JXG#autoDigits</li><li>‘none’<br>no truncation</li><li>‘number’<br>user String.toFixed();<br>default:auto </li></ul></li><li>showInfobox<br>infobox在鼠标移上去的时候会显示<br>default:true</li><li>size<br>点的大小<br>default:3</li><li>snapSizeX<br>Defines together with Point#snapSizeY the grid the point snaps on to.<br>The point will only snap on integer multiples to snapSizeX in x and snapSizeY in y direction.<br>If this value is equal to or less than 0, it will use the grid displayed by the major ticks of the default ticks of the default x axes of the board<br>default:1</li><li>snapSizeY<br>default:1</li><li>snapToGrid<br>If set to true, the point will snap to a grid defined by Point#snapSizeX and Point#snapSizeY.<br>default:false     </li><li>snapToPoints<br>If set to true, the point will snap to the nearest point in distance of Point#attractorDistance.<br>default:false</li><li>snatchDistance<br>If the distance of the point to one of its attractors is at least this number the point will be released from being a glider on the attracting element.<br>If set to zero nothing happens.<br>default:0.0 </li><li>style<br>确定点布局，defaul:5</li><li>zoom<br>如果为true，点得大小可以通过zoom events改变 default:false</li></ul></li></ul><h2 id="PolarLine-极线-JXG-GeometryElement-gt-JXG-Line-gt-PolarLine"><a href="#PolarLine-极线-JXG-GeometryElement-gt-JXG-Line-gt-PolarLine" class="headerlink" title="PolarLine 极线 JXG.GeometryElement -&gt; JXG.Line -&gt; PolarLine"></a>PolarLine 极线 JXG.GeometryElement -&gt; JXG.Line -&gt; PolarLine</h2><h2 id="PolePoint-极点-JXG-GeometryElement-JXG-CoordsElement-gt-JXG-Point-gt-PolePoint"><a href="#PolePoint-极点-JXG-GeometryElement-JXG-CoordsElement-gt-JXG-Point-gt-PolePoint" class="headerlink" title="PolePoint 极点 JXG.GeometryElement,JXG.CoordsElement -&gt; JXG.Point -&gt; PolePoint"></a>PolePoint 极点 JXG.GeometryElement,JXG.CoordsElement -&gt; JXG.Point -&gt; PolePoint</h2><h2 id="Polygon-多边形-JXG-GeometryElement-gt-JXG-Polygon-gt-Polygon"><a href="#Polygon-多边形-JXG-GeometryElement-gt-JXG-Polygon-gt-Polygon" class="headerlink" title="Polygon 多边形 JXG.GeometryElement -&gt; JXG.Polygon -&gt; Polygon"></a>Polygon 多边形 JXG.GeometryElement -&gt; JXG.Polygon -&gt; Polygon</h2><p>  Defined in polygon.js<br>  Extends JXG.Polygon<br>  JXG.Board#create type:’polygon’</p><ul><li><p>param<br>list points<br>a list of points or<br>a list of coordinate arrays or<br>a function returning a list of coordinate arrays.</p></li><li><p>example</p><pre><code class="javascript">var p1 = board.create(&#39;point&#39;, [0.0, 2.0]);var p2 = board.create(&#39;point&#39;, [2.0, 1.0]);var p3 = board.create(&#39;point&#39;, [4.0, 6.0]);var p4 = board.create(&#39;point&#39;, [1.0, 4.0]);var pol = board.create(&#39;polygon&#39;, [p1, p2, p3, p4]);</code></pre><pre><code class="javascript">var p = [[0.0, 2.0], [2.0, 1.0], [4.0, 6.0], [4.0, 6.0], [4.0, 6.0], [1.0, 3.0]];var pol = board.create(&#39;polygon&#39;, p, {hasInnerPoints: true});</code></pre><pre><code class="javascript">var f1 = function() { return [0.0, 2.0]; },   f2 = function() { return [2.0, 1.0]; },   f3 = function() { return [4.0, 6.0]; },   f4 = function() { return [1.0, 4.0]; },   cc1 = board.create(&#39;polygon&#39;, [f1, f2, f3, f4]);</code></pre></li></ul><h2 id="RadicalAxis-根轴-JXG-GeometryElement-gt-JXG-Line-gt-RadicalAxis"><a href="#RadicalAxis-根轴-JXG-GeometryElement-gt-JXG-Line-gt-RadicalAxis" class="headerlink" title="RadicalAxis 根轴 JXG.GeometryElement -&gt; JXG.Line -&gt; RadicalAxis"></a>RadicalAxis 根轴 JXG.GeometryElement -&gt; JXG.Line -&gt; RadicalAxis</h2><p>  defined in line.js<br>  Extends JXG.Line<br>  JXG.Board#create type:’line’</p><ul><li><p>example</p><pre><code class="javascript">// Create the radical axis line with respect to two circlesvar board = JXG.JSXGraph.initBoard(&#39;7b7233a0-f363-47dd-9df5-5018d0d17a98&#39;, {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});var p1 = board.create(&#39;point&#39;, [2, 3]);var p2 = board.create(&#39;point&#39;, [1, 4]);var c1 = board.create(&#39;circle&#39;, [p1, p2]);var p3 = board.create(&#39;point&#39;, [6, 5]);var p4 = board.create(&#39;point&#39;, [8, 6]);var c2 = board.create(&#39;circle&#39;, [p3, p4]);var r1 = board.create(&#39;radicalaxis&#39;, [c1, c2]);</code></pre><h2 id="Reflection-反射-JXG-GeometryElement-gt-JXG-Point-gt-Reflection"><a href="#Reflection-反射-JXG-GeometryElement-gt-JXG-Point-gt-Reflection" class="headerlink" title="Reflection 反射 JXG.GeometryElement -&gt; JXG.Point -&gt; Reflection"></a>Reflection 反射 JXG.GeometryElement -&gt; JXG.Point -&gt; Reflection</h2><h2 id="ReflexAngle-反射角-JXG-GeometryElement-gt-JXG-Curve-gt-Sector-gt-ReflexAngle"><a href="#ReflexAngle-反射角-JXG-GeometryElement-gt-JXG-Curve-gt-Sector-gt-ReflexAngle" class="headerlink" title="ReflexAngle 反射角 JXG.GeometryElement -&gt; JXG.Curve -&gt; Sector -&gt; ReflexAngle"></a>ReflexAngle 反射角 JXG.GeometryElement -&gt; JXG.Curve -&gt; Sector -&gt; ReflexAngle</h2><h2 id="RegularPolygon-正多边形-JXG-GeometryElement-gt-JXG-polygon-gt-Polygon-gt-RegularPolygon"><a href="#RegularPolygon-正多边形-JXG-GeometryElement-gt-JXG-polygon-gt-Polygon-gt-RegularPolygon" class="headerlink" title="RegularPolygon 正多边形 JXG.GeometryElement -&gt; JXG.polygon -&gt; Polygon -&gt; RegularPolygon"></a>RegularPolygon 正多边形 JXG.GeometryElement -&gt; JXG.polygon -&gt; Polygon -&gt; RegularPolygon</h2><p>Defined In Polygon.js<br>Extends Polygon<br>JXG.Board#create type:’regularpolygon’</p></li><li><p>param<br>p1—-JXG.Point<br>p2—-JXG.Point<br>n—–number</p></li><li><p>example</p><pre><code class="javascript">var p1 = board.create(&#39;point&#39;, [0.0, 2.0]);var p2 = board.create(&#39;point&#39;, [2.0, 1.0]);var pol = board.create(&#39;regularpolygon&#39;, [p1, p2, 5]);</code></pre><pre><code class="javascript">var p1 = board.create(&#39;point&#39;, [0.0, 2.0]);var p2 = board.create(&#39;point&#39;, [4.0,4.0]);var p3 = board.create(&#39;point&#39;, [2.0,0.0]);var pol = board.create(&#39;regularpolygon&#39;, [p1, p2, p3]);</code></pre></li><li><p>Attributes</p><ul><li>borders<br>多边形的边</li><li>hasInnerPoints<br>鼠标经过点内时触发hasPoint事件<br>default:false</li><li>vertices<br>多边形的顶点</li><li>withLines<br>多边形的边由通过线连接？？？</li><li>其他<br>借用其他元素的属性：Polygon</li></ul></li><li><p>Fields<br>JXG.GeometryElement</p></li><li><p>Methods<br>JXG.Polygon、JXG.GeometryElement</p></li><li><p>Events<br>JXG.GeometryElement</p></li></ul><h2 id="Riemannsum-黎曼和-高等数学积分-JXG-GeometryElement-gt-JXG-curve-gt-Riemannsum"><a href="#Riemannsum-黎曼和-高等数学积分-JXG-GeometryElement-gt-JXG-curve-gt-Riemannsum" class="headerlink" title="Riemannsum 黎曼和(高等数学积分) JXG.GeometryElement -&gt; JXG.curve -&gt; Riemannsum"></a>Riemannsum 黎曼和(高等数学积分) JXG.GeometryElement -&gt; JXG.curve -&gt; Riemannsum</h2><h2 id="Sector-扇形-JXG-GeometryElement-gt-JXG-Curve-gt-Sector"><a href="#Sector-扇形-JXG-GeometryElement-gt-JXG-Curve-gt-Sector" class="headerlink" title="Sector 扇形 JXG.GeometryElement -&gt; JXG.Curve -&gt; Sector"></a>Sector 扇形 JXG.GeometryElement -&gt; JXG.Curve -&gt; Sector</h2><p>  Defined in sector.js<br>  Extends JXG.Curve<br>  JXG.Borad#create type:’sector’</p><ul><li><p>param<br>p1—-JXG.Point 弧心<br>p2—-JXG.Point 弧的起点（p1到p2的距离–半径）<br>p3—-JXG.Point 弧的终点</p></li><li><p>example</p><pre><code class="javascript">// Create a sector out of three free pointsvar p1 = board.create(&#39;point&#39;, [1.5, 5.0]),    p2 = board.create(&#39;point&#39;, [1.0, 0.5]),    p3 = board.create(&#39;point&#39;, [5.0, 3.0]),    a = board.create(&#39;sector&#39;, [p1, p2, p3]);</code></pre><pre><code class="javascript">// Create a sector out of two lines, two directions and a radiusvar p1 = board.create(&#39;point&#39;, [-1, 4]),p2 = board.create(&#39;point&#39;, [4, 1]),q1 = board.create(&#39;point&#39;, [-2, -3]),q2 = board.create(&#39;point&#39;, [4,3]),li1 = board.create(&#39;line&#39;, [p1,p2], {strokeColor:&#39;black&#39;, lastArrow:true}),li2 = board.create(&#39;line&#39;, [q1,q2], {lastArrow:true}),sec1 = board.create(&#39;sector&#39;, [li1, li2, [5.5, 0], [4, 3], 3]),sec2 = board.create(&#39;sector&#39;, [li1, li2, 1, -1, 4]);</code></pre></li><li><p>Attributes</p><ul><li>anglepoint<br>helper point anglepoint   辅助点anglepoint</li><li>arc<br>sub-element arc</li><li>center<br>helper point center</li><li>label<br>the sector label</li><li>radiuspoint<br>helper point radiuspoint</li></ul></li><li><p>Fields  </p><ul><li>point1  Midpoint of the sector</li><li>point2  This point together with Sector#point1 defines the radius</li><li>point3  Defines the sector’s angle</li><li>point4  Defines the sectors orientation in case of circumCircleSectors</li></ul></li><li><p>Methods</p><ul><li>hasPointSector(x,y)<br>Checks whether (x,y) is within the area defined by the sector.<ul><li>x Coordinate in x direction, screen coordinates.</li><li>y Coordinate in y direction, screen coordinates.</li></ul></li><li>Radius()<br>the distance between Sector#point1 and Sector#point2<br>p1到p2的距离</li></ul></li></ul><h2 id="Segment-段-JXG-GeometryElement-gt-JXG-Line-gt-Segment"><a href="#Segment-段-JXG-GeometryElement-gt-JXG-Line-gt-Segment" class="headerlink" title="Segment 段 JXG.GeometryElement -&gt; JXG.Line -&gt; Segment"></a>Segment 段 JXG.GeometryElement -&gt; JXG.Line -&gt; Segment</h2><p>  Defined in line.js<br>  Extends JXG.Line<br>  JXG.Board#create type:’segment’</p><ul><li><p>param<br>point1—-JXG.Point|array<br>point2 </p></li><li><p>example</p><pre><code class="javascript">// Create a segment providing two points.var p1 = board.create(&#39;point&#39;, [4.5, 2.0]);var p2 = board.create(&#39;point&#39;, [1.0, 1.0]);var l1 = board.create(&#39;segment&#39;, [p1, p2]);</code></pre><pre><code class="javascript">// Create a segment providing two points.var p1 = board.create(&#39;point&#39;, [4.0, 1.0]);var p2 = board.create(&#39;point&#39;, [1.0, 1.0]);var l1 = board.create(&#39;segment&#39;, [p1, p2]);var p3 = board.create(&#39;point&#39;, [4.0, 2.0]);var p4 = board.create(&#39;point&#39;, [1.0, 2.0]);var l2 = board.create(&#39;segment&#39;, [p3, p4, 3]);var p5 = board.create(&#39;point&#39;, [4.0, 3.0]);var p6 = board.create(&#39;point&#39;, [1.0, 4.0]);var l3 = board.create(&#39;segment&#39;, [p5, p6, function(){ return l1.L();} ]);</code></pre></li></ul><h2 id="Semicircle-半圆形-JXG-GeometryElement-gt-JXG-Curve-gt-Curve-gt-Arc-gt-Semicircle"><a href="#Semicircle-半圆形-JXG-GeometryElement-gt-JXG-Curve-gt-Curve-gt-Arc-gt-Semicircle" class="headerlink" title="Semicircle 半圆形 JXG.GeometryElement -&gt; JXG.Curve -&gt; Curve -&gt; Arc -&gt; Semicircle"></a>Semicircle 半圆形 JXG.GeometryElement -&gt; JXG.Curve -&gt; Curve -&gt; Arc -&gt; Semicircle</h2><ul><li>example<pre><code class="javascript">// Create an arc out of three free pointsvar p1 = board.create(&#39;point&#39;, [4.5, 2.0]);var p2 = board.create(&#39;point&#39;, [1.0, 0.5]);var a = board.create(&#39;semicircle&#39;, [p1, p2]);</code></pre></li><li>Attributes<ul><li>midpoint<br>center point of the semicircle</li><li>其他<br>借用其他元素的属性：JXG.Curve</li></ul></li><li>Fields<br>借用其他元素的属性：JXG.Curve、Arc  </li></ul><h2 id="Slider-滑动块-JXG-CoordsElement-JXG-GeometryElement-gt-JXG-Point-gt-Glider-gt-Slider"><a href="#Slider-滑动块-JXG-CoordsElement-JXG-GeometryElement-gt-JXG-Point-gt-Glider-gt-Slider" class="headerlink" title="Slider 滑动块 JXG.CoordsElement,JXG.GeometryElement -&gt; JXG.Point -&gt; Glider -&gt; Slider"></a>Slider 滑动块 JXG.CoordsElement,JXG.GeometryElement -&gt; JXG.Point -&gt; Glider -&gt; Slider</h2><p>  Defined in slider.js<br>  Extends Glider<br>  JXG.Board#create type:’slider’</p><ul><li><p>param</p><ul><li>start—-array</li><li>end——array</li><li>data—–array<br>The first two arrays give the start and the end where the slider is drawn on the board.<br>The third array gives the start and the end of the range the slider operates as the first resp.<br>the third component of the array.<br>The second component of the third array gives its start value</li></ul></li><li><p>example</p><pre><code class="javascript">// Create a slider with values between 1 and 10, initial position is 5.var s = board.create(&#39;slider&#39;, [[1, 2], [3, 2], [1, 5, 10]]);</code></pre><pre><code class="javascript">// Create a slider taking integer values between 1 and 50. Initial value is 50.var s = board.create(&#39;slider&#39;, [[1, 3], [3, 1], [1, 10, 50]], {snapWidth: 1});</code></pre></li><li><p>Attributes</p><ul><li>baseline<br>Attributes for the base line of the slider</li><li>highline<br>Attributes for the highlighting line of the slider</li><li>label<br>Attributes for the slider label.</li><li>point1<br>Attributes for first (left) helper point defining the slider position.</li><li>point2<br>Attributes for second (right) helper point defining the slider position.</li><li>precision<br>The precision of the slider value displayed in the optional text.</li><li>size<br>Size of slider point.</li><li>snapWidth<br>The slider only returns integer multiples of this value, e.g.</li><li>ticks<br>Attributes for the ticks of the base line of the slider.</li><li>withLabel<br>Show slider label.</li><li>withTicks<br>Show slider ticks.</li></ul></li><li><p>Fields</p><ul><li>_smax<br>End value of the slider range</li><li>_smin<br>Start value of the slider range.</li><li>Value<br>Returns the current slider value.</li><li>其他<br>Glider、JXG.GeometryElement、JXG.CoordsElement</li></ul></li><li><p>Methods<br>Glider JXG.Point JXG.GeometryElement JXG.CoordsElement</p></li><li><p>Events<br>JXG.GeometryElement    </p></li></ul><h2 id="Slopetriangle-斜三角形-JXG-GeometryElement-gt-JXG-Line-gt-Slopetriangle"><a href="#Slopetriangle-斜三角形-JXG-GeometryElement-gt-JXG-Line-gt-Slopetriangle" class="headerlink" title="Slopetriangle 斜三角形 JXG.GeometryElement -&gt; JXG.Line -&gt; Slopetriangle"></a>Slopetriangle 斜三角形 JXG.GeometryElement -&gt; JXG.Line -&gt; Slopetriangle</h2><h2 id="Spline-样条-JXG-GeometryElement-gt-JXG-Curve-gt-Spline"><a href="#Spline-样条-JXG-GeometryElement-gt-JXG-Curve-gt-Spline" class="headerlink" title="Spline 样条 JXG.GeometryElement -&gt; JXG.Curve -&gt; Spline"></a>Spline 样条 JXG.GeometryElement -&gt; JXG.Curve -&gt; Spline</h2><h2 id="Stepfunction-阶跃函数-JXG-GeometryElement-gt-JXG-Curve-gt-Stepfunction"><a href="#Stepfunction-阶跃函数-JXG-GeometryElement-gt-JXG-Curve-gt-Stepfunction" class="headerlink" title="Stepfunction 阶跃函数 JXG.GeometryElement -&gt; JXG.Curve -&gt; Stepfunction"></a>Stepfunction 阶跃函数 JXG.GeometryElement -&gt; JXG.Curve -&gt; Stepfunction</h2><ul><li>example <pre><code class="javascript">// Create step function.var curve = board.create(&#39;stepfunction&#39;, [[0,1,2,3,4,5], [1,3,0,2,2,1]]);</code></pre></li></ul><h2 id="Tangent-数-正切-JXG-GeometryElement-gt-JXG-Line-gt-Tangent"><a href="#Tangent-数-正切-JXG-GeometryElement-gt-JXG-Line-gt-Tangent" class="headerlink" title="Tangent (数)正切 JXG.GeometryElement -&gt; JXG.Line -&gt; Tangent"></a>Tangent (数)正切 JXG.GeometryElement -&gt; JXG.Line -&gt; Tangent</h2><ul><li>example<pre><code class="javascript">// Create a tangent providing a glider on a function graphvar c1 = board.create(&#39;curve&#39;, [function(t){return t},function(t){return t*t*t;}]);var g1 = board.create(&#39;glider&#39;, [0.6, 1.2, c1]);var t1 = board.create(&#39;tangent&#39;, [g1]);</code></pre></li></ul><h2 id="Tapemeasure-卷尺-JXG-GeometryElement-gt-JXG-Line-gt-Segment-gt-Tapemeasure"><a href="#Tapemeasure-卷尺-JXG-GeometryElement-gt-JXG-Line-gt-Segment-gt-Tapemeasure" class="headerlink" title="Tapemeasure 卷尺 JXG.GeometryElement -&gt; JXG.Line -&gt; Segment -&gt; Tapemeasure"></a>Tapemeasure 卷尺 JXG.GeometryElement -&gt; JXG.Line -&gt; Segment -&gt; Tapemeasure</h2><h2 id="Text-文本-JXG-CoordsElement-JXG-GeometryElement-gt-JXG-Text-gt-Text"><a href="#Text-文本-JXG-CoordsElement-JXG-GeometryElement-gt-JXG-Text-gt-Text" class="headerlink" title="Text 文本 JXG.CoordsElement,JXG.GeometryElement -&gt; JXG.Text -&gt; Text"></a>Text 文本 JXG.CoordsElement,JXG.GeometryElement -&gt; JXG.Text -&gt; Text</h2><p>  Defined in text.js<br>  Extends JXG.Text<br>  JXG.Board#create type:’text’</p><ul><li><p>param<br>z——number|function  optional<br>x——number|function<br>y——number|function<br>str—-string|function</p></li><li><p>example</p><pre><code class="javascript">// Create a fixed text at position [0,1].var t1 = board.create(&#39;text&#39;,[0,1,&quot;Hello World&quot;]);</code></pre><pre><code class="javascript">// Create a variable text at a variable position.var s = board.create(&#39;slider&#39;,[[0,4],[3,4],[-2,0,2]]);var graph = board.create(                  &#39;text&#39;,                  [                    function(x){ return s.Value();},                    1,                    function(){return &quot;The value of s is&quot;+s.Value().toFixed(2);}                  ]                );</code></pre></li><li><p>Attributes</p><ul><li>anchor<br>default:null<br>Anchor element Point, Text or Image of the text.<br>If it exists, the coordinates of the text are relative to this anchor elemen</li><li>anchorX<br>default:’left’(left/middle/right)<br>The horizontal alignment of the text</li><li>anchorY<br>default:’middle’(top/middle/right)<br>The vertical alignment of the text.</li><li>attractors<br>default:empty<br>List of attractor elements.<br>If the distance of the text is less than attractorDistance the text is made to glider of this element</li><li>cssClass<br>The precision of the slider value displayed in the optional text</li><li>digits<br>default:2<br>Used to round texts given by a number</li><li>display<br>default:’html’<br>Determines the rendering method of the text.<br>Possible values include ‘html’ and ‘internal’</li><li>dragArea<br>default:’all’<br>Sensitive area for dragging the text.<br>Possible values are ‘all’, or something else.<br>This may be extended to left, right, … in the future</li><li>fontSize<br>default:12<br>字号</li><li>highlightCssClass<br>The precision of the slider value displayed in the optional text</li></ul></li></ul><h2 id="Ticks-记号-JXG-GeometryElement-gt-JXG-Ticks-gt-Ticks"><a href="#Ticks-记号-JXG-GeometryElement-gt-JXG-Ticks-gt-Ticks" class="headerlink" title="Ticks 记号 JXG.GeometryElement -&gt; JXG.Ticks -&gt; Ticks"></a>Ticks 记号 JXG.GeometryElement -&gt; JXG.Ticks -&gt; Ticks</h2><ul><li><p>example</p><pre><code class="javascript">// Create an axis providing two coord pairs.var p1 = board.create(&#39;point&#39;, [0, 3]);var p2 = board.create(&#39;point&#39;, [1, 3]);var l1 = board.create(&#39;line&#39;, [p1, p2]);var t = board.create(&#39;ticks&#39;, [l1], {ticksDistance: 2});</code></pre><pre><code class="javascript">// Create an axis providing two coord pairs.var p1 = board.create(&#39;point&#39;, [0, 0]);var p2 = board.create(&#39;point&#39;, [50, 25]);var l1 = board.create(&#39;line&#39;, [p1, p2]);var t = board.create(&#39;ticks&#39;, [l1, 1], {  insertTicks: true,  majorHeight: -1,  label: {      offset: [4, -9]  },  drawLabels: true});</code></pre></li><li><p>Attributes</p><ul><li>anchor default:’left’</li><li>drawLabels default:false</li><li>drawZero default:false</li><li>generateLabelText </li><li>generateLabelValue </li><li>includeBoundaries default:false</li><li>insertTicks  default:false</li><li>labels default:[]</li><li>majorHeight default:10</li><li>maxLabelLenght default:5</li><li>minorHeight default:4</li><li>minorTicks default:4</li><li>precision default:3</li><li>scale default:1</li><li>scaleSymbol default:’’</li><li>tickEndings default:[1,1]</li><li>ticksDistance default:1</li></ul></li></ul><h2 id="Tracecurve-轨迹曲线-JXG-GeometryElement-gt-JXG-Curve-gt-Tracecurve"><a href="#Tracecurve-轨迹曲线-JXG-GeometryElement-gt-JXG-Curve-gt-Tracecurve" class="headerlink" title="Tracecurve 轨迹曲线 JXG.GeometryElement -&gt; JXG.Curve -&gt; Tracecurve"></a>Tracecurve 轨迹曲线 JXG.GeometryElement -&gt; JXG.Curve -&gt; Tracecurve</h2><h2 id="Transformation-转型-JXG-Transformation-gt-Transformation"><a href="#Transformation-转型-JXG-Transformation-gt-Transformation" class="headerlink" title="Transformation 转型 JXG.Transformation -&gt; Transformation"></a>Transformation 转型 JXG.Transformation -&gt; Transformation</h2><h2 id="Turtle-乌龟-JXG-Turtle-gt-Turtle"><a href="#Turtle-乌龟-JXG-Turtle-gt-Turtle" class="headerlink" title="Turtle 乌龟 JXG.Turtle -&gt; Turtle"></a>Turtle 乌龟 JXG.Turtle -&gt; Turtle</h2>]]></content>
      
      
      
        <tags>
            
            <tag> jxggraph </tag>
            
            <tag> shape </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>heapSort</title>
      <link href="2016/07/18/heapSort/"/>
      <url>2016/07/18/heapSort/</url>
      
        <content type="html"><![CDATA[<h1 id="算法-堆排序"><a href="#算法-堆排序" class="headerlink" title="算法: 堆排序"></a>算法: 堆排序</h1><ul><li><p>堆分析<br>堆排序适合于求”前K大问题” 海量输出中找出前几大数据</p><pre><code>堆排序-&gt;二叉树模型    父节点     (3)    /   \   /     \ (2)     (1)左孩子    右孩子</code></pre><p>堆排序两种情况<br>大根堆：父节点要比左右孩子都大<br>小根堆：父节点要比左右孩子都小<br>堆排序需要做两件事：<br>第一：构建大根堆</p><pre><code>              (3)             /   \            /     \          (2)    (1)         /   \        /     \      (4)     (5)</code></pre><p>上面的树是一个无序堆，构建大根堆步骤如下：<br>第一步：首先找到堆中的2个父节点（2,3）;<br>第二步：比较2这个父节点的两个孩子(4,5)，发现5大<br>第三步：将较大的右孩子(5)跟父节点(2)进行交换，至此3的左孩子对构建完成，<br>如下所示</p><pre><code>              (3)             /   \            /     \          (5)     (1)         /   \        /     \       (4)    (2)</code></pre><p>第四步：比较第二个父节点(3)下面的左右孩子(5,1),发现左孩子5大<br>第五步：然后父节点（3）与左孩子（5）进行交换，注意，交换后，堆可能会遭到破坏，<br>按照以上步骤一，步骤二，步骤三进行重新构造堆。</p><p>最后构造的堆如下</p><pre><code>               (5)              /   \             /     \           (4)     (1)          /   \         /     \       (3)     (2)</code></pre><p>第二：输出大根堆<br>至此，我们把大根堆构造出来了，那怎么输出呢？我们做大根堆的目的就是要找出最大值，<br>那么我们将堆顶（5）与堆尾（2）进行交换，然后将（5）剔除根堆，由于堆顶现在是（2），<br>所以破坏了根堆，必须重新构造，构造完之后又会出现最大值，再次交换和剔除，最后也就<br>是要的效果</p></li><li><p>构建堆heapAdjust<br>@param list     数组(待排序集合)<br>@param parent   父节点<br>@param lenght   输出根堆时剔除最大值使用 </p></li></ul><pre><code class="javascript">function heapAdjust(list, parent, length) {    //temp 保存当前父节点    var temp = list[parent];    //得到左孩子（二叉树定义）    var child = 2 * parent + 1;    while (child &lt; length) {        //如果parent有右孩子，则判断左孩子是否小于右孩子        if (child + 1 &lt; length &amp;&amp; list[child] &lt; list[child + 1]) {            child++;        }        //如果父节点大于子节点，就不用交换        if (temp &gt;= list[child]) {            break;        }        //将较大子节点的值赋给父节点        list[parent] = list[child];        //然后将子节点作为父节点，防止是否破坏根堆时重新构造        parent = child;        //找到该父节点较小的左孩子节点        child = 2 * parent + 1;    }    //最后将temp值赋给较大的子节点，以形成两值交换    list[parent] = temp;}</code></pre><ul><li><p>堆排序heapSort<br>@param list 待排序数组<br>@param top  前K大</p><pre><code class="javascript">function heapSort(list, top) {  //需要输出的集合  var topNode = [];  //list.length/2-1 为堆中父节点个数  for (var i = list.length / 2 - 1; i &gt;= 0; i--) {      heapAdjust(list, i, list.length);  }  //最后输出堆元素  for (var i = list.length - 1; i &gt;= list.length - top ; i--) {      //堆顶与当前堆得第一个元素进行值对调      var temp = list[0];      list[0] = list[i];      list[i] = temp;      //最大值添加到输出集合      topNode.push(temp);      //因为顺序被打乱，重新构造堆      heapAdjust(list, 0, i);  }  return topNode;}</code></pre></li><li><p>调用</p><pre><code class="javascript">//获取一个随机数组function getDatalist() {  var listarr = [];  for (var j = 0; j &lt; 20000; j++) {      listarr[j] = Math.ceil(Math.random() * 20000);  }  return listarr;}// 调用//var list = getDatalist();//var toplist = heapSort(list, 10);var list1 = [50, 20, 80, 60, 75, 33, 25, 85, 66, 55];var toplist1 = heapSort(list1, 3);</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>quickSort</title>
      <link href="2016/07/18/quickSort/"/>
      <url>2016/07/18/quickSort/</url>
      
        <content type="html"><![CDATA[<h1 id="算法-快速排序"><a href="#算法-快速排序" class="headerlink" title="算法: 快速排序"></a>算法: 快速排序</h1><ul><li><p>快排分割<br>@param list  数组<br>@param left  数组第一个元素的下标<br>@param right 数据最后一个元素的下标</p><pre><code class="javascript">function division(list, left, right) {  //首先选择一个基准元素  var basenum = list[left];  while (left &lt; right) {     //从数组的右端开始向前找，一直找到比base小的数字为止(包括base同等数)     while (left &lt; right &amp;&amp; list[right] &gt;= basenum) {         right = right - 1;      }      //最终找到了比baseNum小的元素，要做的事情就是此元素放到base的位置      list[left] = list[right];      //从数组的左端开始向后找，一直找到比base大的数字为止（包括base同等数）      while (left &lt; right &amp;&amp; list[left] &lt;= basenum) {          left = left + 1;      }      //最终找到了比baseNum大的元素，要做的事情就是将此元素放到最后的位置      list[right] = list[left];      //最后就是把baseNum放到该left的位置      list[left] = basenum;      //最终，我们发现left位置的左侧数值部分比left小，left位置右侧数值比left大      //至此，我们完成了第一篇排序      return left;  }}</code></pre></li><li><p>调用<br>@param list  数组<br>@param left  数组第一个元素的下标<br>@param right 数据最后一个元素的下标</p><pre><code class="javascript">function quickSort(list, left, right) {  //左下标一定小于右下标，否则就超越了  if (left &lt; right) {      //对数组进行分割，取出下次分割的基准标号      var i = division(list, left, right)      //对“基准标号“左侧的一组数值进行递归的切割，以至于将这些数值完整的排序      quickSort(list, left, i - 1);      //对“基准标号“右侧的一组数值进行递归的切割，以至于将这些数值完整的排序      quickSort(list, i + 1, right);  }}var array = [20, 40, 50, 10, 60];quickSort(array, 0, array.length - 1);</code></pre></li><li><p>算法分析<br>数组：<br>[20,40,50,10,60]</p><p>第一步：<br>  首先我们从数组的left位置取出该数（20）作为基准（base为20）参照物。</p><p>第二步：<br>  从数组的right位置向前找，一直找到比（base）小的数，</p><p>  如果找到，将此数赋给left位置（也就是将10赋给20），</p><p>  此时数组为：10，40，50，10，60，</p><p>  left和right指针（下标）分别为前后的10。</p><p>第三步：<br>  从数组的left位置向后找，一直找到比（base为20）大的数，</p><p>  如果找到，将此数赋给right的位置（也就是40赋给10），</p><p>  此时数组为：10，40，50，40，60，</p><p>  left和right指针分别为前后的40。</p><p>第四步：<br>  重复“第二,第三“步骤，直到left和right指针（下标）重合，</p><p>  最后将（base）插入到40的位置，</p><p>  此时数组值为： 10，20，50，40，60，至此完成一次排序。</p><p>第五步：<br>  此时20已经潜入到数组的内部，20的左侧一组数都比20小，20的右侧作为一组数都比20大，</p><p>  以20为切入点对左右两边数按照”第一，第二，第三，第四”步骤进行，最终快排大功告成。</p></li><li><p>复杂度<br>平均复杂度： O(n*logn)<br>最坏复杂度： 0(n^2)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5 vs XHTML5</title>
      <link href="2016/05/19/HTML5-vs-XHTML5/"/>
      <url>2016/05/19/HTML5-vs-XHTML5/</url>
      
        <content type="html"><![CDATA[<p>XHTML5 与 HTML5 的差异和兼容</p><p>这里考虑的是让文档同时符合 HTML 5 和 XHTML 5（以下简称h5和x5）。</p><p>*** 参考<br>HTML vs. XHTML<br>  <a href="http://wiki.whatwg.org/wiki/HTML_vs._XHTML" target="_blank" rel="noopener">http://wiki.whatwg.org/wiki/HTML_vs._XHTML</a></p><p>HTML和XHTML的不同<br>  <a href="http://dancewithnet.com/2007/10/28/differences-between-html-and-xhtml/" target="_blank" rel="noopener">http://dancewithnet.com/2007/10/28/differences-between-html-and-xhtml/</a></p><p>** mime<br>text/html 和 application/xml or application/xhtml+xml<br>根据HTML5，如果给定 mime是text/html，那么解析模式就不是 xhtml。</p><p>对于本地x5文件，可以给予扩展名 xhtml，这样浏览器会以 xhtml 模式加载。</p><p>** doctype<br> DOCTYPE 对x5是可选的，h5则用来触发正常解析模式。<br> 给出 <!DOCTYPE html> 可以兼容h5和x5。</p><p>** 字符编码<br> h5 忽略（或者不允许使用） xml 声明（<?xml encoding="..."?>），而x5会忽略 <meta charset="..." />（而且只允许值为UTF-8），因此没有两者通用的字符编码指定方法。<br> 相对可行的方法是：文档采用UTF-8编码，给出 meta charset，但是不给出 xml 声明。这样，xml解析器仍可自动识别编码。</p><p>** 命名空间<br> h5 可以被认为不支持命名空间。<br> h5 中的内置元素的命名空间是隐式的，即 html、svg、mathml元素及其子元素分别在 xhtml、svg、mathml 命名空间中，外部元素不能声明自己的命名空间。<br> h5 允许内置元素使用xmlns属性，但是不能使用前缀，xmlns属性也不起任何作用。<br> x5 中，html、svg、mathml元素都必须给予恰当的命名空间：<br>   <a href="http://www.w3.org/1999/xhtml" target="_blank" rel="noopener">http://www.w3.org/1999/xhtml</a><br>   <a href="http://www.w3.org/2000/svg" target="_blank" rel="noopener">http://www.w3.org/2000/svg</a><br>   <a href="http://www.w3.org/1998/Math/MathML" target="_blank" rel="noopener">http://www.w3.org/1998/Math/MathML</a></p><p> 为了兼容 h5和x5，应对html、svg、mathml元素声明命名空间，但不要使用前缀。</p><p>** XML attributes<br>  x5中，有xml:前缀的属性，如 xml:id, xml:base, xml:lang 和 xml:space<br>  不需要声明命名空间，强制的命名空间是 <a href="http://www.w3.org/XML/1998/namespace，前缀也只能是" target="_blank" rel="noopener">http://www.w3.org/XML/1998/namespace，前缀也只能是</a> xml。<br>  h5中，html元素也可以使用 xml:lang，不过没什么效果。其它元素则可以自由使用所有 xml 属性。</p><p>  为了兼容，html元素上应同时使用lang和xml:lang属性，如果需要的话；但不要在html元素上使用其它xml 属性。</p><p>** 属性<br>  x5中属性名都是小写的，h5则不区分大小写，为了兼容应全部小写。<br>  不属于html词汇表的属性仍会包含在DOM中，不过为了避免冲突，建议使用data-属性。<br>  x5属性值中的空白会被正规化，h5则不会，因此不要依赖这个特性。</p><p>** 必空（Void）与非必空（Non-void）元素<br>  h5 中，必空元素是指不能有内容的元素，它们不能写成开始标记紧跟结束标记的形式，只能写成仅有开始标记或自封闭标记的形式。<br>  例如<br>或<br/>不能写成<br></br>，否则h5解析器认为</br>是另一个<br>。<br>  x5 没有这个概念，<br/> 等效于 <br></br>，但是，仅有开始标记是不允许的。<br>  必空元素包括：base, link, meta, area, br, col, embed, hr, img, input, param。</p><p>  h5 中，非必空元素是指可能有内容的元素，它们不能写成自封闭的形式。例如 <script></script>不能写成<script/>，否则该元素整个被忽略。<br>  x5 同样没有这个概念，没有内容的元素总是可以写成自封闭形式。</p><p>  为了兼容，必空元素应写成自封闭形式，非必空元素一定不要写成自封闭形式。</p><p>** 可省略结束标记的元素和可省略的元素<br>  在h5中，某些元素允许省略结束标签或两个标签。</p><pre><code>html (两个)head (两个)body (两个)li (结束标签)dt (结束标签)dd (结束标签)p (结束标签)colgroup (两个)thead (结束标签)tbody (两个)tfoot (结束标签)tr (结束标签)td (结束标签)th (结束标签)</code></pre><p>  在 x5中，以上都不可省略。</p><p>** 处理指令 Processing Instructions<br>  h5 没有处理指令的概念，但早期 html 允许 “bogus comments”（伪造的注释），使用类似的语法 <?foo ...> 或者 <?foo ...?>，但已经被h5废弃。<br>  为了兼容，x5中的处理指令内部不要有’&gt;’，否则在h5解析器中会过早结束。最好完全不用处理指令。</p><p>** CDATA sections<br>  h5 将 CDATA sections 视为“bogus comments”。h5的普通文本中允许出现CDATA结束标记 “]]&gt;” ，但 x5不允许。<br>  为了兼容，要避免普通文本中出现CDATA结束标记 “]]&gt;”。</p><p>** 字符引用<br>  h5中 x 可以大写（如&#XA;），x5 中只能小写。为兼容要小写。</p><p>** script 和 style<br>  h5中，这两个元素的内部总是被视为 CDATA（尽管与xml的CDATA不完全相同），因此可以直接出现’&lt;’、’&amp;’。<br>  x5中，这两个元素的内部只是普通内容，因此里面会按xml语法去解析，所以特殊字符如’&lt;’、’&amp;’必须转义。<br>  为了兼容，可以总是转义特殊字符，或者用CDATA sections。</p><p>** DOM API</p><ul><li><p>类型<br>h5 文档对象类型是 HTMLDocument，x5则是 Document 或者 XMLDocument。<br>元素类型则没有区别，都是 HTMLElement。<br>x5模式下，元素和属性名区分大小写。<br>h5中，Element.tagName and Node.nodeName 对html节点返回大写名字，但x5中返回小写。</p><p>详见 javascript_note_document_creation_parsing_serialization.txt。</p></li><li><p>Document的body、head、images等快捷属性<br>如果文档是主文档（即window.document），则这些属性对 x5 文档也是可用的，这保证了在xhtml中使用js的兼容性。<br>如果不是主文档，则不一定可用（chrome可，FF不可），所以不要依赖它。<br>HTMLDocument 中默认就有 head 和 body 元素，即使在源文件中省略或在创建时省略；而 xhtml Document 中，如果省略元素就真的没有了。</p></li><li><p>innerHTML/outerHTML<br>对于x5，读这个属性得到的字符串会带有xhtml的命名空间（如果含有元素子节点）；<br>写入这个元素不要求有命名空间，但至少要符合xhtml语法，否则抛出异常。<br>对于h5，则不会得到命名空间，也不一定符合xhtml语法。<br>因此在h5文档和x5文档之间交换数据的时候很容易出现问题，解决办法见“格式转换”。</p></li><li><p>Document.createElement(name) 和 createElementNS(ns, name)<br>如果实际类型是HTMLDocument，创建的元素的隐含命名空间是xhtml。<br>如果文档是主文档（即window.document），则 createElement 创建元素的命名空间与根节点相同，这保证了在xhtml中使用js的兼容性。<br>但如果不是主文档，而文档是有命名空间的 xml 文档（包括xhtml），则一定要用 Document.createElementNS(ns, name) 来创建子元素，并正确给出命名空间，否则子元素会变成默认命名空间的。<br>参见 javascript_note_document_creation_parsing_serialization.txt。</p></li><li><p>DOMImplementation、DOMParser 和 XMLSerializer<br>这些都可用于h5或x5，主要差别是设置合理的MIME和命名空间，详见：javascript_note_document_creation_parsing_serialization.txt</p></li><li><p>格式转换<br>在浏览器中将 h5 和 x5 文档或片段相互转换的方法是使用 Document.importNode/adoptNode 方法，详见：javascript_note_document_creation_parsing_serialization.txt</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> XHTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Epub Reader and Tools</title>
      <link href="2016/05/19/Epub-Reader-and-Tools/"/>
      <url>2016/05/19/Epub-Reader-and-Tools/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Epub OPF</title>
      <link href="2016/05/19/Epub-OPF/"/>
      <url>2016/05/19/Epub-OPF/</url>
      
        <content type="html"><![CDATA[<p>EPub OPF</p><p>*** 规范<br><a href="http://www.idpf.org/epub3/latest/packages" target="_blank" rel="noopener">http://www.idpf.org/epub3/latest/packages</a></p><p>*** 说明<br>** OPF文件包括的部分<br>  元数据 metadata<br>  文件清单 manifest<br>  书脊 spine：一个顶层的内容内容文件的序列，定义了阅读顺序<br>  以上子元素必须按如上顺序排列。</p><p>  Fallback chains — an optional means for Publications to define an ordered list of top-level resources that can be considered content equivalents that a Reading System can choose between for rendering.</p><p>** metadata<br>最小示例：</p><p>&lt;package … unique-identifier=”pub-id”&gt;<br>    …<br>    <metadata xmlns:dc="http://purl.org/dc/elements/1.1/"><br>        &lt;dc:identifier id=”pub-id”&gt;urn:uuid:A1B0D67E-2E81-4DF5-9E67-A64CBE366809</dc:identifier><br>        <a href="dc:title">dc:title</a>Norwegian Wood</dc:title><br>        <a href="dc:language">dc:language</a>en</dc:language><br>        <meta property="dcterms:modified">2011-01-01T12:00:00Z</meta><br>    </metadata><br>    …<br></package></p><p>** manifest<br>  manifest包含多个item子元素。<br>  manifest必须是本epub所使用的资源的完整清单。【不过，如果epub使用一些web服务，或者内嵌远程页面，则这要求难以满足】</p><ul><li><p>item<br>Attributes</p><p>  id [required]</p><pre><code>  The ID [XML] of this element, which must be unique within the document scope.  必须是 XML Name，也就是说必须以字母或下划线开头，只能包含字母、下划线、数字和&#39;-&#39;。这与(x)html的id不同，后者可以是包含除空白外的任意字符。</code></pre><p>  href [required]</p><pre><code>  An IRI [RFC3987] specifying the location of the Publication Resource described by this item. </code></pre><p>  media-type [required]</p><pre><code>  A media type [RFC2046] that specifies the type and format of the Publication Resource described by this item. </code></pre><p>  fallback [conditionally required]</p><pre><code>  An IDREF [XML] that identifies the fallback for a non-Core Media Type.  Refer to Manifest Fallbacks for more information.</code></pre><p>  properties [optional]</p><pre><code>  A space-separated list of property values.  Refer to Manifest item Properties for a set of properties defined by this specification.</code></pre><p>  media-overlay [optional]</p><pre><code>  An IDREF [XML] that identifies the Media Overlay Document for the resource described by this item.  Refer to Packaging [MediaOverlays30] for more information.</code></pre><p>href 可以是相对或绝对的，如果是相对的，则是相对于本OPF的。href也可以引用远程资源。item引用的资源不能重复，也就是说，任意两个href解析为绝对IRI后不能相同。<br>epub 2(<a href="http://www.idpf.org/epub/20/spec/OPF_2.0.1_draft.htm" target="_blank" rel="noopener">http://www.idpf.org/epub/20/spec/OPF_2.0.1_draft.htm</a>) 规定此IRI不能含有片段（fragment identifiers），但是epub 3 没有明确要求。</p><p>media-type 属性的可选值在：<a href="http://tools.ietf.org/html/rfc2046" target="_blank" rel="noopener">http://tools.ietf.org/html/rfc2046</a><br>主要有：application/xhtml+xml，image/svg+xml，text/css，text/html，image/jpeg，application/mathml+xml，application/xml等</p><p>properties 可用于指定该资源的性质、用途。这是个空白分割的列表。可选值在：<a href="http://www.idpf.org/epub/30/spec/epub30-publications.html#sec-item-property-values" target="_blank" rel="noopener">http://www.idpf.org/epub/30/spec/epub30-publications.html#sec-item-property-values</a><br>主要包括：<br>  cover-image：该文件是封面图，0-1个。可以是向量图或点阵图。<br>  mathml：该文件包含一些mathml标签。<br>  nav：该文件是导航文档，有且只有1个。<br>  remote-resources: 该文件引用了远程资源。远程的意思是“在本epub之外”。<br>  scripted：该文件使用了脚本或者HTML表单。<br>  svg：该文件包含一些svg标签。<br>  switch：该文件包含一些epub:switch标签。</p><p>  注意：当上述条件满足时，则必须设置相应的属性；如果不满足，则不得设置相应属性。不过，这个规则并不递归到该文件引用的文件，例如通过iframe引用的文件。</p></li></ul><p>** spine</p><p>  Usage</p><pre><code>Required third child of package, following manifest.</code></pre><p>Attributes</p><pre><code>id [optional]    The ID [XML] of this element, which must be unique within the document scope.toc [optional]    An IDREF [XML] that identifies the manifest item that represents the superseded NCX.    Refer to NCX Superseded for more information.page-progression-direction [optional]    The global direction in which the Publication content flows.    Allowed values are ltr (left-to-right), rtl (right-to-left) and default.    When the default value is specified, the Author is expressing no preference and the Reading System may chose the rendering direction. This value must be assumed when the attribute is not specified.</code></pre><p>Content Model</p><pre><code>Multiple itemref elements [required]</code></pre><p>Element Name</p><pre><code>itemref</code></pre><p>Usage</p><pre><code>As a child of spine. Repeatable.</code></pre><p>Attributes</p><pre><code>idref [required]    An IDREF [XML] that identifies a manifest item. linear [optional]    Specifies whether the referenced content is primary.    The value of the attribute must be yes or no. The default value is yes.id [optional]    The ID [XML] of this element, which must be unique within the document scope.properties [optional]    A space-separated list of property values.    Refer to Spine itemref Properties for a set of properties defined by this specification.</code></pre><p>Content Model</p><pre><code>Empty</code></pre><p>Each itemref element must reference an item in the manifest via its idref attribute.</p><p>Each referenced manifest item must be either a) an EPUB Content Document or b) a</p>]]></content>
      
      
      <categories>
          
          <category> Epub </category>
          
          <category> Kindle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Epub </tag>
            
            <tag> OPF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Epub NCX</title>
      <link href="2016/05/19/Epub-NCX/"/>
      <url>2016/05/19/Epub-NCX/</url>
      
        <content type="html"><![CDATA[<p>Epub NCX</p><p>** 规范<br>NCX是DTBook规范的一部分。<br><a href="http://www.niso.org/workrooms/daisy/Z39-86-2005.html#NCX" target="_blank" rel="noopener">http://www.niso.org/workrooms/daisy/Z39-86-2005.html#NCX</a><br>  Specifications for the Digital Talking Book<br>  8. Navigation Control File (NCX)</p><p>Epub2 规范中的相关章节是：2.4.1: Declarative Global Navigation — the NCX<br><a href="http://www.idpf.org/epub/20/spec/OPF_2.0.1_draft.htm#Section2.4.1" target="_blank" rel="noopener">http://www.idpf.org/epub/20/spec/OPF_2.0.1_draft.htm#Section2.4.1</a></p><p>Epub3 中，NCX被”EPUB Navigation Document”取代了；ncx仍可使用，但仅用于向前兼容，epub3阅读器必须忽略它。<br><a href="http://www.idpf.org/epub/30/spec/epub30-contentdocs.html#sec-xhtml-nav" target="_blank" rel="noopener">http://www.idpf.org/epub/30/spec/epub30-contentdocs.html#sec-xhtml-nav</a></p><p>** 例子<br>8.6 Example</p><p>(This example is informative.)</p><p>Example 8.1:</p><?xml version="1.0"  encoding="UTF-8"?><!DOCTYPE ncx PUBLIC "-//NISO//DTD ncx 2005-1//EN"   "http://www.daisy.org/z3986/2005/ncx-2005-1.dtd"><ncx version="2005-1" xml:lang="en" xmlns="http://www.daisy.org/z3986/2005/ncx/">  <head>    <smilCustomTest id="pagenum" defaultState="false"     override="visible" bookStruct="PAGE_NUMBER"/>    <smilCustomTest id="note" defaultState="true"     override="visible" bookStruct="NOTE"/>    <meta name="dtb:uid" content="us-nls-00001"/>    <meta name="dtb:depth" content="6"/>    <meta name="dtb:generator" content="NLSv001"/>    <meta name="dtb:totalPageCount" content="53"/>    <meta name="dtb:maxPageNumber" content="49"/>  <meta name="generator" content="Hexo 4.2.0"></head>  <docTitle>     <text>Revised Standards and Guidelines of Service      for the Library of Congress Network of Libraries for the      Blind and Physically Handicapped 1995</text>     <audio src="rs_title.mp3" clipBegin="00:00.00" clipEnd="00:09.04"/>     <img src="rs_title.png" />  </docTitle>  <docAuthor>       <text>Association of Specialized and Cooperative        Library Agencies</text>       <audio src="rs_title.mp3" clipBegin="00:09.50" clipEnd="00:14.70"/>  </docAuthor>  <navMap>      <navPoint class="chapter" id="lvl1_3" playOrder="2">        <navLabel>          <text>Foreword</text>          <audio src="rs_fwdx.mp3" clipBegin="00:01.50"           clipEnd="00:02.00" />        </navLabel>        <content src="sample.smil#h1_3" />        <navPoint class="section" id="lvl2_1" playOrder="3">          <navLabel>            <text>History</text>            <audio src="rs_fwdx.mp3" clipBegin="00:03.40"             clipEnd="00:03.90" />          </navLabel>          <content src="sample.smil#h2_1" />        </navPoint>        <navPoint class="section" id="lvl2_2" playOrder="5">          <navLabel>            <text>Development of Standards</text>            <audio src="rs_fwdx.mp3" clipBegin="00:56.30"             clipEnd="00:57.70" />          </navLabel>          <content src="sample.smil#h2_2" />        </navPoint>      </navPoint>      <navPoint class="chapter" id="lvl1_7" playOrder="10">        <navLabel>          <text>Standards</text>          <audio src="rs_stdx.mp3" clipBegin="00:01.30"           clipEnd="00:02.10" />        </navLabel>        <content src="sample.smil#h1_7" />        <navPoint class="section" id="lvl2_11" playOrder="11">          <navLabel>            <text>1 Core Services</text>            <audio src="rs_stdx.mp3" clipBegin="00:02.90"             clipEnd="00:04.90" />          </navLabel>          <content src="sample.smil#h2_10" />          <navPoint class="subsection" id="lvl3_1" playOrder="12">            <navLabel>              <text>1.1</text>              <audio src="rs_stdx.mp3" clipBegin="00:05.70"               clipEnd="00:06.70" />            </navLabel>            <content src="sample.smil#h3_1" />            <navPoint class="sub-subsection" id="lvl4_1" playOrder="13">              <navLabel>                <text>a.</text>                <audio src="rs_stdx.mp3" clipBegin="00:18.70"                 clipEnd="00:19.10" />              </navLabel>              <content src="sample.smil#h4_1" />            </navPoint>          </navPoint>          <navPoint class="subsection" id="lvl3_2" playOrder="14">            <navLabel>              <text>1.2</text>              <audio src="rs_stdx.mp3" clipBegin="00:50.50"               clipEnd="00:51.40" />            </navLabel>            <content src="sample.smil#h3_2" />          </navPoint>        </navPoint>      </navPoint>      . . .   </navMap>  <pageList id="pages">    <navLabel>        <text>Pages</text>        <audio src="navlabels.mp3" clipBegin="00:00.00"         clipEnd="00:01.10" />    </navLabel>    <pageTarget class="pagenum" type="normal" id="p1" value="1" playOrder="1">      <navLabel>        <text>1</text>        <audio src="rs_fwdx.mp3" clipBegin="00:00.00"         clipEnd="00:00.90" />      </navLabel>      <content src="sample.smil#p1" />    </pageTarget>    <pageTarget class="pagenum" type="normal" id="p2" value="2" playOrder="4">      <navLabel>        <text>2</text>        <audio src="rs_fwdx.mp3" clipBegin="00:53.90"         clipEnd="00:54.60" />      </navLabel>      <content src="sample.smil#p2" />    </pageTarget>    <pageTarget class="pagenum" type="normal" id="p3" value="3" playOrder="9">      <navLabel>        <text>3</text>        <audio src="rs_stdx.mp3" clipBegin="00:00.00"         clipEnd="00:00.70" />      </navLabel>      <content src="sample.smil#p3" />    </pageTarget>    . . .  </pageList>  <navList id="notes" class="note">    <navInfo>        <text>This list contains the three notes found in this book.              Each entry in the list, numbered 1 through 3, points to a note reference.        </text>        <audio src="rs_info.mp3" clipBegin="00:00.00"        clipEnd="00:05.592" />    </navInfo>    <navLabel>        <text>Notes</text>        <audio src="navlabels.mp3" clipBegin="00:01.50"         clipEnd="00:02.60" />    </navLabel>    <navTarget class="note" id="nref_1" playOrder="6">      <navLabel>        <text>1</text>        <audio src="rs_fwdx.mp3" clipBegin="01:22.60"         clipEnd="01:23.50" />      </navLabel>      <content src="sample.smil#nref_1" />    </navTarget>    <navTarget class="note" id="nref_2" playOrder="7">      <navLabel>        <text>2</text>        <audio src="rs_fwdx.mp3" clipBegin="02:00.60"         clipEnd="02:01.40" />      </navLabel>      <content src="sample.smil#nref_2" />    </navTarget>    <navTarget class="note" id="nref_3" playOrder="8">      <navLabel>        <text>3</text>        <audio src="rs_fwdx.mp3" clipBegin="03:13.30"         clipEnd="03:14.10" />      </navLabel>      <content src="sample.smil#nref_3" />    </navTarget>  </navList></ncx><p>** 说明<br>NCX 主要靠 navMap 来表示书籍的逻辑层次结构。navMap下的navPoint元素表示目录树中的一个节点。navPoint是可以嵌套的。<br>与navMap平级的还有 pageList 和 navList，分别用于表示页序列和索引（脚注、图表等）。</p><p>navMap必须出现一次，pageList可以出现一次，navList可以出现零到多次。</p><p>navMap、pageList、navList 下子元素的 playOrder 属性提供了一种同步机制，可以根据章节找到页码或者根据页码找到章节。<br>不过，在不同的结构中的 playOrder 不必严格对应，阅读器会找到最接近的。</p><p>注意：playOrder 属性在Epub中不是必需的，但在DTBook中是。如果想省略playOrder，则ncx文件不能引用dtd。</p><ul><li>navPoint<br>主要属性：<br>class 节点类别，可取的值是chapter, section, subsection, sub-subsection等。可选，值也不是规范的一部分。<br>id 标识符，必需。<br>playOrder 播放顺序，应为正整数。必需。</li></ul><p>主要子元素：<br>navLabel：节点上显示的文字或播放的声音。文本放在text子元素中，声音放在audio中。必需。<br>content：navPoint指向的内容，其src是内容所在的URL。必需。<br>navPoint：子节点。</p><ul><li>pageTarget<br>pageList 的内容是 pageTarget 的序列。pageTarget不能嵌套。</li></ul><p>主要属性：<br>id 必需。<br>class 值为 pagenum，可选<br>type 页码的类型，值为 front | normal | special，必需。<br>value 页码的值，正整数，可选。与type的组合必需唯一。<br>playOrder 为阅读顺序，必需。<br>子元素：<br>navLabel 其text表示页码，必需。<br>content 必需。</p><ul><li>navTarget<br>navList 的内容是 navTarget 的序列。navTarget不能嵌套。<br>主要属性：<br>id 必需。<br>class 值为 note 等<br>playOrder 为阅读顺序，必需。<br>子元素：<br>navLabel<br>content</li></ul><p>** 在OPF中注册<br><package version="2.0" xmlns="http://www.idpf.org/2007/opf" unique-identifier="BookId"></p>  <manifest>    <item id="chapter1" href="chapter1.xhtml" media-type="application/xhtml+xml"/>    ...    <item id="ncx" href="toc.ncx" media-type="application/x-dtbncx+xml"/>  </manifest>  <spine toc="ncx">    <itemref idref="chapter1" />    ...  </spine></package><p>spine元素的toc属性，可以引用manifest中的ncx文件的id。<br>spine元素的itemref仍可继续引用其它项目。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Epub </tag>
            
            <tag> OPF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jxggraphBoard</title>
      <link href="2016/05/19/jsxgraphBoard/"/>
      <url>2016/05/19/jsxgraphBoard/</url>
      
        <content type="html"><![CDATA[<h1 id="JXG-Board"><a href="#JXG-Board" class="headerlink" title="JXG.Board"></a>JXG.Board</h1><p>  JXG提供的一个画板<br>  Defined in board.js</p><ul><li>Class:JXG.Board</li><li>说明：<br>通常情况我们不会直接使用这个构造器<br>因此提供了一个便捷的方式来构造一个画板,因此主要采用下面的方式来构造一个JXG画板<br>JXG.JSXGraph.initBoard()<h2 id="JXG-JSXGraph-initBoard"><a href="#JXG-JSXGraph-initBoard" class="headerlink" title="JXG.JSXGraph.initBoard"></a>JXG.JSXGraph.initBoard</h2>一个单例的画板构造器<br>Definde in jsxgraph.js</li><li>Class:JXG.JSXGraph</li><li>Field:<br>static JXG.JSXGraph.renderType 用于存储画板的渲染器</li><li>method：<ul><li>JXG.JSXGraph.freeBoard(board)<br>删除一个画板内的所有内容，board为Dom元素ID</li><li>JXG.JSXGraph.initBoard(box,attribute)<br>初始化一个画板 box为装board的一个容器的id，attribute是一个对象参数（好像不用区分大小写，需验证）</li><li>JXG.JSXGraph.loadBoardFromFile(box,file,format,attributes,callback)<br>从一个文件（GEONExT，Intergeo，Geogebra，Cinderella）加载一个画板</li><li>JXG.JSXGraph.loadBoardFromString(box,string,format,attributes,callback)<br>从一个base64编码的字符串加载一个画板 参数同loadBoardFromFile</li><li>JXG.JSXGraph.registerElement(element,creator)<br>采用JXG.registerElement</li></ul></li><li>attributes<ul><li>box dom元素的id</li><li>attributes是一个可选对象 Defined in option.js <ul><li>boundingbox 一个4个数字的数组，用于描述画板的可用坐标的范围。default:[-5,5,5,-5] – [x1,y1,x2,y2]，可用理解为x轴与y轴的范围</li><li>keepaspectratio 一个布尔值 是否保持等比，default：true，建议不用改，因为如果是想画一个圆而不是一个椭圆 </li><li>showCopyright   一个布尔值 用于显示jsx版权 左上角  default：true</li><li>showNavigation  一个布尔值 显示菜单按钮    右下角  default：true</li><li>maxNameLenght  一个数值    自动标签生成中的最大数字数。例如，如果设置为1个自动点标签结束在“Z”。如果设置为2，点标签结束在“ZZ”</li><li>name           一个字符串svg all none   svg表示在每一个重绘的svg子树dom都来这dom，all表示完整dom来自dom，none表示在原始位置，<br>svg 或 all会加速渲染过程，风险就是不知道异常仅仅只有一个白色div or window在左边 default:’svg’</li><li>offsetX        一个数值 将被添加到鼠标坐标计算中使用的板的绝对位置的数字  default:0</li><li>offsetY        一个数值 将被添加到鼠标坐标计算中使用的板的绝对位置的数字  default:0</li><li>zoom           一个对象 支持鼠标滑轮，2个手指缩放<br>  zoom: {<pre><code>        factorX: 1.25,  // horizontal zoom factor (multiplied to JXG.Board#zoomX)        factorY: 1.25,  // vertical zoom factor (multiplied to JXG.Board#zoomY)        wheel: false,     // allow zooming by mouse wheel or            // by pinch-to-toom gesture on touch devices        eedshift: false, // mouse wheel zooming needs pressing of the shift key        min: 0.001        // minimal values of JXG.Board#zoomX and JXG.Board#zoomY, limits zoomOut        max: 1000.0       // maximal values of JXG.Board#zoomX and JXG.Board#zoomY, limits zoomIn    }</code></pre></li><li>pan             一个对象 允许shift+鼠标或2个手指pan手势<br>  pan: {<pre><code>    enabled: true   // Allow panning    needTwoFingers: true, // panning is done with two fingers on touch devices    needshift: true, // mouse panning needs pressing of the shift key</code></pre>  }               </li><li>axis            一个布尔值 是否显示坐标轴 </li><li>grid            一个布尔值 是否显示网格</li><li>registerEvent   一个布尔值 允许用户注册鼠标或触碰事件  default：true</li><li>showClearTraces 一个布尔值 是否显示清除按钮 功能：清除在画板种得所有痕迹 default：false</li><li>showReload      一个布尔值 是否显示强制重载按钮 default：true</li><li>takeFirst       一个布尔值 把设置了JXG.Boardobject hasPoint==true的元素作为拖拽元素</li><li>zoomFactor      一个数值内心额外的缩放因数</li></ul></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JXGGraph </tag>
            
            <tag> Board </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Epub Navigation Documents</title>
      <link href="2016/05/19/Epub-Navigation-Documents/"/>
      <url>2016/05/19/Epub-Navigation-Documents/</url>
      
        <content type="html"><![CDATA[<p>EPUB Navigation Documents</p><p>** 规范<br><a href="http://www.idpf.org/epub/30/spec/epub30-contentdocs.html#sec-xhtml-nav" target="_blank" rel="noopener">http://www.idpf.org/epub/30/spec/epub30-contentdocs.html#sec-xhtml-nav</a></p><p>** 说明<br>EPUB Navigation Document（以下简称END或导航文档）是epub3的导航文档，用于取代epub2的ncx文档。<br>ncx仍可使用，但仅用于向前兼容，epub3阅读器必须忽略它。</p><p>每个epub中有且仅有一个导航文档，不过还可以有一个ncx文档。</p><p>导航文档首先必须是符合 epub3 内容文档要求的 xhtml 文件。</p><p>导航文档使用一个或多个nav元素来表示一个导航结构，如目录、图表索引等。</p><p>nav下使用嵌套的ol/li元素来表示导航的层次结构。<br>li中用a元素来指向实际内容。a以外还可以用span来加入说明性内容。</p><p>nav的开头可以有标题（heading），用h1-h6以及hgroup表示。</p><p>nav的epub:type表示导航的类型，取值可以是<br>toc 目录 table of contents<br>page-list 页码列表。这种nav的ol只能有一层。<br>lot 表格索引 List of tables<br>loi 图形索引 List of Illustrations<br>landmarks 地标</p><p>toc必须出现一次，page-list、landmarks最多出现一次。</p><p>注意 epub 命名空间是： xmlns:epub=”<a href="http://www.idpf.org/2007/ops&quot;" target="_blank" rel="noopener">http://www.idpf.org/2007/ops&quot;</a></p><ul><li><p>隐藏某些导航或其一部分<br>page-list等类型的nav通常不希望直接作为HTML显示出来，或者导航的某些部分不希望直接显示，这时可以用HTML5的hidden属性。注意，不应该使用CSS display:none，因为不是所有的reader都支持CSS。</p></li><li><p>在OPF中注册<br>参考：<br><a href="http://www.idpf.org/epub/30/spec/epub30-publications.html#sec-item-property-values" target="_blank" rel="noopener">http://www.idpf.org/epub/30/spec/epub30-publications.html#sec-item-property-values</a></p><p>导航文档应在 OPF 文件中注册，具体方法是在 Manifest 的 item 元素的 properties 属性中加入 nav 值。<br>properties 是个空白分割的字符串。</p></li></ul><p>** 例子</p><ul><li>toc<br>The following example shows a partial toc nav element where the hidden attribute is used to limit content flow rendering to the two topmost hierarchical levels.</li></ul><nav epub:type="toc" id="toc">  <h1>Table of contents</h1>  <ol>    <li>      <a href="chap1.xhtml">Chapter 1</a>      <ol>        <li>          <a href="chap1.xhtml#sec-1.1">Chapter 1.1</a>          <ol hidden="">            <li>              <a href="chap1.xhtml#sec-1.1.1">Section 1.1.1</a>            </li>            <li>              <a href="chap1.xhtml#sec-1.1.2">Section 1.1.2</a>            </li>          </ol>         </li>         <li>           <a href="chap1.xhtml#sec-1.2">Chapter 1.2</a>         </li>       </ol>     </li>    <li>      <a href="chap2.xhtml">Chapter 2</a>    </li>  </ol></nav><ul><li>page-list<br>The following example shows a partial page-list nav element. The presence of the hidden attribute on the root indicates that the entire list is excluded from rendering in the content flow.</li></ul><nav epub:type="page-list" hidden="">    <h2>Pagebreaks of the print version, third edition</h2>    <ol>        <li><a href="frontmatter.xhtml#pi">I</a></li>        <li><a href="frontmatter.xhtml#pii">II</a></li>        <li><a href="chap1.xhtml#p1">1</a></li>        <li><a href="chap1.xhtml#p2">2</a></li>    </ol></nav><ul><li>landmarks 的例子<br>The following example shows a landmarks nav element with structural semantics drawn from the EPUB Structural Semantics Vocabulary.</li></ul><nav epub:type="landmarks">    <h2>Guide</h2>    <ol>        <li><a epub:type="toc" href="#toc">Table of Contents</a></li>        <li><a epub:type="loi" href="content.html#loi">List of Illustrations</a></li>        <li><a epub:type="bodymatter" href="content.html#bodymatter">Start of Content</a></li>    </ol></nav>]]></content>
      
      
      
        <tags>
            
            <tag> Epub </tag>
            
            <tag> OPF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Epub Fixed Layout</title>
      <link href="2016/05/19/Epub-Fixed-Layout/"/>
      <url>2016/05/19/Epub-Fixed-Layout/</url>
      
        <content type="html"><![CDATA[<p>*** 描述<br>** 引言<br>EPUB 3 允许其内容是固定版式文档（Fixed-Layout Document），也就是页面内容位置大小固定，不可重排。<br>以下将固定版式文档简称为“版式文档”，而可重排文档（Reflowable Document)简称为“流式文档”。</p><p>** 文档结构<br>epub 版式文档的内容文档可以是XHTML、SVG、位图，后两者不必包含在XHTML中。<br>内容文档一般是每页一个独立文件，每页的文档应该在spine中列举。</p><p>规范似乎没有强制要求每页一个独立文件，似乎可以将多个页放在一个html中，然后用html片段url来指向它们。<br>规范似乎并没有明确说manifest中的URI不能仅仅是片段部分不同。不过，不清楚这种做法能否被reader支持。</p><p>** OPF 中的描述</p><ul><li>例子<package xmlns="http://www.idpf.org/2007/opf" version="3.0" xml:lang="en" unique-identifier="pub-id" prefix="rendition: http://www.idpf.org/vocab/rendition/#"></li></ul><metadata xmlns:dc="http://purl.org/dc/elements/1.1/">  ...    <meta property="rendition:layout">pre-paginated</meta>    <meta property="rendition:orientation">landscape</meta>    <meta property="rendition:spread">none</meta></metadata><p>…</p><spine page-progression-direction="ltr">    <itemref idref="cover" linear="yes" properties="rendition:page-spread-center"/>    ...</spine><p>根元素 package 的 prefix 属性定义了命名空间前缀rendition，不过这个不是xml命名空间，而是用于meta property、item properties、itemref properties等属性的值的。</p><p>rendition的意思是翻译，但这里的意思更接近“版本”。</p><p>metadata中3个rendition:属性表明，这是个固定版式的（预先分页的，pre-paginated）书，<br>并且是横版（landscape）。</p><ul><li><p>layout<br>rendition:layout 的值可以是 reflowable 或 pre-paginated，表明一本书是流式还是版式，默认值是 reflowable。<br>metadata中的这个属性可以被 spine/itemref 的 rendition:layout 属性覆盖，表示个别内容文档采取流式还是版式排版。</p></li><li><p>orientation<br>作者希望采取的屏幕方向。可以是 landscape | portrait | auto。这也可以被 spine/itemref 的 rendition:orientation 覆盖。<br>默认值是auto，意思是未指定方向。</p></li><li><p>spread<br>rendition:spread 的意思是“展开”，表示怎样在一个屏幕上并列显示两个相邻的页面，以下简称“并列显示”。其值可以是：<br>none：不要并列显示。<br>landscape：仅当屏幕横置时并列显示。<br>portrait：仅当竖屏时并列显示。<br>both：总是并列显示。<br>auto：让阅读器选择是否并列显示。这是默认值。</p></li></ul><p>metadata中的设置的spread是全局的，在spine的itemref元素中，可以用 rendition:spread 属性加以覆盖，值仍然是上面那些。</p><p>spine page-progression-direction 表示翻页的方向，对应纸书的装订方向。如果同时使用了spread，这个会影响并列时哪一页在左边。其值可以是ltr或rtl。</p><p>翻页方向也可以用spine的itemref元素的 properties 属性的 rendition:page-spread-* 加以覆盖。其中*部分可以是：<br>center：本页不并列，居中显示。<br>left：本页位于左边。<br>right：本页位于右边。</p><p>page-spread-*不限于用于版式文档，也可用于流式文档。</p><ul><li>在spine/itemref中rendition:*属性的写法<br>就是把属性名和值之间用-连接，放到properties的值中。例如<br>rendition:layout=”reflowable” 的写法是：<br>&lt;itemref … properties=”rendition:layout-reflowable”/&gt; </li></ul><p>** 内容文档的视口尺寸</p><ul><li><p>XHTML<br>使用meta viewport，单位是CSS像素。</p><head>  <meta name="viewport" content="width=1200, height=600"/><meta name="generator" content="Hexo 4.2.0"></head></li><li><p>SVG<br>使用viewBox属性，单位还是CSS像素。<br><svg xmlns="http://www.w3.org/2000/svg"  version="1.1" width="100%" height="100%"  viewBox="0 0 844 1200"><br>  …</p></svg></li><li><p>位图<br>把图像的物理像素当成CSS像素，作为视口尺寸。</p></li></ul><p>*** 参考<br>** 规范<br>EPUB 3 Fixed-Layout Documents<br><a href="http://www.idpf.org/epub/fxl" target="_blank" rel="noopener">http://www.idpf.org/epub/fxl</a></p><p>** 分析</p><ul><li><p>Fixed Layout Test books<br><a href="http://apex.infogridpacific.com/dcp/flo-test-books.html" target="_blank" rel="noopener">http://apex.infogridpacific.com/dcp/flo-test-books.html</a><br>A range of aspect ratio and viewport size books exploring the various options in the IDPF Fixed Layout Specification and a discussion on design decisions.</p></li><li><p>ePub3 Fixed Layout Packaging<br><a href="http://apex.infogridpacific.com/df/epub3packaging-flo.html" target="_blank" rel="noopener">http://apex.infogridpacific.com/df/epub3packaging-flo.html</a></p></li></ul><p>** 样书及其制作</p><ul><li><p>Fixed Layout (FLO) Demonstration ePub3 Documents<br><a href="http://azardi.infogridpacific.com/resources.html" target="_blank" rel="noopener">http://azardi.infogridpacific.com/resources.html</a></p></li><li><p>Famous Paintings<br><a href="http://apex.infogridpacific.com/dcp/flo-famous-paintings.html" target="_blank" rel="noopener">http://apex.infogridpacific.com/dcp/flo-famous-paintings.html</a><br>This book was designed to demonstrate two AZARDI Fixed Layout ePub3 things:<br>  The advanced navigation features available in AZARDI<br>  The use of ePub3 to present image rich content in a new, different and better way.</p></li></ul><p>*** 软件<br>** Reader</p><p>** Editor</p><ul><li>IGP:Digital Publisher<br><a href="http://www.infogridpacific.com/DigitalPublisher.html" target="_blank" rel="noopener">http://www.infogridpacific.com/DigitalPublisher.html</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Epub </tag>
            
            <tag> OPF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Epub Content Document</title>
      <link href="2016/05/19/Epub-Content-Document/"/>
      <url>2016/05/19/Epub-Content-Document/</url>
      
        <content type="html"><![CDATA[<p>EPUB Content Document</p><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p><a href="http://www.idpf.org/epub3/latest/contentdocs" target="_blank" rel="noopener">http://www.idpf.org/epub3/latest/contentdocs</a></p><p>*** 概述</p><ul><li><p>与h5（HTML 5）的关系<br>ecd 采用 XHTML 5语法，并有少量扩展。<br>XHTML5 与 HTML5 的差异和兼容请参考：HTML5 vs XHTML5.txt<br>h5中的部分特性是可选的，包括脚本、表单等。</p></li><li><p>SVG<br>SVG 1.1 也是ecd的一种，不过有一些限制。</p></li><li><p>CSS<br>ecd 采用CSS 2.1和部分 CSS 3特性，还定义了一些扩展。</p></li><li><p>命名空间<br>prefix     namespace URI<br>epub     <a href="http://www.idpf.org/2007/ops" target="_blank" rel="noopener">http://www.idpf.org/2007/ops</a><br>m     <a href="http://www.w3.org/1998/Math/MathML" target="_blank" rel="noopener">http://www.w3.org/1998/Math/MathML</a><br>pls     <a href="http://www.w3.org/2005/01/pronunciation-lexicon" target="_blank" rel="noopener">http://www.w3.org/2005/01/pronunciation-lexicon</a><br>ssml     <a href="http://www.w3.org/2001/10/synthesis" target="_blank" rel="noopener">http://www.w3.org/2001/10/synthesis</a><br>svg     <a href="http://www.w3.org/2000/svg" target="_blank" rel="noopener">http://www.w3.org/2000/svg</a></p></li></ul><p>*** 各种 Content Document<br>** XHTML 文档<br>ecd中的 HTML 文档必须用 XHTML 5 语法，并且以 .xhtml 作为扩展名。</p><ul><li>扩展 </li></ul><ul><li>epub:type 属性<br>语法是空格分割的值，可用于 h5 元素上扩展其语义。例如：<br><a epub:type="noteref" href="#n1">1</a><aside epub:type="footnote" id="n1"></li></ul><p>可用的值选自“EPUB 3 Structural Semantics Vocabulary”：<br> <a href="http://www.idpf.org/epub/vocab/structure/#" target="_blank" rel="noopener">http://www.idpf.org/epub/vocab/structure/#</a></p><p>不过并不要求 reader 对这个属性作出反应。</p><ul><li><p>SSML Attributes<br>W3C Speech Synthesis Markup Language</p></li><li><p>Content Switching<br>reader 必须支持此特性。<br>epub:switch Element</p></li><li><p>epub:trigger Element<br>The trigger element enables the creation of markup-defined user interfaces for controlling multimedia objects, such as audio and video playback, in both scripted and non-scripted contexts.<br>也就是一种不用JS脚本的UI编程技术。<br>支持视频音频的 reader 必须支持 epub:trigger。</p></li></ul><p>例子：</p><html xmlns="http://www.w3.org/1999/xhtml"  xmlns:epub="http://www.idpf.org/2007/ops"  xmlns:ev="http://www.w3.org/2001/xml-events">  <head>    <epub:trigger ev:observer="pause" ev:event="click" action="pause" ref="test"/>    <epub:trigger ev:observer="resume" ev:event="click" action="resume" ref="test"/>    <epub:trigger ev:observer="mute" ev:event="click" action="mute" ref="test"/>    <epub:trigger ev:observer="mute" ev:event="click" action="show" ref="muted"/>    <epub:trigger ev:observer="unmute" ev:event="click" action="unmute" ref="test"/>    <epub:trigger ev:observer="unmute" ev:event="click" action="hide" ref="muted"/>  <meta name="generator" content="Hexo 4.2.0"></head>  <body>    <video id="test" src="birds.mp4" width="320" height="240"/>    <p>      <span class="button" id="resume">Play/Resume</span>      <span class="button" id="pause">Pause</span>      <span class="button" id="mute">Mute</span>      <span class="button" id="unmute">Unmute</span>      <span id="muted">MUTED</span>    </p>  </body></html><ul><li>Alternate Style Tags<br>根据环境选择不同样式表的机制。例如<link rel="stylesheet" href="horizontal.css" class="horizontal"/>规范：http://www.idpf.org/epub/altss-tags/</li></ul><p>reader应当支持此扩展。</p><ul><li>MathML<br>reader必须支持MathML，但主要限于 Presentation MathML，Content MathML 支持是可选的。</li></ul><p>** CSS</p><ul><li>规范<br>对CSS2.1的要求：<br>position 属性不能有fixed值；direction 和 unicode-bidi 属性不能用。</li></ul><p>对CSS3的要求：</p><p>以下模块要采用 -epub-前缀：<br>CSS 3.0 Speech<br> -epub-cue<br> -epub-pause<br> -epub-rest<br> …<br>CSS Text Level 3<br> -epub-hyphens*<br> -epub-line-break<br> -epub-text-align-last<br> …<br>未来随着CSS3定稿，可以去掉前缀。</p><p>webfont 必须支持 OpenType 和 WOFF 两种格式。</p><p>支持 @media and @import</p><p>支持 @namespace</p><p>支持多列布局</p><ul><li>分页<br>epub 并不要求reader支持分页显示流式文档，但很多reader是实现了此功能的。<br>在这类reader上，CSS 属性 page-break-inside, page-break-before 和 page-break-after 等可以用于控制分页行为，就像在打印设备上一样。<br>参考：<br><a href="http://electricbookworks.com/kb/creating-epub-from-indesign/after-indesign-export-to-epub/page-breaks/" target="_blank" rel="noopener">http://electricbookworks.com/kb/creating-epub-from-indesign/after-indesign-export-to-epub/page-breaks/</a></li></ul><p>** EPUB Navigation Documents<br>是XHTML 文档的一种，详见 EPub Navigation Documents.txt</p><p>** SVG Content Documents<br>应当符合 SVG 1.1 (Second Edition) specification。<br>其它要求：<br>不能有动画（ Animation Elements and Animation event attributes）。<br>svg:foreignObject 只能包含 xhtml 内容。</p><p>SVG 可以独立作为文档，也可以被XHTML文档引用，也可以嵌入XHTML。</p><p>** Scripted Content Documents</p><p>脚本可以出现在顶层内容文档中，也可以出现在顶层内容文档的iframe中。<br>前者称为 spine-level scripting，后者称为 container-constrained scripting。<br>reader必须支持后者，前者则是可选的。<br>reader必须阻止后者的脚本访问父文档以及其它文档，类似h5 sandboxed iframe。</p><p>reader必须提供 navigator.epubReadingSystem 对象，有以下属性和方法：</p><p>name     Returns a String value representing the name of the Reading System (e.g., iBooks, Kindle).<br>version     Returns a String value representing the version of the Reading System (e.g., 1.0, 2.1.1).<br>layoutStyle typically return one of the values paginated or scrolling, but may define values for any additional layout formats it supports.</p><p>hasFeature(feature[, version]) 特性查询。以下特性名字必须被识别：</p><p>dom-manipulation     Scripts may make structural changes to the document’s DOM (applies to spine-level scripting only).<br>layout-changes     Scripts may modify attributes and CSS styles that affect content layout (applies to spine-level scripting only).<br>touch-events     The device supports touch events and the Reading System passes touch events to the content.<br>mouse-events     The device supports mouse events and the Reading System passes mouse events to the content.<br>keyboard-events     The device supports keyboard events and the Reading System passes keyboard events to the content.<br>spine-scripting     Spine-level scripting is supported.</p><p>*** 安全问题<br>以下均为建议。<br>每本epub书应被视为来自一个独立的域。如果提供本地存储，不同的书之间应该是被隔离的。</p><p>*** 事件模型<br>采用h5事件。</p><p>*** PLS Documents<br>The W3C Pronunciation Lexicon Specification [PLS] defines syntax and semantics for XML-based pronunciation lexicons to be used by Automatic Speech Recognition and Text-to-Speech (TTS) engines.</p><p>reader如果支持TTS则必须支持PLS。</p><p>例子：</p><html … >        <head>        …        <link rel="pronunciation" type="application/pls+xml" hreflang="zh" href="../speech/zh.pls"/>        <link rel="pronunciation" type="application/pls+xml" hreflang="mn" href="../speech/mn.pls"/>    </head>            …</html>]]></content>
      
      
      
        <tags>
            
            <tag> Epub </tag>
            
            <tag> OPF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown syntax</title>
      <link href="2016/05/19/markdown-syntax/"/>
      <url>2016/05/19/markdown-syntax/</url>
      
        <content type="html"><![CDATA[<p>标题</p><h1 id="H1-一级标题"><a href="#H1-一级标题" class="headerlink" title="H1 一级标题"></a>H1 一级标题</h1><h2 id="H2-二级标题"><a href="#H2-二级标题" class="headerlink" title="H2 二级标题"></a>H2 二级标题</h2><h3 id="H3-三级标题"><a href="#H3-三级标题" class="headerlink" title="H3 三级标题"></a>H3 三级标题</h3><h4 id="H4-四级标题"><a href="#H4-四级标题" class="headerlink" title="H4 四级标题"></a>H4 四级标题</h4><h5 id="H5-五级标题"><a href="#H5-五级标题" class="headerlink" title="H5 五级标题"></a>H5 五级标题</h5><h6 id="H6-六级标题"><a href="#H6-六级标题" class="headerlink" title="H6 六级标题"></a>H6 六级标题</h6><p>[TOC]</p><p>文本强调</p><p><em>斜体</em><br><strong>加粗</strong><br><strong><em>粗斜体</em></strong></p><p>列表</p><ul><li>无序列表</li><li>子项</li><li>子项</li></ul><ul><li>无序列表</li><li>子项</li><li>子项</li></ul><ul><li>无序列表</li><li>子项</li><li>子项</li></ul><p>有序列表</p><ol><li><p>第一行</p></li><li><p>第二行</p></li><li><p>第三行</p></li><li><p>第一行</p></li></ol><ul><li>第二行</li><li>第三行</li></ul><p>组合：</p><ul><li><p>产品介绍（子项无项目符号）<br>  此时子项，要以一个制表符或者2个空格缩进</p></li><li><p>产品特点</p><ol><li>特点1</li></ol><ul><li>特点2</li><li>特点3</li></ul></li><li><p>产品功能</p><ol><li>功能1</li></ol><ul><li>功能2</li><li>功能3</li></ul></li></ul><p>Links 连接（title为可选项）：</p><p>Inline-style 内嵌方式：<br><a href="https://www.google.com" target="_blank" rel="noopener" title="title text">link text</a></p><p>Reference-style 引用方式：<br>[link text][id]<br>[id]: <a href="https://www.mozilla.org" target="_blank" rel="noopener">https://www.mozilla.org</a> “title text”</p><p>Relative reference to a repository file 引用存储文件：<br><a href="../path/file/readme.text" title="title text">link text</a></p><p>还能这样使用：<br>[link text][]<br>[link text]: <a href="http://www.reddit.com" target="_blank" rel="noopener">http://www.reddit.com</a></p><p>Email 邮件：<br><a href="mailto:&#101;&#x78;&#97;&#x6d;&#x70;&#x6c;&#x65;&#x40;&#101;&#120;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#x6d;">&#101;&#x78;&#97;&#x6d;&#x70;&#x6c;&#x65;&#x40;&#101;&#120;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#x6d;</a><br>Images 图片：</p><p>Inline-style 内嵌方式：<br><img src="https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png" alt="alt text" title="title text"></p><p>Reference-style 引用方式：<br>![alt text][logo]<br>[logo]: <a href="https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png" target="_blank" rel="noopener">https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png</a> “title text”</p><p>如果高亮的内容包含<code>号，可以这样写：``</code>包裹起来` ``</p><p>语法高亮：</p><pre><code class="html">    &lt;div&gt;Syntax Highlighting&lt;/div&gt;</code></pre><pre><code class="css">    body{font-size:12px}</code></pre><pre><code class="javascript">    var s = &quot;JavaScript syntax highlighting&quot;;    alert(s);</code></pre><pre><code class="php">    &lt;?php      echo &quot;hello, world!&quot;;    ?&gt;</code></pre><pre><code class="python">    s = &quot;Python syntax highlighting&quot;    print s</code></pre><p>Block Code 代码分组(代码区块)：</p><p>在该行开头缩进4个空格或一个制表符(tab)</p><p><strong>Blockquotes 引用：</strong></p><blockquote><p>Email-style angle brackets<br>are used for blockquotes.</p><blockquote><p>And, they can be nested.</p></blockquote><h4 id="Headers-in-blockquotes"><a href="#Headers-in-blockquotes" class="headerlink" title="Headers in blockquotes"></a>Headers in blockquotes</h4><ul><li>You can quote a list.</li><li>Etc.</li></ul></blockquote><p>Hard Line Breaks 换行：</p><p>在一行的结尾处加上2个或2个以上的空格，也可以使用</br>标签<br>第一行文字，<br>第二行文字</p><p>Escape character 转义符(反斜杠)：</p><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果，你可以在星号的前面加上反斜杠：<br>*literal asterisks*<br>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：<br>\反斜杠  `反引号  *星号  _下划线  {}花括号  []方括号  ()括弧  #井字号  +加号  -减号  .英文句 !感叹号</p><p>Additional 补充：</p><p>Markdown也支持传统的HTML标签。<br>比如一个链接，你不太喜欢Markdown的写法，也可以直接写成<a href="http://www.baidu.com" target="_blank" rel="noopener">百度</a></p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table><thead><tr><th align="left">Item</th><th align="right">Value</th><th align="center">Qty</th></tr></thead><tbody><tr><td align="left">Computer</td><td align="right">1600 USD</td><td align="center">5</td></tr><tr><td align="left">Phone</td><td align="right">12 USD</td><td align="center">12</td></tr><tr><td align="left">Pipe</td><td align="right">1 USD</td><td align="center">234</td></tr></tbody></table><p><strong>马克飞象</strong>是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述：</p><ul><li><strong>功能丰富</strong> ：支持高亮代码块、<em>LaTeX</em> 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手；</li><li><strong>得心应手</strong> ：简洁高效的编辑器，提供[桌面客户端][1]以及[离线Chrome App][2]，支持移动端 Web；</li><li><strong>深度整合</strong> ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。</li></ul><hr><p>[TOC]</p><h2 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h2><blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">维基百科</a></p></blockquote><p>正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.example.com" target="_blank" rel="noopener">链接</a>或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按<code>Ctrl + /</code>查看帮助。 </p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><pre><code class="python">@requires_authorizationdef somefunc(param1=&#39;&#39;, param2=0):    &#39;&#39;&#39;A docstring&#39;&#39;&#39;    if param1 &gt; param2: # interesting        print &#39;Greater&#39;    return (param2 - param1 + 1) or Noneclass SomeClass:    pass&gt;&gt;&gt; message = &#39;&#39;&#39;interpreter... prompt&#39;&#39;&#39;</code></pre><h3 id="LaTeX-公式"><a href="#LaTeX-公式" class="headerlink" title="LaTeX 公式"></a>LaTeX 公式</h3><p>可以创建行内公式，例如 $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。或者块级公式：</p><p>$$    x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p><h3 id="表格-1"><a href="#表格-1" class="headerlink" title="表格"></a>表格</h3><table><thead><tr><th align="left">Item</th><th align="right">Value</th><th align="center">Qty</th></tr></thead><tbody><tr><td align="left">Computer</td><td align="right">1600 USD</td><td align="center">5</td></tr><tr><td align="left">Phone</td><td align="right">12 USD</td><td align="center">12</td></tr><tr><td align="left">Pipe</td><td align="right">1 USD</td><td align="center">234</td></tr></tbody></table><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><pre><code class="flow">st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op</code></pre><p>以及时序图:</p><pre><code class="sequence">Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks!</code></pre><blockquote><p><strong>提示：</strong>想了解更多，请查看<strong>流程图</strong>[语法][3]以及<strong>时序图</strong>[语法][4]。</p></blockquote><h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>使用 <code>- [ ]</code> 和 <code>- [x]</code> 语法可以创建复选框，实现 todo-list 等功能。例如：</p><ul><li><input checked="" disabled="" type="checkbox"> 已完成事项</li><li><input disabled="" type="checkbox"> 待办事项1</li><li><input disabled="" type="checkbox"> 待办事项2</li></ul><blockquote><p><strong>注意：</strong>目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在<strong>马克飞象</strong>中修改 Markdown 原文才可生效。下个版本将会全面支持。</p></blockquote><h2 id="印象笔记相关"><a href="#印象笔记相关" class="headerlink" title="印象笔记相关"></a>印象笔记相关</h2><h3 id="笔记本和标签"><a href="#笔记本和标签" class="headerlink" title="笔记本和标签"></a>笔记本和标签</h3><p><strong>马克飞象</strong>增加了<code>@(笔记本)[标签A|标签B]</code>语法, 以选择笔记本和添加标签。 <strong>绑定账号后</strong>， 输入<code>(</code>自动会出现笔记本列表，请从中选择。</p><h3 id="笔记标题"><a href="#笔记标题" class="headerlink" title="笔记标题"></a>笔记标题</h3><p><strong>马克飞象</strong>会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 <code>欢迎使用马克飞象</code>。</p><h3 id="快捷编辑"><a href="#快捷编辑" class="headerlink" title="快捷编辑"></a>快捷编辑</h3><p>保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到<strong>马克飞象</strong>中打开并编辑该笔记。</p><blockquote><p><strong>注意：</strong>目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。</p></blockquote><h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p><strong>马克飞象</strong>通过<strong>将Markdown原文以隐藏内容保存在笔记中</strong>的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。</p><blockquote><p><strong>隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。</strong></p></blockquote><h3 id="离线存储"><a href="#离线存储" class="headerlink" title="离线存储"></a>离线存储</h3><p><strong>马克飞象</strong>使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过<code>文档管理</code>打开。</p><blockquote><p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，<strong>请务必经常及时同步到印象笔记</strong>。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>create a blog by hexo</title>
      <link href="2016/05/18/create-a-blog-by-hexo/"/>
      <url>2016/05/18/create-a-blog-by-hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-建立博客"><a href="#hexo-建立博客" class="headerlink" title="hexo 建立博客"></a>hexo 建立博客</h1><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>第一步：准备好git nodejs</p><pre><code class="ruby">  [git下载地址](http://git-scm.com/download/)  [node.js下载地址](http://nodejs.cn/)</code></pre><p>  说明下：如果没有git，在windows下可以用cmd命令行，nodejs是必须安装的，第二步会依赖第一步安装的nodejs<br>第二步：<br>  安装全局环境变量—-<br>      * 可以有以下两种<br>        第一种打开安装好的git命令行工具，然后切换目录<br>        代码如下<br>        <code>python          $ npm install -g hexo-cli</code><br>        第二种就是直接在windows命令行<br>        <code>npm install -g hexo-cli</code><br>        PS: “$” 这个符号是git工具命令行自带的<br>第三步：初始化博客文件夹</p><pre><code>    ```java      $ cd d/      $ mkdir hexoblog      $ cd /hexoblog       $ hexo init      $ npm install    ```</code></pre><p>  这一步是下载hexo工具，下载完成后的目录结构<br>  |-_config.yml<br>  |-package.json<br>  |-scafolds<br>  |-source<br>  | |-_drafts<br>  | |-_posts<br>  |-themes</p><p>第四步：配置_config.yml文件，这个文件是关于站点设置的一些信息</p><pre><code>        # Hexo Configuration        ## Docs: http://hexo.io/docs/configuration.html        ## Source: https://github.com/hexojs/hexo/        # Site        title: Hexo ##站点标题 PS：这行的&quot;Hexo ##站点标题&quot;表示注释说明，以下基本都是这样        subtitle: ##站点副标题        description: ##站点描述        author: John Doe ##作者        language: ##语言包，需要主题自带才可设置。如Jcaman自带简繁英，设置简体中文填入 zh-CN        timezone:        # URL        ## If your site is put in a subdirectory, set url as ‘http://yoursite.com/child‘ and root as ‘/child/‘        url: http://yoursite.com ##站点域名        root: /        permalink: :year/:month/:day/:title/ ##文章永久链接格式，可添加.html后缀，如 :title.html        permalink_defaults:        # Directory        source_dir: source        public_dir: public        tag_dir: tags        archive_dir: archives        category_dir: categories        code_dir: downloads/code        i18n_dir: :lang        skip_render:        # Writing        new_post_name: :title.md # File name of new posts        default_layout: post        titlecase: false # Transform title into titlecase        externallink: true # Open external links in new tab        filenamecase: 0        render_drafts: false        post_asset_folder: false        relative_link: false        future: true        highlight:        enable: true        line_number: true        tab_replace:        # Category &amp; Tag        default_category: uncategorized        category_map:        tag_map:        # Date / Time format        ## Hexo uses Moment.js to parse and display date        ## You can customize the date format as defined in        ## http://momentjs.com/docs/#/displaying/format/        date_format: YYYY-MM-DD        time_format: HH:mm:ss        # Pagination        ## Set per_page to 0 to disable pagination        per_page: 10        pagination_dir: page        # Extensions        ## Plugins: http://hexo.io/plugins/        ## Themes: http://hexo.io/themes/        theme: landscape ##当前主题名称        # Deployment        ## Docs: http://hexo.io/docs/deployment.html        deploy:        type: git        repo: git@github.com:iSung/iSung.github.io.git        branch: master</code></pre><p>  PS：deploy 这个为github的一些信息<br><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">hexo教程</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mbe_ui</title>
      <link href="2016/05/11/mbe-ui/"/>
      <url>2016/05/11/mbe-ui/</url>
      
        <content type="html"><![CDATA[<h1 id="mbe-ui-库简介"><a href="#mbe-ui-库简介" class="headerlink" title="mbe_ui 库简介"></a>mbe_ui 库简介</h1><h2 id="mbe-ui-的特点以及想要解决的问题"><a href="#mbe-ui-的特点以及想要解决的问题" class="headerlink" title="mbe_ui 的特点以及想要解决的问题"></a>mbe_ui 的特点以及想要解决的问题</h2><p>mbe_ui 是一个用于开发 HTML 用户界面（GUI）的库，诞生于 MBEditor 项目。它试图解决现有的 JS 模板库、DOM 操作库等存在的一些问题。其特点如下：</p><ul><li><p>采用声明式的 JS 语法描述 HTML DOM 树</p><p>mbe_ui 允许用普通的 JS 对象字面量（称作”虚拟元素”）来描述 DOM 树的结构，因此既是声明式的，又可以利用已有的 JS 技能，无需另外学习模板语言；<br>而且，在 DOM 树的描述中可以直接绑定事件监听器。例如 HTML button 的虚拟元素可以是：</p></li></ul><pre><code class="javascript">  {    Name: &#39;button&#39;,    Kids: [&#39;button1&#39;],    className: &#39;btn&#39;,    onclick: function() { alert(`clicked`); }   }</code></pre><ul><li><p>采用“单向数据流动”的界面更新模式</p><p>这个模式的意思是大部分界面组件无状态，总是从上级发送“设置”数据到各级界面组件，决定其显示的样子（详见“mbe_ui 组件的设计思想”一节）。<br>采用这个模式可以简化界面更新的逻辑。</p></li><li><p>自动局部更新，并尽可能地减小重建 DOM 的范围</p><p>当 HTML 界面在运行时需要更新时，一个比较棘手的问题是如何尽可能地局部更新，而不是大范围地重建 DOM 树。<br>大范围地重建 DOM 树有很多问题，如造成滚动条的位置被重置，选区、焦点被取消，界面卡顿等。然而，求出最小的需要更新的 DOM 的范围并不总是容易的，<br>特别是对复杂的界面来说。<br>mbe_ui 则自动保证尽可能少地重建 DOM。当虚拟元素对象改变时，mbe_ui 将它与上一个版本的虚拟元素对比，然后只把修改了的部分应用到真实的元素中。<br>只有当有效地减小了重建 DOM 的范围，“单向数据流动”的设计模式才具有实用价值。</p></li><li><p>提供简单的界面模块化机制</p><p>mbe_ui 提供了一种简单的机制，允许将界面上的各个部分（如按钮、菜单、标签页）实现为“组件”，从而提高代码的模块化程度。<br>不过，mbe_ui 本身并不提供任何现成的组件。</p></li><li><p>库本身非常小巧，如果愿意，使用者可以将其视为白盒而不是黑盒。</p><p>mbe_ui 的源码目前不到 400 行（含注释），使用者可以很快上手，而且遇到问题完全可以自行调试 mbe_ui 的源码，不必将其视为黑盒。</p></li></ul><h2 id="与现有技术的对比"><a href="#与现有技术的对比" class="headerlink" title="与现有技术的对比"></a>与现有技术的对比</h2><h3 id="与传统方法的对比"><a href="#与传统方法的对比" class="headerlink" title="与传统方法的对比"></a>与传统方法的对比</h3><p>传统上，在 JS 中生成 GUI 的 DOM 树的方法有以下 4 种，但都有一些问题，具体分析如下。</p><ul><li><p>用基本的 DOM 操作方法生成 DOM 树。</p><p>如 <code>Document.createElement()</code>, <code>Element.insertBefore()</code>, <code>Element.style</code>, <code>Element.textContent</code> 等。这是底层的、细粒度的方法，有很好的控制力，但缺点是：（1）书写相当繁琐，（2）代码可读性不佳，从代码中想想构建出来的 DOM 树的结构是比较费脑子的。<br>jQuery 库提供了一组包装方法，比这些原生的 DOM 创建方法的语法要简洁，但是可读性仍然不太好。最根本的问题在于：使用这些方法的代码是命令式的，而不是声明式的；<br>在创建较复杂的 DOM 结构时，我们希望能使用声明式的语法（HTML 就是一种声明式的语言）。</p></li><li><p>将 HTML 字符串，通过 <code>Element::innerHTML</code> 或者 <code>jQuery::html()</code> 等方法解析为 DOM 树。</p><p>这种做法有着明显的缺点：如果 DOM 树比较复杂，在 JS 代码中书写/拼接长长的 HTML 字符串是很丑陋的；此外，绑定事件监听器需要额外的步骤。</p></li><li><p>基于字符串的模板引擎。</p><p>利用诸如 <a href="http://handlebarsjs.com/" target="_blank" rel="noopener">Handlebars.js</a> 这样的模板库，开发者将 HTML 的”骨架“写到一个专门的模板文件中；在运行时，模板引擎解析模板，并其中的占位符替换为 JS 数据对象中的值，再将替换后的 HTML 字符串用 innerHTML 解析为 DOM 树。<br>这类模板库允许用声明式的语法（基本上就是 HTML 语法），但是缺点是：其中的分支、循环等语法多是模板引擎自定义的，不是 JS 语法，需要另外学习。</p></li><li><p>基于 cloneNode() 的模板。</p><p>Element.cloneNode() 方法可以克隆从本元素开始的整个 DOM 树，因此可以将模板放在 HTML 页面中的隐藏元素中，在运行时在 JS 中这样使用： 用 cloneNode() 复制模板 -&gt; 填充数据 -&gt; 插入主 DOM 树显示。最新的 HTML5 标准已经将这个做法标准化，也就是 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template" target="_blank" rel="noopener">template 元素</a>。这个方法允许直接用 HTML 来写模板，但是，”填充数据“这个环节仍然没有很好的解决方案，通常仍然使用命令式的 DOM 方法来完成。</p></li></ul><p>而且，以上 4 种方法都没有试图去减小了重建 DOM 的范围，而是把这个问题留给了使用者。<br>因此在传统的 GUI 程序中，根据数据层的更新来决定哪些视图要被更新是相当复杂的。很多时候为了省事和可靠，采用了整体重建；另一些时候则因为不可靠的局部刷新，<br>造成了界面状态的紊乱。</p><h3 id="与-Facebook-React-的对比"><a href="#与-Facebook-React-的对比" class="headerlink" title="与 Facebook React 的对比"></a>与 Facebook React 的对比</h3><p><a href="http://facebook.github.io/react/" target="_blank" rel="noopener">Facebook React</a> 是最近（2014-）比较热门的 JS 界面框架，mbe_ui 与它想要解决的问题大致重合，采用的技术路线也类似（用虚拟 DOM 来减少重建 DOM 的范围）。事实上，mbe_ui 是借鉴 React 的思想而创建的。</p><p>那么为什么不直接采用 React？</p><ul><li><p>React 比较复杂和庞大（react.js 有19000行，含注释）。除了虚拟 DOM，还提供了在 JS 中嵌入 HTML 的特定领域语言 —— JSX，以及事件封装。<br>我认为虚拟 DOM 和自动局部更新是其精华，但其他部分则不那么必要，至少应是可选的。</p></li><li><p>React 的设计不够清晰简洁。我曾试图去理解它的组件机制是如何工作的，但是发现实在是很绕，不容易弄明白。当然，对于一些用户来说，<br>知其然不知其所以然也没关系。但我认为，一个机制不容易理解的框架，使用起来是不能放心的。</p></li><li><p>React 封装和重新实现了浏览器的事件系统。<br>封装虽然改善了跨浏览器的兼容性，但也给调试带来的麻烦（浏览器的调试器只认得通过原生方法添加的事件监听器）。<br>此外，由于自定义事件不会得到封装，而我们又广泛依赖自定义事件（如 pointer 事件），所以使用 React 的事件系统会比较别扭。</p></li><li><p>React JSX 与 Typescript 语言的结合尚有困难。JSX 的语法与 TS 是有冲突的，因此无法在 TS 中直接使用。在 TS 中使用 JSX 还在<a href="https://github.com/Microsoft/TypeScript/pull/2673" target="_blank" rel="noopener">试验中</a>。</p></li></ul><h2 id="mbe-ui-的应用"><a href="#mbe-ui-的应用" class="headerlink" title="mbe_ui 的应用"></a>mbe_ui 的应用</h2><p>mbe_ui 已经被用于开发“备课大师”的主用户界面，详见以下文件：</p><pre><code>src/master-editor.xhtmlsrc/mbe/shell/            MasterEditorApp.ts            MasterEditorShell.ts            MasterNav.ts            MasterTooBar.ts            MasterResourcePanel.ts            Buttons.ts            Tab.ts            ...</code></pre><p>“备课大师”之前的主用户界面没有用 mbe_ui，是采用较为原始的方法开发的，详见：</p><pre><code>src/editor-shell.xhtmlsrc/mbe/shell/            EditorShell.ts            PageNavigator.ts            PropertyPanel.ts</code></pre><p>可以对比一下。</p><p>另外，mbe_ui 有单元测试，即 <code>test/domer.html</code> 文件，从这个文件里可以看到一些 mbe_ui.Domer 的用法。</p><h2 id="使用-mbe-ui-的虚拟-DOM"><a href="#使用-mbe-ui-的虚拟-DOM" class="headerlink" title="使用 mbe_ui 的虚拟 DOM"></a>使用 mbe_ui 的虚拟 DOM</h2><h3 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h3><p>先举个虚拟元素的例子：</p><pre><code>// 例1{  Name: &#39;section&#39;, // HTML 元素名  Kids: // 子节点  [    { Name: &#39;h1&#39;, Kids: [&#39;大标题...&#39;] },    {      Name: &#39;button&#39;,      &#39;.btn&#39;: true, // HTML class 属性      Kids:      [        { Name: &#39;img&#39;, src: &#39;image/icon1.png&#39; },        &#39;按钮1&#39; // 文本节点      ],      onclick: function(ev) { alert(&#39;clicked&#39;); }, // 事件监听器      &#39;@data-action&#39;: &#39;insert&#39;, // 普通属性 data-action      &#39;-font-family&#39;: &#39;heiti, sans-serif&#39; // CSS 属性 font-family    }  ]}；</code></pre><p>等效于</p><pre><code>&lt;section&gt;  &lt;h1&gt;大标题...&lt;/h1&gt;  &lt;button class=&quot;btn&quot; onclick=&quot;alert(&#39;clicked&#39;)&quot; data-action=&quot;insert&quot;    style=&quot;font-family: heiti, sans-serif&quot;&gt;    &lt;img src=&quot;image/icon1.png&quot; /&gt;&#39;按钮1&#39;  &lt;/button&gt;&lt;/section&gt;</code></pre><p>mbe_ui 虚拟元素就是一个普通的 JS 对象，你可以用 JS 对象字面量的写法来创建。它的各种属性的意义如下：</p><ul><li><p><code>Name</code>：元素名。HTML 元素名应一律用小写。如果忽略，则被认为是 div 元素；如果是”?” 并且“与已有的实际元素相同”，则使用实际元素的名字（这个在后面介绍），否则也认为是 “div”。<br>由于在界面实现中 div 用得很多，所以这是比较方便的。</p></li><li><p><code>Kids</code>：子节点列表，是一个数组，其成员要么是其它虚拟元素，要么是字符串；字符串则对应实际 DOM 中的文本节点。</p></li><li><p>以 <code>@</code> 开头的属性映射到 html/xml 属性，相当于通过 <code>elem.setAttribute(name, value)</code> 的方式赋值（去掉去掉首字符）。</p></li><li><p>以 <code>-</code> 开头的属性开头的属性视为 inline css 属性，通过 <code>elem.style.setProperty(name, value)</code> 的方式赋值（去掉首字符）。</p></li><li><p>以 <code>.</code> 开头的属性视为 html class 属性的片段（去掉首字符），如果相当于 true 则添加到 <code>elem.classList</code> 中，否则删除。</p></li><li><p>其它的属性，如 <code>src</code>, <code>onclick</code>，一般直接映射到同名的 WebIDL 属性，或者作为普通的 JS 属性，相当于通过 <code>elem[name] = value</code> 的方式赋值。<br>而前述的 <code>Name</code>、<code>Kids</code> 属性首字母大写，因此不会与 WebIDL 属性（首字母小写）发生冲突。<br>虚拟元素的一个特色是可以在声明时直接添加函数作为 <code>onclick</code> 等事件的监听器，很方便。</p></li></ul><p>从上面的例子可以看出，虚拟元素的写法很直观，不过代码比起对应的 HTML 的确不那么紧凑，这需要开发者适应一下。<br>不过比起手工拼接 HTML 字符串，或者使用模板引擎来说，还是方便了不少。</p><h3 id="从虚拟元素生成实际元素"><a href="#从虚拟元素生成实际元素" class="headerlink" title="从虚拟元素生成实际元素"></a>从虚拟元素生成实际元素</h3><p>这需要用到 <code>mbe_ui.Domer</code> 类的 <code>render()</code> 方法：</p><pre><code>// 例2var domer = new mbe_ui.Domer();var a = domer.render({ Name: &#39;a&#39;, href: &#39;http://www.w3.org&#39;, Kids: [&#39;W3C&#39;]});</code></pre><p>这样就创建了一个相当于 <code>&lt;a href=&#39;http://www.w3.org&#39;&gt;W3C&lt;/a&gt;</code> 的元素对象（<code>HTMLAnchorElement</code> 的实例）。不过这个元素是独立的，并未添加到当前文档树中。</p><p>如果要用虚拟元素更新已有的实际元素，就要用 2 参数版的<code>render()</code> 方法，第二个参数是实际元素。例如，我们要更新一个 <code>&lt;a&gt;</code> 元素，就可以：</p><pre><code>// 例3var domer = new mbe_ui.Domer();var a = document.createElement(&#39;a&#39;);//此时 a 是 `&lt;a&gt;&lt;/a&gt;`;domer.render({ Name: &#39;a&#39;, href: &#39;http://www.w3.org&#39;, Kids: [&#39;W3C&#39;]}, a);//此时 a 是 `&lt;a href=&#39;http://www.w3.org&#39;&gt;W3C&lt;/a&gt;`</code></pre><p>注意，尽管这个 <code>&lt;a&gt;</code> 元素是新建的，并没有位于文档树中，但 <code>domer.render()</code> 也是可以作用于文档树中已有的元素的。</p><p>如果用 <code>render()</code> 多次作用于同一个实际元素，那么在虚拟元素中以前出现过、后来没有出现的属性、子节点会被删除，例如：</p><pre><code>// 例3var domer = new mbe_ui.Domer();var a = document.createElement(&#39;a&#39;);a.href = &#39;about:blank&#39;;a.textContent = &#39;blank&#39;//此时 a 是 `&lt;a href=&#39;about:blank&#39;&gt;blank&lt;/a&gt;`;domer.render({ Name: &#39;a&#39;, &#39;@data-role&#39;: &#39;link&#39;, href: &#39;http://www.w3.org&#39;,  Kids: [&#39;W3C&#39;, {Name: &#39;img&#39;, src: &#39;w3c.png&#39;} ] },  a);//现在 a 是 &lt;a href=&quot;http://www.w3.org&quot; data-role=&quot;link&quot;&gt;W3C&lt;img href=&quot;w3c.png&quot; /&gt;&lt;/a&gt;domer.render({ Name: &#39;a&#39;, href: &#39;http://www.w3.org&#39;, Kids: [&#39;W3C&#39;] }, a);//现在 a 是 &lt;a href=&quot;http://www.w3.org&quot;&gt;W3C&lt;/a&gt;</code></pre><p>也就是说，第二次调用 render() 时，没有再出现的 <code>data-role</code> 属性和 <code>&lt;img&gt;</code> 子元素都被删除了。<br>这是 mbe_ui.Domer 的一个重要特性，只有这样，才能保证虚拟元素和实际元素的一致性。</p><p>mbe_ui.Domer 尽量保持局部更新。在这个例子中，<code>a</code> 元素本身没有被替换，文本节点 ‘W3C’ 和属性 <code>href</code> 也没有被修改。</p><h3 id="重用子节点的规则"><a href="#重用子节点的规则" class="headerlink" title="重用子节点的规则"></a>重用子节点的规则</h3><p>在使用 <code>render(virtualElem: VElement, realElem?: Element): Element</code> 方法时，如果提供了真实元素（<code>realElem</code>），则渲染时会尽可能的重用它及其子节点。目前的重用/新建规则是：如果节点类型、名字和位置都相同，<br>则重用，否则就新建一个，并替换真实元素。如果虚拟元素的 Name 是 “?”，则认为总是与对应的真实元素的名字相同；如果没有对应的真实元素，则创建一个 div 元素。</p><p>这个重用规则尽可能的减小了更新 DOM 的范围，提高了性能，并减小了失去滚动条位置、焦点、选区的可能性。</p><p>当然，这并没有做到 React 的程度， React 在一定条件下还能够识别子节点的移动并加以重用。</p><h2 id="使用-mbe-ui-的组件框架"><a href="#使用-mbe-ui-的组件框架" class="headerlink" title="使用 mbe_ui 的组件框架"></a>使用 mbe_ui 的组件框架</h2><h3 id="总体概念"><a href="#总体概念" class="headerlink" title="总体概念"></a>总体概念</h3><p>mbe_ui 的组件框架由两个类组成：</p><ul><li><code>mbe_ui.Component</code>：界面组件的基类。用户实现的界面组件要继承这个类。</li><li><code>mbe_ui.UIDomer</code>：用于渲染界面组件的 Domer。它是 mbe_ui.Domer 的子类。</li></ul><p>先举一个例子：</p><pre><code>// 假定已经导入了 mbe_ui.Component 和 mbe_ui.UIDomer。class NumInput extends Component { // 组件都继承 Component 类  value = 0; // 组件实例的一个可变的状态  getView(): VElement { // getView() 应当返回表现当前状态的界面的“展开”后的虚拟元素。此方法由 UIDomer 适时调用。    var view = &lt;VElement&gt;{      // 因为 NumInput 省略了 Name 属性，因此采用默认的元素名 div。      Kids: [        {Name: &#39;span&#39;, Kids: [&#39;&#39; + this.value]}, // 让当前 value 值展现在 span 中        // 绑定 click 事件到 NumInput::onclick() 方法        {Name: &#39;button&#39;, onclick: this.onclick.bind(this), Kids: [&#39;increase&#39;]}      ]    };    return view;  }  onclick(ev: MouseEvent) {    this.value++; // 更新本组件实例的状态    // this.settings 属性是本组件实例的“展开”前的虚拟元素，即 { Class: NumInput, onValueChange: function() {...}} 那个对象。    if (this.settings[&#39;onValueChange&#39;])      this.settings[&#39;onValueChange&#39;].call(this); // 调用 onValueChange 回调。    this.updateLater(); // 请求 UIDomer 稍后更新界面（即将 geView() 得到的虚拟元素 render() 到对应的真实元素）。  }}var uidomer = new UIDomer();var vElement = {  Class: NumInput, // Class 是 mbe_ui 组件框架定义的特殊属性，表示这个元素不是普通元素，而是对应一个 NumInput 组件。  onValueChange: function() { alert(&#39;current value: &#39; + this.value)} // 从 NumInput 组件接收 onValueChange 的通知。};var rElement = uidomer.render(vElement);document.body.appendChild(rElement);</code></pre><p>这里 <code>NumInput</code> 实现了一个文本（<code>span</code>）和按钮（<code>button</code>）的组合组件，点击按钮时，文本上的数字会增加1，并通过 <code>onValueChange</code> 回调报告值的改变。</p><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p>mbe_ui 组件框架的基本工作方式是“展开”。<code>uidomer.render(vElement)</code> 的流程大致如下：</p><ol><li><p>如果 <code>vElement.Class</code> 存在：</p><p> 1.1. 创建组件实例 <code>component = new Class()</code></p><p> 1.2. 设定 <code>settings</code>：<code>component.settings = vElement</code></p><p> 1.3. 调用 <code>getView()</code> 获得展开后的虚拟元素，并替代 <code>vElement</code>：<code>vElement = component.getView()</code>。</p></li><li><p>根据 <code>vElement</code> 创建实际元素 <code>rElement</code>。<br>如果第上一步创建了组件实例，则与 rElement 建立互相连接：<code>rElement.Component = component; component.element = rElement</code>，</p></li><li><p>递归处理 <code>vElement</code> 的子节点，执行 1-4，并将子节点对应的实际元素作为子元素插入 rElement。</p></li><li><p>返回 <code>rElement</code>。</p></li></ol><p>在前面的例子中，1.2 步的 <code>component.settings</code> 和 <code>vElement</code> 是</p><pre><code>{  Class: NumInput,  onValueChange: function() {...}}</code></pre><p>1.3 步的 <code>vElement</code> （展开后）则是</p><pre><code>{  Kids: [    {Name: &#39;span&#39;, Kids: [...]},    {Name: &#39;button&#39;, Kids: [&#39;increase&#39;], onclick: NumInput::onclick }  ]}</code></pre><p>其它一些要点：</p><ul><li><p>组件是可以嵌套的。在一个组件的 <code>getView()</code> 方法返回的虚拟元素中，可以在其子节点中使用其他的组件，<code>UIDomer</code> 会自动地层层展开，<br>从而得到最终的虚拟 DOM 树和真实 DOM 树。</p></li><li><p><code>getView()</code> 通常要利用 <code>settings</code> 属性中的值来确定展开后的形态。</p></li><li><p>如果重新渲染已有的元素，如 <code>uidomer.render(vElement, rElement)</code>，或者 <code>rElement.Component.update()/updateLater()</code> ，<br>则会尽可能重 <code>rElement</code> 和 <code>rElement.Component</code>（只要 <code>Name</code> 和 <code>Class</code> 属性没有变）。<code>rElement</code> 和 <code>rElement.Component</code> 的生存期一般是相同的。</p></li></ul><h3 id="虚拟元素接口"><a href="#虚拟元素接口" class="headerlink" title="虚拟元素接口"></a>虚拟元素接口</h3><p>虚拟元素的正式定义如下：</p><pre><code>interface VElement {  /**   * 元素（本地）名，对 html 元素一定是小写，如&#39;div&#39;。省略时，采用相应实际元素的元素名；如果没有对应实际元素，   * 则认为是 &#39;div&#39;。   */  Name?: string;  /**   * 子节点。string 表示文本节点。   */  Kids?: Array&lt;VElement | string&gt;;  /**   * 本元素对应的组件的类。对自定义组件，用户应指定这个属性。   */  Class?: new() =&gt; mbe_ui.Component;  /**   * 本元素对应的组件的实例。用户无需指定此属性，它由 UIDomer 生成。   */  Component?: mbe_ui.Component;}</code></pre><h3 id="Component-类"><a href="#Component-类" class="headerlink" title="Component 类"></a>Component 类</h3><p>界面组件要继承 Component 类，并且至少要覆盖 getView() 方法来返回自己的界面表示。其他的一些重要的属性和方法如下：</p><pre><code>class Component {  /**   * 对应的 html 元素。Component 不应直接修改它，只有 UIDomer 可以修改它。   */  element: Element;  /**   * 从上层传入的设定（展开前的虚拟元素）。Component 不应修改它，只有 UIDomer 可以修改它。   */  settings: VElement;  /**   * 子类应当覆盖。返回表现当前组件的视图。在每次要将本组件渲染到真实 DOM 前调用。   */  getView(): VElement;  /**   * 重新渲染本 Component。通常在更新了本组件的状态后调用此方法重新渲染界面。   * 这个方法是同步的，会立即修改 DOM。为了减少开销，一般应尽可能用 updateLater() 代替此方法。   */  update(): void;  /**   * 请求稍后异步地（通过 requestAnimationFrame）重新渲染本 Component。   * 通常在更新了本组件的状态后调用此方法重新渲染界面。   * 如果在一组操作中可能重复调用 update()，则用这个方法代替可以减少不必要的重复渲染，提高性能。   */  updateLater(): void;  /**   * 回调，子类可覆盖。当本组件创建并关联到 html 元素后调用，此时 element 属性可用。   */  onAttached(): void;  /**   * 回调，子类可覆盖。当本组件渲染到 html 元素（不论是否新建）后调用。如果是新建的 html 元素，则在 onAttached() 之后调用。   */  onRendered(): void;  /**   * 回调，子类可覆盖。当本组件即将与关联的 html 元素分离，或本组件关联的 html 元素即将被删除时调用。   */  onBeforeRemove(): void;}</code></pre><p>一些要点：</p><ul><li><p><code>update()</code> 和 <code>updateLater()</code> 会调用 <code>uidomer.render(this.settings, this.element)</code> 来更新 <code>this.element</code>。<br><code>render()</code> 则会调用 <code>this.getView()</code> 获得当前的视图形态。这两个方法对于刷新个别组件的视图是很有用的。</p></li><li><p>mbe_ui 并没有类似 React 组件的 refs 属性的机制来访问子组件。我们建议的做法是：给需要从父组件访问的子组件的元素以特定的 <code>id</code> 或 <code>class</code>，<br>然后用<code>this.element.querySelector(...).Component</code> 来得到子组件。</p></li></ul><h3 id="对真实元素-Element-接口的扩展"><a href="#对真实元素-Element-接口的扩展" class="headerlink" title="对真实元素 Element 接口的扩展"></a>对真实元素 Element 接口的扩展</h3><pre><code>interface Element {  Class?: new() =&gt; mbe_ui.Component;  Component?: mbe_ui.Component;}</code></pre><p>UIDomer 在渲染出组件对应的真实元素后，会把相应的组件类和组件实例分别赋值给<code>Class</code>和<code>Component</code>属性。<br>后者尤其有用，因为可以通过真实元素访问到组件的实例，并调用其方法和属性（最常用的可能是<code>updateLater()</code>）。</p><p>此处 <code>Class</code> 和 <code>Component</code> 首字母大写的原因与也是为了避免与 WebIDL 属性发生冲突。</p><h3 id="mbe-ui-组件的设计思想"><a href="#mbe-ui-组件的设计思想" class="headerlink" title="mbe_ui 组件的设计思想"></a>mbe_ui 组件的设计思想</h3><p>mbe_ui 强烈鼓励组件采用“单向数据流动”的设计模式，这也是 React 采用的模式。其特点是：</p><ul><li><p>视图（View）层最好是无状态的（可以有非公开的状态，如菜单是否处于展开状态），<br>其当前显示的样子由从上级传递的参数（即 <code>Component::settings</code> 属性）完全决定。</p></li><li><p>总是描述界面 “现在的样子”，而不是 “怎样修改过去的样子从而得到现在的样子”。后者是传统的 GUI 程序惯用的更新界面的方法，<br>但也是导致程序过于复杂的一个重要原因。在<code>Component::getView()</code> 方法中，用户只需描述“现在的样子”，而怎样修改则交给 <code>UIDomer</code> 去做。</p></li></ul><p>采用“单向数据流动”的设计模式，可以显著简化界面更新的逻辑。</p><h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><h3 id="高级事件监听器"><a href="#高级事件监听器" class="headerlink" title="高级事件监听器"></a>高级事件监听器</h3><p>前面提到的 onclick 等事件监听器属性固然很方便，但是也有局限性：（1）只能添加一个监听器函数<br>（2）只能监听冒泡阶段（bubble phase）的事件，不能监听捕获阶段（catch phase）的事件<br>（3）不能监听自定义事件（因为自定义事件没有对应的 <code>Element::onxxx</code> 属性）。因此，mbe_ui 还提供了另2种高级的事件监听器属性的写法：</p><ul><li><code>*事件名</code>属性：冒泡阶段的事件监听器，可以是函数或者函数的数组，通过 <code>elem.addEventListender()</code> 添加。</li><li><code>!事件名</code>属性：捕获阶段的事件监听器，可以是函数或者函数的数组，通过 <code>elem.addEventListender(..,true)</code> 添加。</li></ul><p>注意此处“事件名”没有 “on” 前缀，应为 “click” 而不是 “onclick”。</p><p>例子：</p><pre><code>var view = {  Name: &#39;button&#39;,  &#39;!pointerdown&#39;: [    function(ev): { console.log(&#39;pointerdown1&#39;);},    function(ev): { console.log(&#39;pointerdown2&#39;);}  ],  &#39;*pointerdown&#39;: function(ev): { console.log(&#39;pointerdown3&#39;);},}</code></pre><p>这个例子中，<code>pointerdown</code> 是个<a href="https://dvcs.w3.org/hg/pointerevents/raw-file/tip/pointerEvents.html" target="_blank" rel="noopener">指针事件</a>。因为尚未被浏览器广泛支持，所以我们只能用自定义事件来模拟它。在捕获阶段我们添加了两个监听函数，冒泡阶段添加了一个监听函数。</p><p>比起直接使用 <code>Element::addEventListender()/removeEventListender()</code>，mbe_ui 的高级事件监听器有一个很好的特性：能确保监听器函数在不需要时总是能被删除——只要下一次渲染时提供的监听器函数与上一次的不是同一对象，<br>那么上一次提供的监听器函数函数就会被删除，因此可以“无忧使用”。相比之下，调用<code>removeEventListender()</code>时传入的函数与调用<br><code>addEventListender()</code> 时传入的函数必须是同一对象才行。</p><h3 id="SVG-MathML-和命名空间"><a href="#SVG-MathML-和命名空间" class="headerlink" title="SVG, MathML 和命名空间"></a>SVG, MathML 和命名空间</h3><p>在 mbe_ui 的虚拟元素中也可以使用 SVG 和 MathML 元素名，例如</p><pre><code>var ve =  {    Name: &#39;div&#39;, // HTML 元素    Kids:    [      {Name: &#39;span&#39;}, // HTML 元素      {Name: &#39;svg&#39;, Kids: [{Name: &#39;line&#39;}]}, // SVG 元素      {Name: &#39;math&#39;, Kids: [{Name:&#39;mn&#39;, Kids: [&#39;2&#39;]}]} // MathML 元素    ]  };</code></pre><p>我们知道，如果文档的类型是 XHTML 时，创建元素时要指定命名空间，尤其是不在 XHTML 命名空间中的 SVG 和 MathML 元素。<br>mbe_ui.Domer 在大多数情况下可以自动推断出合适的命名空间，让 svg 及其子元素采用 SVG 命名空间，让 math 及其子元素采用 MathML 命名空间。<br>不过，用户必须保证 SVG 元素都在 <code>&lt;svg&gt;</code> 之下， MathML 元素都在 <code>&lt;math&gt;</code> 之下，并且不带前缀，否则就无法自动推断了。</p><p>当 mbe_ui.Domer 的自动命名空间推断无法满足要求时，用户可以提供自定义的命名空间推断方法给它，即替换或覆盖<br><code>Domer::inferNamespace(tagName: string): string</code> 方法。参数是虚拟元素的 Name，返回值是命名空间。</p><h3 id="className，-class-和-someClass-属性，style，-style-和-some-style-属性"><a href="#className，-class-和-someClass-属性，style，-style-和-some-style-属性" class="headerlink" title="className，@class 和 .someClass 属性，style，@style 和 -some-style 属性"></a><code>className</code>，<code>@class</code> 和 <code>.someClass</code> 属性，<code>style</code>，<code>@style</code> 和 <code>-some-style</code> 属性</h3><p>在 mbe_ui 中，使用 <code>{ className: &#39;a b&#39;}</code>，<code>{ &#39;@class&#39;: &#39;a b&#39;}</code>与 <code>{ &#39;.a&#39;: true, &#39;.b&#39;: true }</code> 大体上是等效的。在底层，它们分别利用<br><code>Element::className</code>，<code>Element::setAttribute(&#39;class&#39;, ...)</code> 和 <code>Element::classList</code> 来实现。那么如何选择呢？</p><ul><li>在一个虚拟元素上绝对不要混合使用多种方式。如果这样做，多种方式中只有一种会生效，但不保证是哪一种。</li><li><code>.someClass</code> 写法更灵活，尤其适合运行时会动态增减的 class，也适合通过多个步骤创建的虚拟元素，每个步骤都可能添加 class。</li><li><code>className</code> 可以用于明确的、运行时不会改变的 class；<code>@class</code> 与之类似。</li><li>如果不确定，用 <code>.someClass</code> 写法比较安全。</li></ul><p><code>@style</code> 和 <code>-some-style</code> 的关系也是类似的。但是，由于<code>Element::style</code> 不可以直接赋值，所以<strong>绝对不要</strong>在虚拟元素中指定 <code>style</code> 属性。</p><h3 id="终点元素"><a href="#终点元素" class="headerlink" title="终点元素"></a>终点元素</h3><p>虚拟元素可以设定其 <code>Terminal</code> 属性为 true，表示这个元素是终点元素。对于终点元素，Domer 不再处理其子节点，客户代码可自行管理其子节点。<br>这个特性使得可以在 mbe_ui 的终点元素内部使用其他的界面技术。<br>当然，如果在虚拟元素中用了 innerHTML, textContent 等可以影响子节点的属性，则一定要设置 Terminal 为 true。</p><h4 id="by-duanyao"><a href="#by-duanyao" class="headerlink" title="by duanyao"></a>by duanyao</h4>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> JS </tag>
            
            <tag> 虚拟dom </tag>
            
            <tag> mvvm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
